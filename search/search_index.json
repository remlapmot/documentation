{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"These documents are a work-in-progress Please see the Updating the Documentation page if you want to make improvements. What is OpenSAFELY? \ud83d\udd17 OpenSAFELY is a secure analytics platform for electronic health records in the NHS, created to deliver urgent results during the global COVID-19 emergency. It is now successfully delivering analyses across more than 24 million patients' full pseudonymised primary care NHS records, with more to follow shortly. All our analytic software is open for security review, scientific review, and re-use. OpenSAFELY uses a new model for enhanced security and timely access to data: we don't transport large volumes of potentially disclosive pseudonymised patient data outside of the secure environments managed by the electronic health record software company; instead, trusted analysts can run large scale computation across near real-time pseudonymised patient records inside the data centre of the electronic health records software company. As such, the platform maintains extremely high standards for data privacy whilst ensuring complete computational and analytical transparency. Who is OpenSAFELY? \ud83d\udd17 OpenSAFELY is a collaboration between the DataLab at the University of Oxford, the EHR group at London School of Hygiene and Tropical Medicine, TPP and other electronic health record software companies (who already manage NHS patients' records), working on behalf of NHS England and NHSX. Using OpenSAFELY \ud83d\udd17 Only approved users can execute code against the real OpenSAFELY database . However, all the OpenSAFELY-specific tools needed to define analysis datasets, generate dummy data, and run analysis scripts in a computational environment that mimics the secure environment where real analyses are run, are available now for use by anyone. To use OpenSAFELY, users must know, or be willing to learn, the following programs and tools: Essential \ud83d\udd17 Stata, R or Python OpenSAFELY currently supports Stata v16.1, Python 3.8, and R 4.0 for statistical analysis. For security reasons, available libraries are restricted to those provided by the framework. See \"Execution Environments\" for more information. Git The workflow is strongly integrated into Git/GitHub. As a minimum you need to be able to clone a remote git repository, create a branch to work on, commit changes to it, push those changes to the remote repository, create a pull request, and merge branches. See git workflow for advice about how to use git effectively. Desirable \ud83d\udd17 Python The way we specify the data to be extracted for analysis is written in Python, using what we call a study definition . We provide easy-to-use Python functions to define your study population and study variables that are designed to be used and understood by anybody familiar with health research, even if you've neveer used python before. However, some prior knowledge of Python may still be beneficial to create or modify existing functions. SQL Behind the scenes, SQL is the language that is used to extract data from the server. Some knowledge of SQL may be useful if you want to understand in more detail how the raw patient-level data held in the secure environment is converted into analysis-ready datasets. Docker We use Docker containers to simulate the production environment on your machine, so you can test code locally . See our installation pages for complete installation instructions. We recommend following one of our OpenSAFELY walkthroughs (see here ) to guide you through the platform workflow, rather than using the documentation pages alone.","title":"Introduction"},{"location":"#what-is-opensafely","text":"OpenSAFELY is a secure analytics platform for electronic health records in the NHS, created to deliver urgent results during the global COVID-19 emergency. It is now successfully delivering analyses across more than 24 million patients' full pseudonymised primary care NHS records, with more to follow shortly. All our analytic software is open for security review, scientific review, and re-use. OpenSAFELY uses a new model for enhanced security and timely access to data: we don't transport large volumes of potentially disclosive pseudonymised patient data outside of the secure environments managed by the electronic health record software company; instead, trusted analysts can run large scale computation across near real-time pseudonymised patient records inside the data centre of the electronic health records software company. As such, the platform maintains extremely high standards for data privacy whilst ensuring complete computational and analytical transparency.","title":"What is OpenSAFELY?"},{"location":"#who-is-opensafely","text":"OpenSAFELY is a collaboration between the DataLab at the University of Oxford, the EHR group at London School of Hygiene and Tropical Medicine, TPP and other electronic health record software companies (who already manage NHS patients' records), working on behalf of NHS England and NHSX.","title":"Who is OpenSAFELY?"},{"location":"#using-opensafely","text":"Only approved users can execute code against the real OpenSAFELY database . However, all the OpenSAFELY-specific tools needed to define analysis datasets, generate dummy data, and run analysis scripts in a computational environment that mimics the secure environment where real analyses are run, are available now for use by anyone. To use OpenSAFELY, users must know, or be willing to learn, the following programs and tools:","title":"Using OpenSAFELY"},{"location":"#essential","text":"Stata, R or Python OpenSAFELY currently supports Stata v16.1, Python 3.8, and R 4.0 for statistical analysis. For security reasons, available libraries are restricted to those provided by the framework. See \"Execution Environments\" for more information. Git The workflow is strongly integrated into Git/GitHub. As a minimum you need to be able to clone a remote git repository, create a branch to work on, commit changes to it, push those changes to the remote repository, create a pull request, and merge branches. See git workflow for advice about how to use git effectively.","title":"Essential"},{"location":"#desirable","text":"Python The way we specify the data to be extracted for analysis is written in Python, using what we call a study definition . We provide easy-to-use Python functions to define your study population and study variables that are designed to be used and understood by anybody familiar with health research, even if you've neveer used python before. However, some prior knowledge of Python may still be beneficial to create or modify existing functions. SQL Behind the scenes, SQL is the language that is used to extract data from the server. Some knowledge of SQL may be useful if you want to understand in more detail how the raw patient-level data held in the secure environment is converted into analysis-ready datasets. Docker We use Docker containers to simulate the production environment on your machine, so you can test code locally . See our installation pages for complete installation instructions. We recommend following one of our OpenSAFELY walkthroughs (see here ) to guide you through the platform workflow, rather than using the documentation pages alone.","title":"Desirable"},{"location":"code-of-conduct/","text":"Coming soon.","title":"Code of conduct"},{"location":"code-reviews/","text":"These documents are a work-in-progress This section needs to be written! A \"code review\" is an important quality assurance practice. Every time you make a Pull Request in Github, you should ask a collaborator to do a review. This video is a good starting point.","title":"Code reviews"},{"location":"codelist-creation/","text":"Workflow \ud83d\udd17 The general workflow for creating codelists is as follows: Search codelists.opensafely.org for codelists that meet or nearly meet your requirements and make sure that one doesn't already exist If you need to build a new codelist sign up for an account on codelists.opensafely Create a new issue on the codelist -development repo Decide your key terms to search for codes. Good source of key words might be a previous codelist , clinicians or experts in the field and previous research papers When logged into Codelist Builder click \"my codelists\" and then \"create new codelist \" Add/remove terms to your codelists to end up with a list. Save the list as a draft and share the link to your the Github issue. Discuss as a group in the issue your decisions, and the reason for including or excluding different codes. Finalise a list as a group (i.e. at least 2). Detailed reasons are helpful in this issue for referencing in the future. Once agreed, obtain sign-off Clicking \"Save changes\" makes the codelist available on codelists.opensafely.org . Summarise your discussion briefly for the metadata, and reference the issue on the website for more details. This will initially be a draft. When ready, publish it. Close the issue on the codelist -development repo Import the codelist for use in your study definition Create a new issue on the codelist -development repo \ud83d\udd17 The issue title should start with either: *PATIENT* -- non-clinical patient information (demographic, social, etc) *CONDITION* -- specific clinical conditions / disorders / findings / symptoms *DISEASE* -- specific diseases *MEDICINE* -- medicines, treatments, prescriptions, interventions another codelist classification if relevant. The rest of the title should be short and informative. Discuss and document and review \ud83d\udd17 Discuss and document each decision clearly and comprehensively in the issue. Explain why codes have been included and why codes have been excluded. Link to relevant webpages and documents. Upload files. Involve domain experts. Iterate. The current coding systems available in opencodelists are listed below. Coding system CSV column name Pseudo BNF BNFCode CTV3 (Read v3) CTV3Code CTV3 (Read v3) with TPP extensions CTV3Code Dictionary of Medicines and Devises (dm+d) DMDCode International Classification of Diseases 10 ( ICD-10 ) ICD10Code Read v2 Read2Code SNOMED CT SNOMEDCode Each codelist must use exactly one of these systems. The final codelist must be stored in CSV format to be imported into codelists.opensafely.org . The codes must be stored in exactly one column. You can include other columns (such as code descriptions) if useful. There is currently a soft requirement that the codes should be contained in the first column, which should be named as per the list above. For example, if using CTV3 then the column header should be CTV3Code . Do not keep the original codelist in Excel and then filter by a include or exclude column as this will be lost when converted to CSV, and you will end up with all the codes again. Sign-off \ud83d\udd17 Once a draft codelist has been agreed, it must be signed-off by a \"data expert\" (epidemiological sign-off) and \"disease expert\" (clinical sign-off) from at least two different people. Add to codelists.opensafely.org \ud83d\udd17 Go to the openSAFELY new codelist page . You will need an editor account. Ask one of the tech team for one if you do not have one. Fill in the fields. Include lots of detail (specific guidance to follow). CSV data : Export your Spreadsheet to a CSV and choose that file. References : this should include a link to the issue on the codelist -development repo , and any other relevant materials. Sign Off : This should match the people signing off on the issue. You need at least 2 people and can have many more. Click Submit and check the new codelist has appeared on the main site. Exporting a CSV from a Spreadsheet \ud83d\udd17 In Excel go to File Click Export in the left-hand ribbon menu Select Change File Type Click CSV (Comma delimited) (*.csv) Close the issue in the repo \ud83d\udd17 Go to the codelist issue in the codelist repo and close it. This issue serves as documentation of the choices made that determined the final codelist . The issue can be re-opened if revisions are required. Import the codelist for use in your study definition \ud83d\udd17 Once the codelist is in codelists.opensafely.org , you can retrieve it for use in your research repo. Follow these instructions if you're not sure how to do this. Codelist contributorship \ud83d\udd17 How contributions to codelists are acknowledged -- to be agreed. Editing existing codelists \ud83d\udd17 Go to an existing Codelist page. Click Edit metadata. Edit the relevant fields Note: Changing the CSV data requires you Update the current Version or Create a new Version, both can be done from the Codelist page. Add, remove, or edit the References and SignOffs as needed. Click Submit Publishing a Codelist Version \ud83d\udd17 Go to an existing Codelist page. This will show you the latest version for a Codelist If it's a draft version there will be a Publish version button on the left below Create new version. If not, it's already published, good job! Adding a Codelist Version \ud83d\udd17 Go to an existing Codelist page. Click Create new version If you want to update the existing version, click Update version instead.","title":"Building a codelist"},{"location":"codelist-creation/#workflow","text":"The general workflow for creating codelists is as follows: Search codelists.opensafely.org for codelists that meet or nearly meet your requirements and make sure that one doesn't already exist If you need to build a new codelist sign up for an account on codelists.opensafely Create a new issue on the codelist -development repo Decide your key terms to search for codes. Good source of key words might be a previous codelist , clinicians or experts in the field and previous research papers When logged into Codelist Builder click \"my codelists\" and then \"create new codelist \" Add/remove terms to your codelists to end up with a list. Save the list as a draft and share the link to your the Github issue. Discuss as a group in the issue your decisions, and the reason for including or excluding different codes. Finalise a list as a group (i.e. at least 2). Detailed reasons are helpful in this issue for referencing in the future. Once agreed, obtain sign-off Clicking \"Save changes\" makes the codelist available on codelists.opensafely.org . Summarise your discussion briefly for the metadata, and reference the issue on the website for more details. This will initially be a draft. When ready, publish it. Close the issue on the codelist -development repo Import the codelist for use in your study definition","title":"Workflow"},{"location":"codelist-creation/#create-a-new-issue-on-the-codelist-development-repo","text":"The issue title should start with either: *PATIENT* -- non-clinical patient information (demographic, social, etc) *CONDITION* -- specific clinical conditions / disorders / findings / symptoms *DISEASE* -- specific diseases *MEDICINE* -- medicines, treatments, prescriptions, interventions another codelist classification if relevant. The rest of the title should be short and informative.","title":"Create a new issue on the codelist-development repo"},{"location":"codelist-creation/#discuss-and-document-and-review","text":"Discuss and document each decision clearly and comprehensively in the issue. Explain why codes have been included and why codes have been excluded. Link to relevant webpages and documents. Upload files. Involve domain experts. Iterate. The current coding systems available in opencodelists are listed below. Coding system CSV column name Pseudo BNF BNFCode CTV3 (Read v3) CTV3Code CTV3 (Read v3) with TPP extensions CTV3Code Dictionary of Medicines and Devises (dm+d) DMDCode International Classification of Diseases 10 ( ICD-10 ) ICD10Code Read v2 Read2Code SNOMED CT SNOMEDCode Each codelist must use exactly one of these systems. The final codelist must be stored in CSV format to be imported into codelists.opensafely.org . The codes must be stored in exactly one column. You can include other columns (such as code descriptions) if useful. There is currently a soft requirement that the codes should be contained in the first column, which should be named as per the list above. For example, if using CTV3 then the column header should be CTV3Code . Do not keep the original codelist in Excel and then filter by a include or exclude column as this will be lost when converted to CSV, and you will end up with all the codes again.","title":"Discuss and document and review"},{"location":"codelist-creation/#sign-off","text":"Once a draft codelist has been agreed, it must be signed-off by a \"data expert\" (epidemiological sign-off) and \"disease expert\" (clinical sign-off) from at least two different people.","title":"Sign-off"},{"location":"codelist-creation/#add-to-codelistsopensafelyorg","text":"Go to the openSAFELY new codelist page . You will need an editor account. Ask one of the tech team for one if you do not have one. Fill in the fields. Include lots of detail (specific guidance to follow). CSV data : Export your Spreadsheet to a CSV and choose that file. References : this should include a link to the issue on the codelist -development repo , and any other relevant materials. Sign Off : This should match the people signing off on the issue. You need at least 2 people and can have many more. Click Submit and check the new codelist has appeared on the main site.","title":"Add to codelists.opensafely.org"},{"location":"codelist-creation/#exporting-a-csv-from-a-spreadsheet","text":"In Excel go to File Click Export in the left-hand ribbon menu Select Change File Type Click CSV (Comma delimited) (*.csv)","title":"Exporting a CSV from a Spreadsheet"},{"location":"codelist-creation/#close-the-issue-in-the-repo","text":"Go to the codelist issue in the codelist repo and close it. This issue serves as documentation of the choices made that determined the final codelist . The issue can be re-opened if revisions are required.","title":"Close the issue in the repo"},{"location":"codelist-creation/#import-the-codelist-for-use-in-your-study-definition","text":"Once the codelist is in codelists.opensafely.org , you can retrieve it for use in your research repo. Follow these instructions if you're not sure how to do this.","title":"Import the codelist for use in your study definition"},{"location":"codelist-creation/#codelist-contributorship","text":"How contributions to codelists are acknowledged -- to be agreed.","title":"Codelist contributorship"},{"location":"codelist-creation/#editing-existing-codelists","text":"Go to an existing Codelist page. Click Edit metadata. Edit the relevant fields Note: Changing the CSV data requires you Update the current Version or Create a new Version, both can be done from the Codelist page. Add, remove, or edit the References and SignOffs as needed. Click Submit","title":"Editing existing codelists"},{"location":"codelist-creation/#publishing-a-codelist-version","text":"Go to an existing Codelist page. This will show you the latest version for a Codelist If it's a draft version there will be a Publish version button on the left below Create new version. If not, it's already published, good job!","title":"Publishing a Codelist Version"},{"location":"codelist-creation/#adding-a-codelist-version","text":"Go to an existing Codelist page. Click Create new version If you want to update the existing version, click Update version instead.","title":"Adding a Codelist Version"},{"location":"codelist-intro/","text":"What are Codelists? \ud83d\udd17 Codes are alphanumerical codes that are attached to a clinical or event description. There are a few different code systems such as SNOMED and CTV3 , which means one clinical diagnosis can have different codes, depending on the system used. Most code systems arrange their codes in a hierachical structure, meaning a code can be a parent of another code or codes, and a child of another code. This hierarchy allows all possible events within the clinical environment to be organised in a relatively systematic way. Each code refers to a particular event or clinical term such as \"Type 1 Diabetes Mellitus\". Even within a single coding system, there are multiple codes for each disease or symptoms with very precise terms. Clinicians use these codes precisely, though not always consistently, in their every day work. This means that to find all the patients with Type 1 diabetes, you may have to search for 30 plus codes in the clinical record. How did we deal with Codelists? \ud83d\udd17 We built a system for building, reviewing and maintaining codelists at codelists.opensafely.org . Codelists that are hosted on this website can be used directly in the Study Definition. This means there is no need to download or alter these codelists in the study definition , and they can be reused. Applying the principle of open working to making codelists \ud83d\udd17 Our recommended codelist workflow is still in flux We are developing several new features on OpenSAFELY Codelists to help audit and quality-assess codelists. In the mean time, here is what was suggest as best practice for recording your decision-making Make an issue in codelist repo for the Codelist to be discussed Discuss all decisions along the way in the issue, for example, why you decided to exclude \"historical asthma\" from an asthma codelist Who signed off the codelist should be easy to find and transparent. It should be in the Github issue (preferably by the person signing off so they can be contacted via Github) and on the published website. Write a good description for the website on what it does and does not include and summarise any key decisions All study repos will at some point become public (if they are not already), so bear in mind the discussion and conversations will be available for examination These discussions should be linked to from the website - i.e. link the issue to the final codelist where it appears in OpenSAFELY Codelists","title":"Introduction to codelists"},{"location":"codelist-intro/#what-are-codelists","text":"Codes are alphanumerical codes that are attached to a clinical or event description. There are a few different code systems such as SNOMED and CTV3 , which means one clinical diagnosis can have different codes, depending on the system used. Most code systems arrange their codes in a hierachical structure, meaning a code can be a parent of another code or codes, and a child of another code. This hierarchy allows all possible events within the clinical environment to be organised in a relatively systematic way. Each code refers to a particular event or clinical term such as \"Type 1 Diabetes Mellitus\". Even within a single coding system, there are multiple codes for each disease or symptoms with very precise terms. Clinicians use these codes precisely, though not always consistently, in their every day work. This means that to find all the patients with Type 1 diabetes, you may have to search for 30 plus codes in the clinical record.","title":"What are Codelists?"},{"location":"codelist-intro/#how-did-we-deal-with-codelists","text":"We built a system for building, reviewing and maintaining codelists at codelists.opensafely.org . Codelists that are hosted on this website can be used directly in the Study Definition. This means there is no need to download or alter these codelists in the study definition , and they can be reused.","title":"How did we deal with Codelists?"},{"location":"codelist-intro/#applying-the-principle-of-open-working-to-making-codelists","text":"Our recommended codelist workflow is still in flux We are developing several new features on OpenSAFELY Codelists to help audit and quality-assess codelists. In the mean time, here is what was suggest as best practice for recording your decision-making Make an issue in codelist repo for the Codelist to be discussed Discuss all decisions along the way in the issue, for example, why you decided to exclude \"historical asthma\" from an asthma codelist Who signed off the codelist should be easy to find and transparent. It should be in the Github issue (preferably by the person signing off so they can be contacted via Github) and on the published website. Write a good description for the website on what it does and does not include and summarise any key decisions All study repos will at some point become public (if they are not already), so bear in mind the discussion and conversations will be available for examination These discussions should be linked to from the website - i.e. link the issue to the final codelist where it appears in OpenSAFELY Codelists","title":"Applying the principle of open working to making codelists"},{"location":"codelist-project/","text":"Adding Codelist \ud83d\udd17 Take a look at the codelists/codelist.txt file in the repo, and note the structure of the existing example codelists that shipped with the research template: opensafely/<codelist-name>/<YYYY-MM-DD> If you want a codelist from codelists.opensafely.org , then you need to put it in this format in the codelist.txt file. For example: codelist.txt: opensafely/aplastic-anaemia/2020-04-24 opensafely/asplenia/2020-06-02 opensafely/current-asthma/2020-05-06 Adding CSV to file \ud83d\udd17 Download the new codelists into the codelist/ folder using the opensafely program by running opensafely codelists update Beware that in Windows, if one or more of these codelist files is open then this command won't be able to run; close them first. You will need to add and commit these changes and push to Github. If you don't, or a newer version is available than that committed, the automated tests will fail with an error message.","title":"Adding codelists to Project"},{"location":"codelist-project/#adding-codelist","text":"Take a look at the codelists/codelist.txt file in the repo, and note the structure of the existing example codelists that shipped with the research template: opensafely/<codelist-name>/<YYYY-MM-DD> If you want a codelist from codelists.opensafely.org , then you need to put it in this format in the codelist.txt file. For example: codelist.txt: opensafely/aplastic-anaemia/2020-04-24 opensafely/asplenia/2020-06-02 opensafely/current-asthma/2020-05-06","title":"Adding Codelist"},{"location":"codelist-project/#adding-csv-to-file","text":"Download the new codelists into the codelist/ folder using the opensafely program by running opensafely codelists update Beware that in Windows, if one or more of these codelist files is open then this command won't be able to run; close them first. You will need to add and commit these changes and push to Github. If you don't, or a newer version is available than that committed, the automated tests will fail with an error message.","title":"Adding CSV to file"},{"location":"codelist-snomed/","text":"SNOMED CT Codelists generated from CTV3 \ud83d\udd17 At the time of writing (26 Oct 2020), most SNOMED CT Codelists on codelists.opensafely.org have been generated from CTV3 Codelists using a mapper function . They have not been reviewed, or used in any research. They are clearly marked with \"Automatically-generated equivalent\" within the description. Codelists now built in SNOMED \ud83d\udd17 When the codelist builder came online in August / September, it defaults to creating new codelists in SNOMED and then mapping to CTV3 where needed. This is because SNOMED has more codes than the other coding systems and therefore we do not lose granularity going from one coding system to another. To convert a new SNOMED code to CTV3 , please contact the tech team. This is currently manually run but will be automated soon.","title":"SNOMED codelists"},{"location":"codelist-snomed/#snomed-ct-codelists-generated-from-ctv3","text":"At the time of writing (26 Oct 2020), most SNOMED CT Codelists on codelists.opensafely.org have been generated from CTV3 Codelists using a mapper function . They have not been reviewed, or used in any research. They are clearly marked with \"Automatically-generated equivalent\" within the description.","title":"SNOMED CT Codelists generated from CTV3"},{"location":"codelist-snomed/#codelists-now-built-in-snomed","text":"When the codelist builder came online in August / September, it defaults to creating new codelists in SNOMED and then mapping to CTV3 where needed. This is because SNOMED has more codes than the other coding systems and therefore we do not lose granularity going from one coding system to another. To convert a new SNOMED code to CTV3 , please contact the tech team. This is currently manually run but will be automated soon.","title":"Codelists now built in SNOMED"},{"location":"cohortextractor/","text":"cohortextractor is a Python module built for OpenSAFELY. It is used to convert the study definition into an actual analysis-ready dataset based on dummy or real data. The dataset it creates can be either: A dummy dataset used for developing and testing analysis code on the user's own machine. Users have control over the characteristics of each dummy variable, which are defined inside the study definition . A real dataset created from the OpenSAFELY database, used for the analysis proper. Real datasets never leave the secure server, only summary data and other outputs that are derived from them can be released (after disclosivity checks). cohortextractor also performs some other tasks, like creating Measures , and many of the functions that are needed within the a study definition script. Installing cohortextractor \ud83d\udd17 In most cases you won't need to install cohortextractor directly . Instead, you create an action in your project.yaml file and run it via opensafely run <action> . This will use cohortextractor via a Docker image rather than a local installation. If you need to install, follow these instructions Go to the Anaconda prompt and submit the following command (or use another method to install the module if you know how): pip install opensafely-cohort-extractor To check this has installed successfully, submit `cohortextractor --version`. ## Updating `cohortextractor` If you need to install a new version, update with: pip install --upgrade opensafely-cohort-extractor Using cohortextractor in the project.yaml \ud83d\udd17 Typically, you will be writing cohortextractor commands inside the project.yaml and executing them using the opensafely run command. The available cohortextractor commands and how they are declared in the project.yaml are detailed below. generate_cohort \ud83d\udd17 This is the command used to generate a dataset from the study definition . A basic generate_cohort action looks like this: generate_study_cohort run : cohortextractor:latest generate_cohort outputs : highly_sensitive : data : output/input.csv The size of the dummy dataset is determined by the population_size option in the project.yaml . Running the action with opensafely run generate_study_population will create the file output/input.csv . Running the action again will overwrite the existing dataset with a new one (check the file's modified date) which will contain different data than previously (even if the study_definition.py didn't change) because the values are randomly generated. Beware that on Windows, you can't have input.csv open and generate a new one at the same time. If you have multiple study definitions in the repo (e.g., study_definition_cohort1.py and study_definition_cohort2.py ) then generate_cohort will by default create a dataset for each and name them appropriately (e.g., input_cohort1.csv and input_cohort2.csv ). You can restrict the command to produce a single study definition using the study-definition option, like this: generate_study_cohort run : cohortextractor:latest generate_cohort --study-definition study_definition_cohort2 outputs : highly_sensitive : data : output/input_cohort2.csv You can change the location of the outputted .csv file using the --ouput-dir option, for example run: cohortextractor:latest generate_cohort --ouput-dir output/cohorts","title":"cohortextractor"},{"location":"cohortextractor/#installing-cohortextractor","text":"In most cases you won't need to install cohortextractor directly . Instead, you create an action in your project.yaml file and run it via opensafely run <action> . This will use cohortextractor via a Docker image rather than a local installation. If you need to install, follow these instructions Go to the Anaconda prompt and submit the following command (or use another method to install the module if you know how): pip install opensafely-cohort-extractor To check this has installed successfully, submit `cohortextractor --version`. ## Updating `cohortextractor` If you need to install a new version, update with: pip install --upgrade opensafely-cohort-extractor","title":"Installing cohortextractor"},{"location":"cohortextractor/#using-cohortextractor-in-the-projectyaml","text":"Typically, you will be writing cohortextractor commands inside the project.yaml and executing them using the opensafely run command. The available cohortextractor commands and how they are declared in the project.yaml are detailed below.","title":"Using cohortextractor in the project.yaml"},{"location":"cohortextractor/#generate_cohort","text":"This is the command used to generate a dataset from the study definition . A basic generate_cohort action looks like this: generate_study_cohort run : cohortextractor:latest generate_cohort outputs : highly_sensitive : data : output/input.csv The size of the dummy dataset is determined by the population_size option in the project.yaml . Running the action with opensafely run generate_study_population will create the file output/input.csv . Running the action again will overwrite the existing dataset with a new one (check the file's modified date) which will contain different data than previously (even if the study_definition.py didn't change) because the values are randomly generated. Beware that on Windows, you can't have input.csv open and generate a new one at the same time. If you have multiple study definitions in the repo (e.g., study_definition_cohort1.py and study_definition_cohort2.py ) then generate_cohort will by default create a dataset for each and name them appropriately (e.g., input_cohort1.csv and input_cohort2.csv ). You can restrict the command to produce a single study definition using the study-definition option, like this: generate_study_cohort run : cohortextractor:latest generate_cohort --study-definition study_definition_cohort2 outputs : highly_sensitive : data : output/input_cohort2.csv You can change the location of the outputted .csv file using the --ouput-dir option, for example run: cohortextractor:latest generate_cohort --ouput-dir output/cohorts","title":"generate_cohort"},{"location":"coming-soon/","text":"Coming soon.","title":"Not just another TRE"},{"location":"dataset-apc/","text":"Admitted Patient Care ( APC ) is the national data set for hospital admissions. APCS is part of Hospital Episode Statistics ( HES ) and is provided to OpenSAFELY via NHS Digital's Secondary Use Service ( SUS ). Metadata \ud83d\udd17 Data provider NHS England. Participation / Coverage In-hospital patient admissions in NHS Trusts in England. Update frequency in OpenSAFELY Approximately monthly. Delay between event occurring and event appearing in OpenSAFELY Approximately 1-2 months. Collected information Admission and discharge dates; admission and discharge locations; reason for admission; diagnoses; treatments; discharge destination. Diagnoses are coded using ICD-10 . Procedures are coded in OPCS-4 . Each row is a in-hospital Spell. In-hospital episodes cannot be queried. An episode is a period of continuous care under a single responsible consultant. A spell is a period of continuous care within a single trust. Essentially, a spell is a collection of episodes (often just one episode) denoting the entirety of a patient's stay in hospital from admission to discharge or death. An episode denotes time within a spell spent under the responsibility of a single consultant. So for example if within your hospital stay you are transferred from a medical to surgical ward, or transferred to another site (within the same trust), there will be at least two episodes within your spell. The dataset does not include any patients who have not been discharged (i.e., patients who have an incomplete spell) at the data extraction date. In other words, the data will be missing admissions of the patients with the longest stay for the most recent admissions. More information \ud83d\udd17 Notebook showing breakdown of ethnicity codes ) - (private, pending review & publication) NHS Digital SUS site NHS Digital HES site Hospital APC Activity reports NHS Digital APC data dictionary Data resource profile: Hospital Episode Statistics Admitted Patient Care ( HES APC ) CLOSER Understanding Hospital Episode Statistics","title":"Hospital admissions"},{"location":"dataset-apc/#metadata","text":"Data provider NHS England. Participation / Coverage In-hospital patient admissions in NHS Trusts in England. Update frequency in OpenSAFELY Approximately monthly. Delay between event occurring and event appearing in OpenSAFELY Approximately 1-2 months. Collected information Admission and discharge dates; admission and discharge locations; reason for admission; diagnoses; treatments; discharge destination. Diagnoses are coded using ICD-10 . Procedures are coded in OPCS-4 . Each row is a in-hospital Spell. In-hospital episodes cannot be queried. An episode is a period of continuous care under a single responsible consultant. A spell is a period of continuous care within a single trust. Essentially, a spell is a collection of episodes (often just one episode) denoting the entirety of a patient's stay in hospital from admission to discharge or death. An episode denotes time within a spell spent under the responsibility of a single consultant. So for example if within your hospital stay you are transferred from a medical to surgical ward, or transferred to another site (within the same trust), there will be at least two episodes within your spell. The dataset does not include any patients who have not been discharged (i.e., patients who have an incomplete spell) at the data extraction date. In other words, the data will be missing admissions of the patients with the longest stay for the most recent admissions.","title":"Metadata"},{"location":"dataset-apc/#more-information","text":"Notebook showing breakdown of ethnicity codes ) - (private, pending review & publication) NHS Digital SUS site NHS Digital HES site Hospital APC Activity reports NHS Digital APC data dictionary Data resource profile: Hospital Episode Statistics Admitted Patient Care ( HES APC ) CLOSER Understanding Hospital Episode Statistics","title":"More information"},{"location":"dataset-cpns/","text":"The Covid-19 Patient Notification System ( CPNS ) is the route by which NHS England are informed of positive COVID-19 in-hospital deaths. Initially this was lab-confirmed covid deaths only, but also includes suspected cases from 28 April 2020 onwards. Metadata \ud83d\udd17 Data provider NHS England. Participation / Coverage In-hospital covid-related deaths in England. Update frequency in OpenSAFELY Weeekly. Delay between event occurring and event appearing in OpenSAFELY Within 2 weeks. Available from 24/03/2020 onwards (all test-positive deaths); 28/04/2020 onwards (test-positive and covid documented as underlying cause). Collected information Admission, test, result, and death dates; hospital and department of death; basic demographics. More information \ud83d\udd17 Notebook showing breakdown of ethnicity codes ) - (private, pending review & publication) Press release from Arden&GEM Letter from NHSE to Trust chief execs regarding changes to data collection Technical summary on data series on deaths in people with COVID-19","title":"In-hospital deaths (covid-19 only)"},{"location":"dataset-cpns/#metadata","text":"Data provider NHS England. Participation / Coverage In-hospital covid-related deaths in England. Update frequency in OpenSAFELY Weeekly. Delay between event occurring and event appearing in OpenSAFELY Within 2 weeks. Available from 24/03/2020 onwards (all test-positive deaths); 28/04/2020 onwards (test-positive and covid documented as underlying cause). Collected information Admission, test, result, and death dates; hospital and department of death; basic demographics.","title":"Metadata"},{"location":"dataset-cpns/#more-information","text":"Notebook showing breakdown of ethnicity codes ) - (private, pending review & publication) Press release from Arden&GEM Letter from NHSE to Trust chief execs regarding changes to data collection Technical summary on data series on deaths in people with COVID-19","title":"More information"},{"location":"dataset-ecds/","text":"The Emergency Care Data Set ( ECDS ) is the national data set for urgent and emergency care. ECDS is part of Hospital Episode Statistics ( HES ) and is provided to OpenSAFELY via NHS Digital's Secondary Use Service ( SUS ) Metadata \ud83d\udd17 Data provider NHS England. Participation / Coverage Emergency Department attendances in NHS Trusts in England. Update frequency in OpenSAFELY Approximately monthly. Delay between event occurring and event appearing in OpenSAFELY * Approximately 1-2 months. Collected information Attendance, admission and discharge dates; locations; presenting complaints; diagnoses. Diagnoses and discharge destinations are coded using SNOMED-CT . More information \ud83d\udd17 Notebook showing breakdown of ethnicity codes ) - (private, pending review & publication) NHS Digital ECDS site NHS Digital SUS site NHS Digital HES site NHS Digital ECDS data dictionary NHS Digital ECDS Information Standard NHS Digital ECDS Technical Output Specification ECDS Data Quality Dashboards","title":"Emergency attendances"},{"location":"dataset-ecds/#metadata","text":"Data provider NHS England. Participation / Coverage Emergency Department attendances in NHS Trusts in England. Update frequency in OpenSAFELY Approximately monthly. Delay between event occurring and event appearing in OpenSAFELY * Approximately 1-2 months. Collected information Attendance, admission and discharge dates; locations; presenting complaints; diagnoses. Diagnoses and discharge destinations are coded using SNOMED-CT .","title":"Metadata"},{"location":"dataset-ecds/#more-information","text":"Notebook showing breakdown of ethnicity codes ) - (private, pending review & publication) NHS Digital ECDS site NHS Digital SUS site NHS Digital HES site NHS Digital ECDS data dictionary NHS Digital ECDS Information Standard NHS Digital ECDS Technical Output Specification ECDS Data Quality Dashboards","title":"More information"},{"location":"dataset-icnarc/","text":"The ICNARC -CMP dataset contains information on covid-related intensive care admissions in England. From ICNARC 's website: The Case Mix Programme (CMP) is an audit of patient outcomes from adult, general critical care units (intensive care and combined intensive care/high dependency units) covering England, Wales and Northern Ireland. The CMP is listed in the Department of Health's 'Quality Accounts' as a recognised national audit by the National Advisory Group on Clinical Audit & Enquiries (NAGCAE) for 'Acute' care. Currently only Covid-19 positive patients are provided by ICNARC . Metadata \ud83d\udd17 Data provider ICNARC Participation / Coverage Adult ICU/HDUs admissions in England, Wales, NI. Specialist units (eg neuro / cardiac) also participate. covid-19 admissions only Provenance ICUs and HDUs Update frequency in OpenSAFELY Approximately weekly. Delay between event occurring and event appearing in OpenSAFELY Approximately 1-2 weeks. Collected information Admission, discharge and transfer dates; reason for admission; clinical support/interventions; clinical findings More Information \ud83d\udd17 CMP resources \u2014 this is comprehensive, and includes links to the data dictionary, CRF, data flows, and other useful resources. Datasource-specific glossary \ud83d\udd17 Advanced respiratory support unclear, possibly non-intubated ventilation Basic respiratory support unclear, possibly intubated ventilation Admission these include any admission to ICU even if the patient did not require critical care, for example due to bed pressures elsewhere in the hospital. It may be useful to filter by severity, e.g., ventilated patients only. Similarly, potentially critically ill patients cared-for by ICU staff but who are admitted to a different unit will not be included in the CMP. Each admission is a row, so patients transferred to other units will appear in the dataset multiple times, even if it\u2019s part of the same spell.","title":"Intensive care admissions (covid-19 only)"},{"location":"dataset-icnarc/#metadata","text":"Data provider ICNARC Participation / Coverage Adult ICU/HDUs admissions in England, Wales, NI. Specialist units (eg neuro / cardiac) also participate. covid-19 admissions only Provenance ICUs and HDUs Update frequency in OpenSAFELY Approximately weekly. Delay between event occurring and event appearing in OpenSAFELY Approximately 1-2 weeks. Collected information Admission, discharge and transfer dates; reason for admission; clinical support/interventions; clinical findings","title":"Metadata"},{"location":"dataset-icnarc/#more-information","text":"CMP resources \u2014 this is comprehensive, and includes links to the data dictionary, CRF, data flows, and other useful resources.","title":"More Information"},{"location":"dataset-icnarc/#datasource-specific-glossary","text":"Advanced respiratory support unclear, possibly non-intubated ventilation Basic respiratory support unclear, possibly intubated ventilation Admission these include any admission to ICU even if the patient did not require critical care, for example due to bed pressures elsewhere in the hospital. It may be useful to filter by severity, e.g., ventilated patients only. Similarly, potentially critically ill patients cared-for by ICU staff but who are admitted to a different unit will not be included in the CMP. Each admission is a row, so patients transferred to other units will appear in the dataset multiple times, even if it\u2019s part of the same spell.","title":"Datasource-specific glossary"},{"location":"dataset-intro/","text":"This section provides contextual information on the core primary care EHR systems on which OpenSAFELY in based, as well as all external datasets imported to the secure EHR environment. To query the data, see the study definition section . Use the navigation pane on the left-hand side to view information on each dataset. External sources and record linkage \ud83d\udd17 Currently, all data available for analysis are for patients registered at GP practices who use the SystmOne clinical information system, managed by TPP . Patient records from external datasets are imported and matched to the core data as follows: Patient records from other external sources are matched to SystmOne records on NHS numbers via a salted hash : Usually this is done by the data controllers of the external dataset \u2014 that is, hashed NHS numbers for patients in OpenSAFELY are sent to the external data controller, they identify all the matching records in their dataset, and then send only those records back to OpenSAFELY. For some datasets ( ICNARC ), OpenSAFELY receives the hashed NHS numbers from the external dataset and the matching occurs inside OpenSAFELY. The matched IDs are then sent back and the matched records are returned to OpenSAFELY. No other identifiers (names, postcodes, DOBs etc) are used for matching, though this may change in future. No patient identifiers are imported from external datasets. Only records for patients with matching NHS numbers are imported to OpenSAFELY (i.e., left_join(SystmOne, External, by='NHSNumber') ). Matching quality is dependent on the quality of NHS numbers (they're good but not infallible). Currently there is no direct evaluation of linkage quality because by design (minimisation of the transfer of sensitive data) we don't have access to direct identifiers from external datasets; nor do we know in general if we should be expecting a match or not. OpenSAFELY- TPP database builds \ud83d\udd17 The OpenSAFELY- TPP database is typically built once per week. In essence, this involves refreshing records in SystmOne so that the records from the following groups are available for analysis: All patients currently registered 1 at a TPP practice All patients registered at any time from 2009-01-01 onwards, but having since de-registered All patients registered at any time from 2009-01-01 onwards, but having since died. These three groups constitute the patient population available for analysis within OpenSAFELY. Note that any primary care events occurring in de-registered patients after the de-registration date will not be available in the TPP patient record, though any events recorded in external linked datasets (such as hospitals admissions or deaths) will be visible. Every time the database is re-built there will be slight differences in study populations, either due to new registrations or changes to patient records that include/exclude them from the study cohort. Old database builds cannot be recovered, and due to the differences between successive database builds, old study populations are unlikely to be re-extracted exactly as before. When TPP receive data from external data sources (eg ONS ), the data in the relevant tables is completely replaced. For those with access to the OpenSAFELY database, the latest database build time is available in the LatestBuildTime table, and the history of builds for each dataset is available in the BuildInfo table. Descriptive metadata \ud83d\udd17 OpenSAFELY- TPP database table examples (based on dummy data) (private, needs occasional refreshes) OpenSAFELY- TPP Database Schema Latest available records in SystmOne and external datasets Historical coverage of records in SystmOne and external datasets OpenSAFELY-EMIS database builds \ud83d\udd17 This section is a work in progress. When EMIS receive data from external data sources (eg ONS ), records are appended to the relevant tables. The relevant tables have an upload_date column, and to get the latest data, we have to query for on upload_date . \"Registered\" here means a patient with a full \"GMS\" (General Medical Services) registration. Patients with temporary registrations are not included. \u21a9","title":"Overview"},{"location":"dataset-intro/#external-sources-and-record-linkage","text":"Currently, all data available for analysis are for patients registered at GP practices who use the SystmOne clinical information system, managed by TPP . Patient records from external datasets are imported and matched to the core data as follows: Patient records from other external sources are matched to SystmOne records on NHS numbers via a salted hash : Usually this is done by the data controllers of the external dataset \u2014 that is, hashed NHS numbers for patients in OpenSAFELY are sent to the external data controller, they identify all the matching records in their dataset, and then send only those records back to OpenSAFELY. For some datasets ( ICNARC ), OpenSAFELY receives the hashed NHS numbers from the external dataset and the matching occurs inside OpenSAFELY. The matched IDs are then sent back and the matched records are returned to OpenSAFELY. No other identifiers (names, postcodes, DOBs etc) are used for matching, though this may change in future. No patient identifiers are imported from external datasets. Only records for patients with matching NHS numbers are imported to OpenSAFELY (i.e., left_join(SystmOne, External, by='NHSNumber') ). Matching quality is dependent on the quality of NHS numbers (they're good but not infallible). Currently there is no direct evaluation of linkage quality because by design (minimisation of the transfer of sensitive data) we don't have access to direct identifiers from external datasets; nor do we know in general if we should be expecting a match or not.","title":"External sources and record linkage"},{"location":"dataset-intro/#opensafely-tpp-database-builds","text":"The OpenSAFELY- TPP database is typically built once per week. In essence, this involves refreshing records in SystmOne so that the records from the following groups are available for analysis: All patients currently registered 1 at a TPP practice All patients registered at any time from 2009-01-01 onwards, but having since de-registered All patients registered at any time from 2009-01-01 onwards, but having since died. These three groups constitute the patient population available for analysis within OpenSAFELY. Note that any primary care events occurring in de-registered patients after the de-registration date will not be available in the TPP patient record, though any events recorded in external linked datasets (such as hospitals admissions or deaths) will be visible. Every time the database is re-built there will be slight differences in study populations, either due to new registrations or changes to patient records that include/exclude them from the study cohort. Old database builds cannot be recovered, and due to the differences between successive database builds, old study populations are unlikely to be re-extracted exactly as before. When TPP receive data from external data sources (eg ONS ), the data in the relevant tables is completely replaced. For those with access to the OpenSAFELY database, the latest database build time is available in the LatestBuildTime table, and the history of builds for each dataset is available in the BuildInfo table.","title":"OpenSAFELY-TPP database builds"},{"location":"dataset-intro/#descriptive-metadata","text":"OpenSAFELY- TPP database table examples (based on dummy data) (private, needs occasional refreshes) OpenSAFELY- TPP Database Schema Latest available records in SystmOne and external datasets Historical coverage of records in SystmOne and external datasets","title":"Descriptive metadata"},{"location":"dataset-intro/#opensafely-emis-database-builds","text":"This section is a work in progress. When EMIS receive data from external data sources (eg ONS ), records are appended to the relevant tables. The relevant tables have an upload_date column, and to get the latest data, we have to query for on upload_date . \"Registered\" here means a patient with a full \"GMS\" (General Medical Services) registration. Patients with temporary registrations are not included. \u21a9","title":"OpenSAFELY-EMIS database builds"},{"location":"dataset-onsdeaths/","text":"Date and cause of death based on information recorded when deaths are certified and registered in England and Wales. Metadata \ud83d\udd17 Data provider Office for National Statistics. Participation / Coverage Deaths occurring in England and Wales, including non-residents. Provenance General Register Office. Update frequency in OpenSAFELY Approximately weeekly. Available from deaths recorded from X onwards. Delay between event occurring and event appearing in OpenSAFELY Approximately 1-2 weeks. Collected information Date of death, causes of death, age, sex. Causes of death are coded using ICD-10 . More information \ud83d\udd17 Information collected at death registration User guide to mortality statistics Meta data Glossary \ud83d\udd17 Underlying cause of death (icd10u) A cause code that identifies the medical condition judged to be the underlying cause of death according to the rules of the 10th Revision of the International Classification of Diseases . This field appears once for each cause coded routine and inquest death (deaths at age 28 days and over). This code is generally known as 'the cause of death' and is used in single cause tabulations and analyses. The death is assigned the ICD10U code on the basis of ICD-10 codes allocated to the death by the MICAR program. A coder may also manually assign these codes to a death record. Primary / secondary cause of death These are not concepts used in ONS cause of death data. There is the underlying cause, and then a list of up to 15 medical conditions ( ICD10001 to ICD10015 , given as ICD-10 codes) mentioned on the death certificate. These codes are not ordered meaningfully.","title":"Registered deaths"},{"location":"dataset-onsdeaths/#metadata","text":"Data provider Office for National Statistics. Participation / Coverage Deaths occurring in England and Wales, including non-residents. Provenance General Register Office. Update frequency in OpenSAFELY Approximately weeekly. Available from deaths recorded from X onwards. Delay between event occurring and event appearing in OpenSAFELY Approximately 1-2 weeks. Collected information Date of death, causes of death, age, sex. Causes of death are coded using ICD-10 .","title":"Metadata"},{"location":"dataset-onsdeaths/#more-information","text":"Information collected at death registration User guide to mortality statistics Meta data","title":"More information"},{"location":"dataset-onsdeaths/#glossary","text":"Underlying cause of death (icd10u) A cause code that identifies the medical condition judged to be the underlying cause of death according to the rules of the 10th Revision of the International Classification of Diseases . This field appears once for each cause coded routine and inquest death (deaths at age 28 days and over). This code is generally known as 'the cause of death' and is used in single cause tabulations and analyses. The death is assigned the ICD10U code on the basis of ICD-10 codes allocated to the death by the MICAR program. A coder may also manually assign these codes to a death record. Primary / secondary cause of death These are not concepts used in ONS cause of death data. There is the underlying cause, and then a list of up to 15 medical conditions ( ICD10001 to ICD10015 , given as ICD-10 codes) mentioned on the death certificate. These codes are not ordered meaningfully.","title":"Glossary"},{"location":"dataset-sgsscovid/","text":"The Second Generation Surveillance System ( SGSS ) is an application that stores and manages data on laboratory isolates and notifications, and is the preferred method for capturing routine laboratory surveillance data on infectious diseases and antimicrobial resistance from laboratories across England. -- PHE Laboratory Reporting Guidelines, page 6 SGSS data currently available in OpenSAFELY is for SARS-COV-2 test results from the UK's Pillar 1 and Pillar 2 tests. Some SARS-CoV-2 testing info also flows directly into the primary care record from SGSS (see below). Metadata \ud83d\udd17 Data provider Public Health England Participation / Coverage Unclear, and varies over time Provenance PHE and NHS hospital testing labs Update frequency in OpenSAFELY Approximately monthly Delay between event occurring and event appearing in OpenSAFELY Approximately 1-2 weeks. Collected information Earliest specimen date, lab report date, age, sex, county, test result, source (\"pillar 2\" or \"other\") Overview \ud83d\udd17 SGSS contains Information on patients receiving a swab test for SARS-CoV-2, from Pillar 1 (NHS and PHE labs) and Pillar 2 (commercial partners). It includes \"earliest specimen date\" (when the sample was taken); \"lab report date\" (when the result was uploaded to SGSS system); pillar 2 or \"other\"; result (pos/neg); some demographics. The are two tables, one for positive tests and one for negative tests. Multiple tests for the same person are treated as a single 'infection episode', no matter how far apart, and so the system will only return the earliest test (sample date and report date), and all subsequent tests are dropped. 'Infection episodes' are split by test results, so SGSS will in theory return data for both the earliest positive test, and the earliest negative test. However, negative testing data appears to be incomplete. Other viruses/organisms may have a finite episode length, so that any tests occurring within say the first 14 days of the first test are dropped, but for coronavirus the episode length is indefinite, though this may change in future. Negative test data is unreliable \u2014 DO NOT USE SARS-CoV-2 test results from various sources are also coded within SystmOne . More information \ud83d\udd17 Regarding lab-confirmed cases National COVID-19 surveillance reports Testing methodology Testing strategy","title":"Covid-19 test results"},{"location":"dataset-sgsscovid/#metadata","text":"Data provider Public Health England Participation / Coverage Unclear, and varies over time Provenance PHE and NHS hospital testing labs Update frequency in OpenSAFELY Approximately monthly Delay between event occurring and event appearing in OpenSAFELY Approximately 1-2 weeks. Collected information Earliest specimen date, lab report date, age, sex, county, test result, source (\"pillar 2\" or \"other\")","title":"Metadata"},{"location":"dataset-sgsscovid/#overview","text":"SGSS contains Information on patients receiving a swab test for SARS-CoV-2, from Pillar 1 (NHS and PHE labs) and Pillar 2 (commercial partners). It includes \"earliest specimen date\" (when the sample was taken); \"lab report date\" (when the result was uploaded to SGSS system); pillar 2 or \"other\"; result (pos/neg); some demographics. The are two tables, one for positive tests and one for negative tests. Multiple tests for the same person are treated as a single 'infection episode', no matter how far apart, and so the system will only return the earliest test (sample date and report date), and all subsequent tests are dropped. 'Infection episodes' are split by test results, so SGSS will in theory return data for both the earliest positive test, and the earliest negative test. However, negative testing data appears to be incomplete. Other viruses/organisms may have a finite episode length, so that any tests occurring within say the first 14 days of the first test are dropped, but for coronavirus the episode length is indefinite, though this may change in future. Negative test data is unreliable \u2014 DO NOT USE SARS-CoV-2 test results from various sources are also coded within SystmOne .","title":"Overview"},{"location":"dataset-sgsscovid/#more-information","text":"Regarding lab-confirmed cases National COVID-19 surveillance reports Testing methodology Testing strategy","title":"More information"},{"location":"dataset-systmone/","text":"Overview \ud83d\udd17 SystmOne is a Primary Care clinical information system run by The Phoenix Partnership, used by roughly one third of GP practices in England, with records for approximately 44% of the English population. Its primary purpose is patient management, though the data may be used for research. It captures symptoms, test results, diagnoses, prescriptions, onward referrals, demographic and social characteristics, etc. Essentially everything about a patient that is electronically recorded or accessed by GPs. The SystmOne database contains various tables for events, medications, registrations, and so on, and some additional custom tables have been created specifically for OpenSAFELY. This is typically to make administrative and geographic grouping information available (like household membership) without disclosing of identifiable patient data (like addresses). Event coding \ud83d\udd17 SystmOne uses an augmented version of CTV3 Read Codes to classify clinical events, and only data that is associated with a Read Code can be accessed in OpenSAFELY \u2014 we do not have access to free text data. SARS-CoV-2 test results \ud83d\udd17 SARS-CoV-2 test result data is incorporated into SystmOne and uses the following CTV3 codes: Y20d1 SARS-CoV-2 (severe acute respiratory syndrome coronavirus 2) RNA (ribonucleic acid) detection result positive Y20d2 SARS-CoV-2 (severe acute respiratory syndrome coronavirus 2) RNA (ribonucleic acid) detection result negative Y23f6 SARS-CoV-2 (severe acute respiratory syndrome coronavirus 2) RNA (ribonucleic acid) detection result unknown These are coded in response to data flowing from Pillar 1 and Pillar 2 . (At the time of writing, Dec 2020, Moonshot community tests are also planned to be incorporated) Dates \ud83d\udd17 All coded events should be accompanied by an event date. However, invalid or highly unusual dates are possible and may occur for a number of reasons; for instance, when a GP is coding an important event in the patient's medical history but the exact date is not known. Additional derived data \ud83d\udd17 Geographic and administrative groupings \ud83d\udd17 A patient registers with a practice using their home address. The postcode from this address is mapped to an Output Area, from which other larger geographic representations such as LSOA, MSOA, CCG, and STP can be derived (see various ONS publications for more detail). MSOA \ud83d\udd17 According to our identifiable data minimimisation principles, only representations as large or larger than MSOA are available to be extracted into a study cohort for analysis. Of ~36 million active patient addresses, less than 55,000 have no MSOA code set. These are a split of no postcode entered, an invalid postcode entered, and no fixed abode. IMD \ud83d\udd17 IMD (the English Index of Multiple Deprivation) is a ranking of LSOAs based on various characteristics of the region. The ranking ranges from 1 to around 33000 (the number of LSOAs in England), but is rounded to the nearest 100 so that the exact LSOA cannot be derived. IMD rankings are redone every 3 or 4 years. For some newly built residences, there is no associated IMD rank, and so IMD is not defined in that case. Occasionally a patient has multiple active registrations on a given date. The chosen postcode is chosen as follows: choose the registration with the latest start date; if this is not unique, then choose the registration with the latest end date; if this is not unique, choose at random. If a patient's postcode is not recorded, then these geographic variables are not available for analysis. Household membership \ud83d\udd17 Content to be written","title":"Primary care records"},{"location":"dataset-systmone/#overview","text":"SystmOne is a Primary Care clinical information system run by The Phoenix Partnership, used by roughly one third of GP practices in England, with records for approximately 44% of the English population. Its primary purpose is patient management, though the data may be used for research. It captures symptoms, test results, diagnoses, prescriptions, onward referrals, demographic and social characteristics, etc. Essentially everything about a patient that is electronically recorded or accessed by GPs. The SystmOne database contains various tables for events, medications, registrations, and so on, and some additional custom tables have been created specifically for OpenSAFELY. This is typically to make administrative and geographic grouping information available (like household membership) without disclosing of identifiable patient data (like addresses).","title":"Overview"},{"location":"dataset-systmone/#event-coding","text":"SystmOne uses an augmented version of CTV3 Read Codes to classify clinical events, and only data that is associated with a Read Code can be accessed in OpenSAFELY \u2014 we do not have access to free text data.","title":"Event coding"},{"location":"dataset-systmone/#sars-cov-2-test-results","text":"SARS-CoV-2 test result data is incorporated into SystmOne and uses the following CTV3 codes: Y20d1 SARS-CoV-2 (severe acute respiratory syndrome coronavirus 2) RNA (ribonucleic acid) detection result positive Y20d2 SARS-CoV-2 (severe acute respiratory syndrome coronavirus 2) RNA (ribonucleic acid) detection result negative Y23f6 SARS-CoV-2 (severe acute respiratory syndrome coronavirus 2) RNA (ribonucleic acid) detection result unknown These are coded in response to data flowing from Pillar 1 and Pillar 2 . (At the time of writing, Dec 2020, Moonshot community tests are also planned to be incorporated)","title":"SARS-CoV-2 test results"},{"location":"dataset-systmone/#dates","text":"All coded events should be accompanied by an event date. However, invalid or highly unusual dates are possible and may occur for a number of reasons; for instance, when a GP is coding an important event in the patient's medical history but the exact date is not known.","title":"Dates"},{"location":"dataset-systmone/#additional-derived-data","text":"","title":"Additional derived data"},{"location":"dataset-systmone/#geographic-and-administrative-groupings","text":"A patient registers with a practice using their home address. The postcode from this address is mapped to an Output Area, from which other larger geographic representations such as LSOA, MSOA, CCG, and STP can be derived (see various ONS publications for more detail).","title":"Geographic and administrative groupings"},{"location":"dataset-systmone/#msoa","text":"According to our identifiable data minimimisation principles, only representations as large or larger than MSOA are available to be extracted into a study cohort for analysis. Of ~36 million active patient addresses, less than 55,000 have no MSOA code set. These are a split of no postcode entered, an invalid postcode entered, and no fixed abode.","title":"MSOA"},{"location":"dataset-systmone/#imd","text":"IMD (the English Index of Multiple Deprivation) is a ranking of LSOAs based on various characteristics of the region. The ranking ranges from 1 to around 33000 (the number of LSOAs in England), but is rounded to the nearest 100 so that the exact LSOA cannot be derived. IMD rankings are redone every 3 or 4 years. For some newly built residences, there is no associated IMD rank, and so IMD is not defined in that case. Occasionally a patient has multiple active registrations on a given date. The chosen postcode is chosen as follows: choose the registration with the latest start date; if this is not unique, then choose the registration with the latest end date; if this is not unique, choose at random. If a patient's postcode is not recorded, then these geographic variables are not available for analysis.","title":"IMD"},{"location":"dataset-systmone/#household-membership","text":"Content to be written","title":"Household membership"},{"location":"git-workflow/","text":"git is a command-line tool for recording, sharing and collaborating on code. Github is a Microsoft-owned company (and website) that makes it easy to use git , and adds extra collaboration and security tools on top. They also make Github Desktop, a convenient graphical user interface for git. Github provide good documentation about best practices. This walkthrough is essential reading for new users, and this slideshow summarises some best practice. Editing the Study Definition and gitting changes \ud83d\udd17 The general workflow for making changes to your code is as follows: Create a new branch. A branch is a way for you to record and publish your own changes without breaking things for other people who are using the same code. It is also a good way of collecting changes (\"commits\") into a meaningful unit that can be reviewed by others. Edit/add/delete files in the repo on that branch, committing regularly with informative commit messages. Push the changes to GitHub, so that others can view the branch. Continue to commit and push changes on that branch until you believe it's ready to be merged back into the main codebase that everyone uses. Submit a pull request (PR), requesting that the branch be reviewed by somebody else. A PR is simply a way of viewing, commenting on, and approving branches. Watch out for the automated tests passing or failing!","title":"Using Git effectively"},{"location":"git-workflow/#editing-the-study-definition-and-gitting-changes","text":"The general workflow for making changes to your code is as follows: Create a new branch. A branch is a way for you to record and publish your own changes without breaking things for other people who are using the same code. It is also a good way of collecting changes (\"commits\") into a meaningful unit that can be reviewed by others. Edit/add/delete files in the repo on that branch, committing regularly with informative commit messages. Push the changes to GitHub, so that others can view the branch. Continue to commit and push changes on that branch until you believe it's ready to be merged back into the main codebase that everyone uses. Submit a pull request (PR), requesting that the branch be reviewed by somebody else. A PR is simply a way of viewing, commenting on, and approving branches. Watch out for the automated tests passing or failing!","title":"Editing the Study Definition and gitting changes"},{"location":"good-practice-intro/","text":"These documents are a work-in-progress This section will contain information on the core primary care EHR on which OpenSAFELY in based, as well as all external datasets imported to the secure EHR environment.","title":"Good practice"},{"location":"install-docker/","text":"Why Docker? \ud83d\udd17 Docker allows you to run identical software on all platforms. It creates \"containers\" that are guaranteed to be identical on any system that can run Docker. OpenSAFELY uses Docker to run your code in a reproducible, safe manner. This is most helpful for checking that you will be able to successfully run your code on the OpenSAFELY server on real data. If you only run your code locally using your own installation of R, say, then you won't know if the version of R (and the packages) installed on the server will run your code without errors or unexpected behaviours. See the Testing Your Code section for more details on how to test your code in practice. Unfortunately, Docker is happiest on Linux; on Windows and Mac OSX, installation can be a chore. These notes should help. Installation \ud83d\udd17 Windows and Macs have different installation processes. Regardless of machine, you will have to install Docker and make an account on the Docker Website . There are two flavours you can install, Desktop and Toolbox . Docker Desktop is preferred over Docker Toolbox. Windows \ud83d\udd17 Docker Desktop in Windows offers native support via Hyper-V containers, and so is preferred. To install Docker Desktop on Windows 10 64-bit Pro, Enterprise, or Education build 15063 or later (i.e., most university of institution managed machines) follow these installation instructions To install Docker Desktop on Windows Home follow these installation instructions . Windows users who log into an Active Directory domain (i.e., a network login) may find they lack permissions to start Docker correctly. If so, follow these instructions . It is best to install using the default settings. You may be asked to enable the Hyper-V and Containers features, which you should do. You can do this by following these instructions . At least one user has had the box ticked on the screen but had to untick and tick again to get this to enable correctly (Detailed in issue #4 ). Starting Docker can take a while \u2014 up to 5 minutes. While it's doing so, an animation runs in the notification area: Another notification appears when it's finished. \"Running\" means there's a docker service running on your computer, to which you can connect using the command line. You can check it's up and running by opening a Terminal and entering docker info , which should output a load of diagnostics. To be able to access the windows filesystem from the docker container (and therefore do development inside the Docker container with results appearing in a place visible to Git), you must explicitly share your hard drive in the Docker settings (click system tray docker icon; select \"settings\"; select \"shared drives\") Network login issues \ud83d\udd17 When installing from the office, and logged in as a network user, there have been permission problems that have been solved by adding the special \"Authenticated Users\" group to the docker-users group, per this comment (screenshot of place to do it here ). Finally, note that when authentication changes (e.g., different logins), you sometimes have to reauthorise Docker's \"Shared Drives\" (click system tray docker icon; select \"settings\"; select \"shared drives\"; click Reset credentials; retick the drive to share; Apply) Macs \ud83d\udd17 Follow the instructions from the Docker website. You may have to restart your computer during installation. Once you have Docker installed, you will need to log in. This can be accessed via the Applications Folder and once you have logged in, you should have the Docker icon on the top taskbar (next to battery icon, etc.) Once this is running, you should be able to use Docker. Gotchas \ud83d\udd17 The first time you use Docker or use a new Docker template, please be aware that it takes a long time to make the build. It is easy to think that it has frozen, but it will take quite a while to get going. If this is the case, look at this cat whilst you wait:","title":"Docker"},{"location":"install-docker/#why-docker","text":"Docker allows you to run identical software on all platforms. It creates \"containers\" that are guaranteed to be identical on any system that can run Docker. OpenSAFELY uses Docker to run your code in a reproducible, safe manner. This is most helpful for checking that you will be able to successfully run your code on the OpenSAFELY server on real data. If you only run your code locally using your own installation of R, say, then you won't know if the version of R (and the packages) installed on the server will run your code without errors or unexpected behaviours. See the Testing Your Code section for more details on how to test your code in practice. Unfortunately, Docker is happiest on Linux; on Windows and Mac OSX, installation can be a chore. These notes should help.","title":"Why Docker?"},{"location":"install-docker/#installation","text":"Windows and Macs have different installation processes. Regardless of machine, you will have to install Docker and make an account on the Docker Website . There are two flavours you can install, Desktop and Toolbox . Docker Desktop is preferred over Docker Toolbox.","title":"Installation"},{"location":"install-docker/#windows","text":"Docker Desktop in Windows offers native support via Hyper-V containers, and so is preferred. To install Docker Desktop on Windows 10 64-bit Pro, Enterprise, or Education build 15063 or later (i.e., most university of institution managed machines) follow these installation instructions To install Docker Desktop on Windows Home follow these installation instructions . Windows users who log into an Active Directory domain (i.e., a network login) may find they lack permissions to start Docker correctly. If so, follow these instructions . It is best to install using the default settings. You may be asked to enable the Hyper-V and Containers features, which you should do. You can do this by following these instructions . At least one user has had the box ticked on the screen but had to untick and tick again to get this to enable correctly (Detailed in issue #4 ). Starting Docker can take a while \u2014 up to 5 minutes. While it's doing so, an animation runs in the notification area: Another notification appears when it's finished. \"Running\" means there's a docker service running on your computer, to which you can connect using the command line. You can check it's up and running by opening a Terminal and entering docker info , which should output a load of diagnostics. To be able to access the windows filesystem from the docker container (and therefore do development inside the Docker container with results appearing in a place visible to Git), you must explicitly share your hard drive in the Docker settings (click system tray docker icon; select \"settings\"; select \"shared drives\")","title":"Windows"},{"location":"install-docker/#network-login-issues","text":"When installing from the office, and logged in as a network user, there have been permission problems that have been solved by adding the special \"Authenticated Users\" group to the docker-users group, per this comment (screenshot of place to do it here ). Finally, note that when authentication changes (e.g., different logins), you sometimes have to reauthorise Docker's \"Shared Drives\" (click system tray docker icon; select \"settings\"; select \"shared drives\"; click Reset credentials; retick the drive to share; Apply)","title":"Network login issues"},{"location":"install-docker/#macs","text":"Follow the instructions from the Docker website. You may have to restart your computer during installation. Once you have Docker installed, you will need to log in. This can be accessed via the Applications Folder and once you have logged in, you should have the Docker icon on the top taskbar (next to battery icon, etc.) Once this is running, you should be able to use Docker.","title":"Macs"},{"location":"install-docker/#gotchas","text":"The first time you use Docker or use a new Docker template, please be aware that it takes a long time to make the build. It is easy to think that it has frozen, but it will take quite a while to get going. If this is the case, look at this cat whilst you wait:","title":"Gotchas"},{"location":"install-github-and-git/","text":"OpenSAFELY uses GitHub to store the code used to create and analyse the study data. GitHub is based on git , an industry-standard version control system that helps multiple contributors manage and share code effectively. GitHub also supports convenient publication of your code, so that anybody can view it, comment on it, and use it themselves. We require that anyone who uses OpenSAFELY publish their code on publication of their papers. A good starting point for understanding version control in the context of scientific research has been written by The Turing Way collaborative. If you are completely new to these concepts or want to understand more then we suggest reading through their chapter on version control . To get set up, you will need: A GitHub account git installed on your local machine New to git \ud83d\udd17 For Windows or macOS users new to git, the easiest way to do both is to install GitHub Desktop . This includes a command line version of git and a useful GUI for editing files and gitting. To install GitHub Desktop, visit the GitHub Desktop homepage and click install for your operating system. Once installed, it will ask you to create or sign-in to your GitHub account. Follow the instructions as appropriate. Once signed in, you'll be taken to a Let's get started page. You'll need to install other OpenSAFELY requirements before diving in. Old to git \ud83d\udd17 If you already have git installed and prefer using your existing git workflow, then this is fine. If you're not sure if you already have git installed, type git --version into any command line terminal. Access to the OpenSAFELY GitHub organisation \ud83d\udd17 This is only necessary for running code against the real data. Ask us to be added . If you're not sure if you already have access, go to settings > security in GitHub and see if opensafely is listed. You will need Two-factor authentication for your GitHub account to join the organisation. To set up 2FA follow these instructions . If you're not sure if you already have 2FA enabled, go to settings > security > Two-factor authentication in GitHub and check that at least one method is Configured .","title":"GitHub and Git"},{"location":"install-github-and-git/#new-to-git","text":"For Windows or macOS users new to git, the easiest way to do both is to install GitHub Desktop . This includes a command line version of git and a useful GUI for editing files and gitting. To install GitHub Desktop, visit the GitHub Desktop homepage and click install for your operating system. Once installed, it will ask you to create or sign-in to your GitHub account. Follow the instructions as appropriate. Once signed in, you'll be taken to a Let's get started page. You'll need to install other OpenSAFELY requirements before diving in.","title":"New to git"},{"location":"install-github-and-git/#old-to-git","text":"If you already have git installed and prefer using your existing git workflow, then this is fine. If you're not sure if you already have git installed, type git --version into any command line terminal.","title":"Old to git"},{"location":"install-github-and-git/#access-to-the-opensafely-github-organisation","text":"This is only necessary for running code against the real data. Ask us to be added . If you're not sure if you already have access, go to settings > security in GitHub and see if opensafely is listed. You will need Two-factor authentication for your GitHub account to join the organisation. To set up 2FA follow these instructions . If you're not sure if you already have 2FA enabled, go to settings > security > Two-factor authentication in GitHub and check that at least one method is Configured .","title":"Access to the OpenSAFELY GitHub organisation"},{"location":"install-intro/","text":"This section provides instructions for installing git, GitHub, Python, and Docker, all of which are needed to use OpenSAFELY from your own computer. These tools are required for, or greatly simplify, the following tasks: defining the data you want to extract from the database importing codelists creating dummy data for developing analysis scripts testing analysis scripts locally running the analysis on the server For the analysis proper, you can use Stata, R, or Python (almost) however you wish \u2014 see the pipelines section for guidance and exceptions. Additionally, to use OpenSAFELY fully you will need some platform-specific permissions, for instance to be able to submit analyses to run on the server. We will issue these as required.","title":"Overview"},{"location":"install-macos/","text":"macOS Install Guide \ud83d\udd17 This guide was created using macOS 11.1 It is expected that this guide should work from 10.14 upwards but has only been tested with 11.1 Open Terminal.app by clicking the magnifying glass icon in the top right of your screen. Type terminal and hit enter. Install Homebrew , this should install the Xcode Command Line Tools for you as well. This command might take a while to run depending on the speed of your internet connection. /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh ) \" Once homebrew is installed use it to install pipx and pyenv : brew install pipx pyenv Next, install Docker for Mac , GitHub Desktop , and Visual Studio Code : brew install --cask docker github visual-studio-code Use pyenv to install Python: This command might take a while to run depending on the speed of your computer. pyenv install 3 .9.1 Then install the OpenSAFELY CLI with pipx, using the Python installed in the previous step: pipx install opensafely --python ~/.pyenv/shims/python3.9 Test the installation of OpenSAFELY CLI. This should print out the usage and available sub commands: % opensafely --help usage: opensafely [ -h ] [ --version ] COMMAND ... optional arguments: -h, --help show this help message and exit --version show program ' s version number and exit available commands: COMMAND help Show this help message and exit run Run project.yaml actions locally codelists Commands for interacting with https://codelists.opensafely.org/ Set up Docker by opening the app you installed earlier: open /Applications/Docker.app You'll be warned about the system dialogue which is about to pop up, choose \"OK\". Enter your password and click \"Install Helper\". Now that the Docker application is open you can click \"Skip tutorial\" and close the window. The Docker service will continue to run in the background and can be accessed from the Docker icon in your menu bar. You're done! Now you can navigate to a research repo, on your local machine, and use opensafely via the command line .","title":"macOS"},{"location":"install-macos/#macos-install-guide","text":"This guide was created using macOS 11.1 It is expected that this guide should work from 10.14 upwards but has only been tested with 11.1 Open Terminal.app by clicking the magnifying glass icon in the top right of your screen. Type terminal and hit enter. Install Homebrew , this should install the Xcode Command Line Tools for you as well. This command might take a while to run depending on the speed of your internet connection. /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh ) \" Once homebrew is installed use it to install pipx and pyenv : brew install pipx pyenv Next, install Docker for Mac , GitHub Desktop , and Visual Studio Code : brew install --cask docker github visual-studio-code Use pyenv to install Python: This command might take a while to run depending on the speed of your computer. pyenv install 3 .9.1 Then install the OpenSAFELY CLI with pipx, using the Python installed in the previous step: pipx install opensafely --python ~/.pyenv/shims/python3.9 Test the installation of OpenSAFELY CLI. This should print out the usage and available sub commands: % opensafely --help usage: opensafely [ -h ] [ --version ] COMMAND ... optional arguments: -h, --help show this help message and exit --version show program ' s version number and exit available commands: COMMAND help Show this help message and exit run Run project.yaml actions locally codelists Commands for interacting with https://codelists.opensafely.org/ Set up Docker by opening the app you installed earlier: open /Applications/Docker.app You'll be warned about the system dialogue which is about to pop up, choose \"OK\". Enter your password and click \"Install Helper\". Now that the Docker application is open you can click \"Skip tutorial\" and close the window. The Docker service will continue to run in the background and can be accessed from the Docker icon in your menu bar. You're done! Now you can navigate to a research repo, on your local machine, and use opensafely via the command line .","title":"macOS Install Guide"},{"location":"install-python/","text":"* Please read even if you already have Python installed * For security, consistency, and readability, OpenSAFELY provides an API built in Python for using the platform. This API includes script-based functions for specifying the patients and variables that make up a study dataset (using a study definition ), and command line functions for importing codelists, generating dummy data, and testing that the study definition can be run successfully on the server. Python version 3.7 or higher must be installed on your machine to perform these tasks. Many functions are provided in a Python module called opensafely which will also need to be installed \u2014 see the opensafely CLI section for more details. Windows users \ud83d\udd17 For Windows users, we recommend that you install Anaconda (Individual Edition) , a popular Python distribution that includes an recent version of Python, many useful Python packages, and an environment manager. This will help avoid some fiddly annoyances when dealing with multiple versions/installations of Python. To install, follow these instructions . Accept the default/recommended settings unless you understand the consequences of changing them. This should have added Python and Anaconda Prompt to your machine (as well as a few other things). To to verify that you can run Python with Anaconda Prompt, open it and submit python --version . You should use the Anaconda Prompt whenever you want to use the opensafely package. Go to the opensafely CLI section for instructions on how to install this module. mac users \ud83d\udd17 not yet documented","title":"Python"},{"location":"install-python/#windows-users","text":"For Windows users, we recommend that you install Anaconda (Individual Edition) , a popular Python distribution that includes an recent version of Python, many useful Python packages, and an environment manager. This will help avoid some fiddly annoyances when dealing with multiple versions/installations of Python. To install, follow these instructions . Accept the default/recommended settings unless you understand the consequences of changing them. This should have added Python and Anaconda Prompt to your machine (as well as a few other things). To to verify that you can run Python with Anaconda Prompt, open it and submit python --version . You should use the Anaconda Prompt whenever you want to use the opensafely package. Go to the opensafely CLI section for instructions on how to install this module.","title":"Windows users"},{"location":"install-python/#mac-users","text":"not yet documented","title":"mac users"},{"location":"measures/","text":"The Measures framework allows you to extract multiple datasets covering different time periods, and calculates a set of measures for each period. Measures are expressed as a quotient (i.e., a numerator divided by a denominator) which in practice could be used to calculate proportions, ratios, means, counts, and so on. For example, we may wish to calculate, for each month in 2020 and each STP (administrative health regions in England), the proportion of patients who were admitted to hospital at least once and the proportion of patients who died. Without Measures, this would require creating a set of variables (or a study definition ) for each month of interest containing: the region; whether or not they were admitted to hospital; whether or not they died, and we would then need to use these datasets to calculate the desired proportion and aggregate the results. Measures makes this process simple. Defining measures \ud83d\udd17 Generating measures is a three step process: Define a study definition that includes a measures variable, which should be a list calls to the Measure() function. Extract the data by running generate_cohort using the --index-date-range option to cover the range of time periods we want to calculate the measure for. Calculate the measures by running generate_measures which takes the files extracted in step 2 and produces files like measure_<measure_id>.csv . Define a study definition \ud83d\udd17 The study_definition.py script for the example above is: from cohortextractor import StudyDefinition , Measure , patients study = StudyDefinition ( # Configure the expectations framework default_expectations = { \"date\" : { \"earliest\" : \"2020-01-01\" , \"latest\" : \"today\" }, \"rate\" : \"exponential_increase\" , \"incidence\" : 0.2 }, index_date = \"2020-01-01\" , population = patients . registered_as_of ( \"index_date\" ), stp = patients . registered_practice_as_of ( \"index_date\" , returning = \"stp_code\" , return_expectations = { \"category\" : { \"ratios\" : { \"stp1\" : 0.1 , \"stp2\" : 0.2 , \"stp3\" : 0.7 }}, \"incidence\" : 1 } ), sex = patients . sex ( return_expectations = { \"rate\" : \"universal\" , \"category\" : { \"ratios\" : { \"M\" : 0.49 , \"F\" : 0.51 }}, } ), admitted = patients . admitted_to_hospital ( returning = \"binary_flag\" , between = [ \"index_date\" , \"last_day_of_month(index_date)\" ], return_expectations = { \"incidence\" : 0.1 }, ), died = patients . died_from_any_cause ( between = [ \"index_date\" , \"last_day_of_month(index_date)\" ], returning = \"binary_flag\" , return_expectations = { \"incidence\" : 0.05 }, ), ) measures = [ Measure ( id = \"hosp_admission_by_stp\" , numerator = \"admitted\" , denominator = \"population\" , group_by = \"stp\" , ), Measure ( id = \"death_by_stp\" , numerator = \"died\" , denominator = \"population\" , group_by = \"stp\" , ), ] This differs from a normal study definition due to the addition of the measures object, which is a list of calls to the Measure() function, for each measure. id is just a string used to identify the measure output file. numerator and denominator are the columns in the dataset that define the measure. They must be numeric or boolean (encoded as 0 or 1). group_by column can be of any type. To calculate the measure across the entire population, you can set group_by=\"population\" . If not specified, group_by will default to None and the measure will be calculated at the individual patient level. You can calculate measures for more than one group at a time by specifying multiple variables as follows: measures = [ Measure ( id = \"hosp_admission_by_stp\" , numerator = \"admitted\" , denominator = \"population\" , group_by = [ \"stp\" , \"sex\" ], ), Measure ( id = \"death_by_stp\" , numerator = \"died\" , denominator = \" population\" , group_by = [ \"stp\" , \"sex\" ], ), ] Extract the data \ud83d\udd17 To run multiple study definitions over a series of dates, use the --index-date-range option of the generate_cohort command. Rather than generating a single output CSV file this generates multiple output files across a range of dates, modifying the study's index date each time. The range is specified as: --index-date-range \"YYYY-MM-DD to YYYY-MM-DD by (week|month)\" It also excepts today in place of a date. Output files are named like: output/input_YYYY-MM-DD.csv There is also a --skip-existing option which will cause the cohortextractor to skip the extraction step for any dates where the corresponding file already exists. This makes it easier to incrementally extract data for new months/weeks without having to re-extract everything. Example: cohortextractor generate_cohort --index-date-range \"2020-01-01 to 2020-12-01 by month\" ...which will output: output/input_2020-01-01.csv output/input_2020-02-01.csv ... output/input_2020-12-01.csv Calculate the measures \ud83d\udd17 This is done using the generate_measures command: cohortextractor generate_measures For each defined measure, and for each file extracted in step 2, this generates an output file with the measure calculated for that month or week. output/measure_hosp_admission_by_stp_2020-01-01.csv output/measure_death_by_stp_2020-01-01.csv output/measure_hosp_admission_by_stp_2020-02-01.csv output/measure_death_by_stp_2020-02-01.csv ... output/measure_hosp_admission_by_stp_2020-12-01.csv output/measure_death_by_stp_2020-12-01.csv Finally, for each measure, it combines all the output into a single file with an additional date column indicating the date associated with each row. output/measure_hosp_admission_by_stp.csv output/measure_death_by_stp.csv This command also respects the --skip-existing flag. This will prevent it from recalculating the measure for any months or weeks which have already been calculated. However the final step, which combines output across time periods, will always be run. Putting it all together in a pipeline \ud83d\udd17 To generate the final outputs measure_hosp_admission_by_stp.csv and measure_death_by_stp.csv in a project pipeline , you would use the following actions: generate_study_population : run : cohortextractor:latest generate_cohort --study-definition study_definition --index-date-range \"2020-01-01 to 2020-12-01 by month\" --skip-existing --output-dir=output/measures outputs : highly_sensitive : cohort : output/measures/input_*.csv generate_measures : run : cohortextractor:latest generate_measures --study-definition study_definition --skip-existing --output-dir=output/measures needs : [ generate_study_population ] outputs : moderately_sensitive : measure_csv : output/measures/measure_*.csv","title":"Measures"},{"location":"measures/#defining-measures","text":"Generating measures is a three step process: Define a study definition that includes a measures variable, which should be a list calls to the Measure() function. Extract the data by running generate_cohort using the --index-date-range option to cover the range of time periods we want to calculate the measure for. Calculate the measures by running generate_measures which takes the files extracted in step 2 and produces files like measure_<measure_id>.csv .","title":"Defining measures"},{"location":"measures/#define-a-study-definition","text":"The study_definition.py script for the example above is: from cohortextractor import StudyDefinition , Measure , patients study = StudyDefinition ( # Configure the expectations framework default_expectations = { \"date\" : { \"earliest\" : \"2020-01-01\" , \"latest\" : \"today\" }, \"rate\" : \"exponential_increase\" , \"incidence\" : 0.2 }, index_date = \"2020-01-01\" , population = patients . registered_as_of ( \"index_date\" ), stp = patients . registered_practice_as_of ( \"index_date\" , returning = \"stp_code\" , return_expectations = { \"category\" : { \"ratios\" : { \"stp1\" : 0.1 , \"stp2\" : 0.2 , \"stp3\" : 0.7 }}, \"incidence\" : 1 } ), sex = patients . sex ( return_expectations = { \"rate\" : \"universal\" , \"category\" : { \"ratios\" : { \"M\" : 0.49 , \"F\" : 0.51 }}, } ), admitted = patients . admitted_to_hospital ( returning = \"binary_flag\" , between = [ \"index_date\" , \"last_day_of_month(index_date)\" ], return_expectations = { \"incidence\" : 0.1 }, ), died = patients . died_from_any_cause ( between = [ \"index_date\" , \"last_day_of_month(index_date)\" ], returning = \"binary_flag\" , return_expectations = { \"incidence\" : 0.05 }, ), ) measures = [ Measure ( id = \"hosp_admission_by_stp\" , numerator = \"admitted\" , denominator = \"population\" , group_by = \"stp\" , ), Measure ( id = \"death_by_stp\" , numerator = \"died\" , denominator = \"population\" , group_by = \"stp\" , ), ] This differs from a normal study definition due to the addition of the measures object, which is a list of calls to the Measure() function, for each measure. id is just a string used to identify the measure output file. numerator and denominator are the columns in the dataset that define the measure. They must be numeric or boolean (encoded as 0 or 1). group_by column can be of any type. To calculate the measure across the entire population, you can set group_by=\"population\" . If not specified, group_by will default to None and the measure will be calculated at the individual patient level. You can calculate measures for more than one group at a time by specifying multiple variables as follows: measures = [ Measure ( id = \"hosp_admission_by_stp\" , numerator = \"admitted\" , denominator = \"population\" , group_by = [ \"stp\" , \"sex\" ], ), Measure ( id = \"death_by_stp\" , numerator = \"died\" , denominator = \" population\" , group_by = [ \"stp\" , \"sex\" ], ), ]","title":"Define a study definition"},{"location":"measures/#extract-the-data","text":"To run multiple study definitions over a series of dates, use the --index-date-range option of the generate_cohort command. Rather than generating a single output CSV file this generates multiple output files across a range of dates, modifying the study's index date each time. The range is specified as: --index-date-range \"YYYY-MM-DD to YYYY-MM-DD by (week|month)\" It also excepts today in place of a date. Output files are named like: output/input_YYYY-MM-DD.csv There is also a --skip-existing option which will cause the cohortextractor to skip the extraction step for any dates where the corresponding file already exists. This makes it easier to incrementally extract data for new months/weeks without having to re-extract everything. Example: cohortextractor generate_cohort --index-date-range \"2020-01-01 to 2020-12-01 by month\" ...which will output: output/input_2020-01-01.csv output/input_2020-02-01.csv ... output/input_2020-12-01.csv","title":"Extract the data"},{"location":"measures/#calculate-the-measures","text":"This is done using the generate_measures command: cohortextractor generate_measures For each defined measure, and for each file extracted in step 2, this generates an output file with the measure calculated for that month or week. output/measure_hosp_admission_by_stp_2020-01-01.csv output/measure_death_by_stp_2020-01-01.csv output/measure_hosp_admission_by_stp_2020-02-01.csv output/measure_death_by_stp_2020-02-01.csv ... output/measure_hosp_admission_by_stp_2020-12-01.csv output/measure_death_by_stp_2020-12-01.csv Finally, for each measure, it combines all the output into a single file with an additional date column indicating the date associated with each row. output/measure_hosp_admission_by_stp.csv output/measure_death_by_stp.csv This command also respects the --skip-existing flag. This will prevent it from recalculating the measure for any months or weeks which have already been calculated. However the final step, which combines output across time periods, will always be run.","title":"Calculate the measures"},{"location":"measures/#putting-it-all-together-in-a-pipeline","text":"To generate the final outputs measure_hosp_admission_by_stp.csv and measure_death_by_stp.csv in a project pipeline , you would use the following actions: generate_study_population : run : cohortextractor:latest generate_cohort --study-definition study_definition --index-date-range \"2020-01-01 to 2020-12-01 by month\" --skip-existing --output-dir=output/measures outputs : highly_sensitive : cohort : output/measures/input_*.csv generate_measures : run : cohortextractor:latest generate_measures --study-definition study_definition --skip-existing --output-dir=output/measures needs : [ generate_study_population ] outputs : moderately_sensitive : measure_csv : output/measures/measure_*.csv","title":"Putting it all together in a pipeline"},{"location":"open-data-manifesto/","text":"Better Data for the NHS \ud83d\udd17 Operational research is key to understanding what works in the NHS. However the methods and code used to carry out this research are rarely seen in public. Standards are variable. One-off point-and-click analytics are common. This living document aims to start a discussion about best practice for research and analysis using NHS data. Send us your feedback! ebmdatalab@phc.ox.ac.uk Publish everything \ud83d\udd17 Share your methods and code, so other teams can review it and learn. Permit other people to re-use your code and content. Publish imperfect code fearlessly. Work in public from the start where possible. Make collaboration easy \ud83d\udd17 Use Jupyter notebooks or R Markdown to tell a story for generalists and analysts. Do the hard work to make it easy for others to run the code. Use code comments to inform a technical audience. Document key decisions alongside your code. Maintain a single repository for each project, with a README . Develop a supportive culture. Automate tasks with code where possible \ud83d\udd17 Use scripts , not point-and-click tools. Make live dashboards rather than occasional reports. Turn recurring work into libraries and share them. Use coders' best practice \ud83d\udd17 Do regular code reviews . Use version control . Write tests for your code. Help develop and follow local conventions around coding.","title":"The Datalab Open Manifesto"},{"location":"open-data-manifesto/#better-data-for-the-nhs","text":"Operational research is key to understanding what works in the NHS. However the methods and code used to carry out this research are rarely seen in public. Standards are variable. One-off point-and-click analytics are common. This living document aims to start a discussion about best practice for research and analysis using NHS data. Send us your feedback! ebmdatalab@phc.ox.ac.uk","title":"Better Data for the NHS"},{"location":"open-data-manifesto/#publish-everything","text":"Share your methods and code, so other teams can review it and learn. Permit other people to re-use your code and content. Publish imperfect code fearlessly. Work in public from the start where possible.","title":"Publish everything"},{"location":"open-data-manifesto/#make-collaboration-easy","text":"Use Jupyter notebooks or R Markdown to tell a story for generalists and analysts. Do the hard work to make it easy for others to run the code. Use code comments to inform a technical audience. Document key decisions alongside your code. Maintain a single repository for each project, with a README . Develop a supportive culture.","title":"Make collaboration easy"},{"location":"open-data-manifesto/#automate-tasks-with-code-where-possible","text":"Use scripts , not point-and-click tools. Make live dashboards rather than occasional reports. Turn recurring work into libraries and share them.","title":"Automate tasks with code where possible"},{"location":"open-data-manifesto/#use-coders-best-practice","text":"Do regular code reviews . Use version control . Write tests for your code. Help develop and follow local conventions around coding.","title":"Use coders' best practice"},{"location":"open-methods/","text":"We are using modern open working methods to carry out important analyses whilst preserving patient privacy and keeping all patient data secure. What do we mean by Open Working Methods? \ud83d\udd17 We believe that researchers should be openly sharing all analytic cods and development insights in order to accelerate development of analyses and tools by other groups with other datasets. Our tools are build using Python, SQL and Docker. Analyses can be carried out in Python, R or Stata. All our code including analytic code is shared on Github and is open access for efficiency, reuse and collaboration. We encourage external review and reuse of our code.","title":"Our philosophy"},{"location":"open-methods/#what-do-we-mean-by-open-working-methods","text":"We believe that researchers should be openly sharing all analytic cods and development insights in order to accelerate development of analyses and tools by other groups with other datasets. Our tools are build using Python, SQL and Docker. Analyses can be carried out in Python, R or Stata. All our code including analytic code is shared on Github and is open access for efficiency, reuse and collaboration. We encourage external review and reuse of our code.","title":"What do we mean by Open Working Methods?"},{"location":"opensafely-cli/","text":"The main tool for using the OpenSAFELY platform locally is the opensafely Python module, which is run via the command-line. It's main function is to run data extraction and analysis scripts that are specified in the project pipeline , in a way that mimics the production environment where real data is accessed. It also contains other functions relating to the OpenSAFELY workflow, such as updating codelists from codelists.opensafely.org . Installing opensafely \ud83d\udd17 This is a command-line program. To install, go to the Anaconda prompt and submit the following command (or use another method to install the module if you know how): pip install opensafely To check this has installed successfully, submit opensafely --version . Updating opensafely \ud83d\udd17 If you need to install a new version of opensafely , update with: pip install --upgrade opensafely Using opensafely at the command line \ud83d\udd17 To view the in-built documentation for each command, submit opensafely --help at the terminal, which will list all the ways in which you can use it. You can also use opensafely run --help to learn more about the run command, for example. To run any of these commands for a specific OpenSAFELY project, you need to change the directory of your prompt to be the repository of the project. For example, cd C:/Users/me/my-git-repos/my-repo . More information on how to use the opensafely module is available in specific sections elsewhere, but some key functions are described briefly below. run \ud83d\udd17 The most common command you'll run. This runs actions defined in the project.yaml file and is the main way of testing your code. For example, opensafely run make_graph will run the make_graph action. codelists \ud83d\udd17 This command is for working with codelists. Use opensafely codelists update to retrieve each codelist listed in /codelists/codelists.txt from codelists.opensafely.org . It will add (or update) the codelist .csv files to the codelists/ folder. Use opensafely codelists check to check if the codelist files are up-to-date with thse listed in ./codelists/codelists.txt . See the Codelist section for more information on codelists.","title":"OpenSAFELY CLI"},{"location":"opensafely-cli/#installing-opensafely","text":"This is a command-line program. To install, go to the Anaconda prompt and submit the following command (or use another method to install the module if you know how): pip install opensafely To check this has installed successfully, submit opensafely --version .","title":"Installing opensafely"},{"location":"opensafely-cli/#updating-opensafely","text":"If you need to install a new version of opensafely , update with: pip install --upgrade opensafely","title":"Updating opensafely"},{"location":"opensafely-cli/#using-opensafely-at-the-command-line","text":"To view the in-built documentation for each command, submit opensafely --help at the terminal, which will list all the ways in which you can use it. You can also use opensafely run --help to learn more about the run command, for example. To run any of these commands for a specific OpenSAFELY project, you need to change the directory of your prompt to be the repository of the project. For example, cd C:/Users/me/my-git-repos/my-repo . More information on how to use the opensafely module is available in specific sections elsewhere, but some key functions are described briefly below.","title":"Using opensafely at the command line"},{"location":"opensafely-cli/#run","text":"The most common command you'll run. This runs actions defined in the project.yaml file and is the main way of testing your code. For example, opensafely run make_graph will run the make_graph action.","title":"run"},{"location":"opensafely-cli/#codelists","text":"This command is for working with codelists. Use opensafely codelists update to retrieve each codelist listed in /codelists/codelists.txt from codelists.opensafely.org . It will add (or update) the codelist .csv files to the codelists/ folder. Use opensafely codelists check to check if the codelist files are up-to-date with thse listed in ./codelists/codelists.txt . See the Codelist section for more information on codelists.","title":"codelists"},{"location":"pipelines/","text":"This section covers how to develop, run, and test your code to ensure it will work end-to-end within the secure framework. General code-writing guidance \ud83d\udd17 Generally-speaking, you can write whatever code you like as long as it will run successfully on server, and it is possible to test this locally . However, note the following restrictions and guidance: Write analyses in Python, R, or Stata. You can can use more than one language in a single project if necessary. You can find more information about the available libraries here . Do not write code that requires an internet connection to run. Any research objects (datasets, libraries, etc) that are retrieved via the internet should be imported to the repo locally first. If this is not possible (for instance if the object size is too large to be transferred via GitHub) then get in touch. Avoid code that consumes a lot of time or memory. The server is not an infinite resource. We can advise on code optimisation if run-times become problematic. A good strategy is to split your processing into separate project pipeline actions; the job runner can then choose to run them in parallel if sufficient resources are available. Write code that runs across different platforms. Since code will be run both locally and within a Linux-based Docker environment. For example use forward-slashes / for directories. Structure your code into discrete chunks, both within scripts, and by splitting into different pipeline actions. This helps with: readability bug-finding parallelisation via the project pipeline Project pipelines \ud83d\udd17 The cohortextractor section describes how to write commands to generate dummy datasets based on the instructions defined in your study_definition.py script . These dummy datasets are the basis for developing the analysis code that will eventually be passed to the server to run on real datasets. The code can be written and run on your local machine using whatever development set up you prefer (e.g., developing R in RStudio). However, it's important to ensure that this code will run successfully in OpenSAFELY's secure environment too, using the specific language and package versions that are installed there. To do this, you should use the Project Pipeline. The project pipeline , defined entirely in a project.yaml file, is a system for executing your code using a series of actions i.e., a discrete analytical step within the analysis, each of which may depend on previous actions. The primary purpose of the pipeline is to specify the execution order for all your code, so that it can be automatically run and tested from start to finish using dummy data and using the live database in the secure environment, using an identical software configuration. Arranging your code like this also has several other advantages: The pipeline knows if outputs for given actions already exist, and by default skips running them if so. This greatly speeds up the debugging cycle when testing against live data In production, actions that can be executed in parallel will be, automatically Thinking about your analysis in terms of actions makes it more readable and therefore easier to review and test. For example, being explicit about what the inputs and outputs of each actions are ensures you don't overwrite files by accident. The pipeline forces you to declare which outputs may be more or less disclosive. project.yaml format \ud83d\udd17 The project pipeline is defined in a single file, project.yaml , which lives in the repository's root directory. It is written using a configuration format called YAML , which uses indentation to indicate groupings of related variables. A simple example of a project.yaml is as follows: version : \"3.0\" expectations : population_size : 1000 actions : generate_study_population : run : cohortextractor:latest generate_cohort --study-definition study_definition outputs : highly_sensitive : cohort : output/input.csv run_model : run : stata-mp:latest analysis/model.do needs : [ generate_study_population ] outputs : moderately_sensitive : model : models/cox-model.txt figure : figures/survival-plot.png This example declares the pipeline version , the population_size for the dummy data, and two actions, generate_study_population and run_model . You only need to change version if you want to take advantage of features of newer versions of the pipeline framework. The generate_study_population action will create the highly sensitive input.csv dataset. It will be dummy data when run locally, and will be based on real data from the OpenSAFELY database when run in the secure environment. The run_model action will run a Stata script called model.do based on the the input.csv created by the previous action. It will output two moderately sensitive files cox-model.txt and survival-plot.png , which can be checked and released if appropriate. Every project.yaml requires a version , expectations , and actions section. In general, actions are composed as follows: Each action must be named using a valid YAML key (you won't go wrong with letters, numbers, and underscores) and must be unique. Each action must include a run key which includes an officially-supported command and a version ( latest will always select the most recent version, but following initial development you should specify the version to ensure reproducibility). The cohortextractor command has the same options as described in the cohortextractor section . The python , r , and stata-mp commands provide a locked-down execution environment can take one or more inputs which are passed to the code. Each action must include an outputs key with at least one output, classified as either highly_sensitive or moderately_sensitive highly_sensitive outputs are considered potentially highly-disclosive, and are never intended for publishing outside the secure environment moderately_sensitive outputs are automatically copied to the secure review area for redaction (otherwise known as Level 4 ) and potentially for publication back to Github. Each action can include a needs key which specifies a list of actions (contained within square brackets and separated by commas) that are required for it to successfully run. When an action runs, the outputs of all its needs actions are copied to its working directory. needs actions can be defined anywhere in the project.yaml , but it's more readable if they are defined above. When writing and running your pipeline, note that: All file paths must be declared relative to the repository's root directory. So for example use outputs/figures/ , not C:/users/elvis/documents/myrepo/outputs/figures . File paths are case-sensitive as everything is run inside a Linux Docker container. The location of each action's output is determined by the underlying code that the action invoked, not by the value of the outputs configuration. The purpose of outputs is to label the disclosivity of each output and indicate that it should be stored securely \u2014 any outputs not labelled will not be saved. Each action is run in its own isolated environment in a temporary working directory. This means that all the necessary libraries and data must be imported within the script for each action \u2014 For R users, this essentially means that the R is restarted for each action. If one or more dependencies of an action have not been run (i.e., their outputs do not exist) then these dependency actions will be run first. If a dependency has changed but has not been run (so the outputs are not up-to-date with the changes), then the dependency actions will not be run, and the dependent actions will be run using the out-of-date outputs. Execution environments \ud83d\udd17 OpenSAFELY currently supports Stata, Python, and R for statistical analysis. For security reasons, available libraries are restricted to those provided by the framework, though you can request additions . The framework executes your scripts using Docker images which have been preloaded with a fixed set of libraries. These Docker images have yet to be optimised; if you have skills in creating Dockerfiles and would like to help, get in touch! Stata \ud83d\udd17 We currently package version 16.1, with datacheck , safetab , and safecount libraries installed; when installed, new libraries will appear in the stata-docker Github repository . As Stata is a commercial product, and the image incorporates our license key, the Docker image and Github repository are currently private, pending work to separate the license from the image. Get in touch if you need to apply your own license and we can accelerate this work. Python \ud83d\udd17 The docker image provided is Python 3.8, with this list of packages installed . R \ud83d\udd17 The R image provided is R 4.0, with this list of libraries installed . Currently our configuration doesn't list the precise versions of the libraries. If you need this, get in touch and we will accelerate this work. Running your code locally \ud83d\udd17 Whilst you can develop and run code locally using your own installations of R, Stata or Python, it's important to check that these will also successfully run on the real data in an identical execution environment. The opensafely run command will execute one or more actions according to the project.yaml . To see its options, type opensafely run --help . For opensafely run to work: You need to have both Python and Docker installed. The Docker daemon must be running on your machine: For Windows users using Docker Desktop, there should be a Docker icon in your system tray. For Mac users using Docker Desktop, there should be a Docker icon in the top status bar. You may need credentials for our docker registry (for example, if you are running Stata actions, which require a licensed version). If you have access, you can see instructions for this here . To run the first action in the example above, using dummy data, you can use: opensafely run generate_study_population This will generate the input.csv file as explained in the cohortextractor section. To run the second action you can use: opensafely run run_model It will create the two files as specified in the analysis/model.do script. To force the dependencies to be run you can use for example opensafely run run_model --force-run-dependencies , or -f for short. This will ensure for example that both the run_model and generate_study_population actions are run, even if input.csv already exists. To run all actions, you can use a special run_all action which is created for you (no need to define it in your project.yaml ): opensafely run run_all Each time an action is run, logging information about your run will be put into the metadata/ folder. If any of your actions fail, you may find clues here as to why. Click here for information on the exact steps that occur when each job is run locally What happens: A new, empty temporary directory for the job is created Any files in the local repo that do not match the output patterns in the project.yaml are copied into the temporary folder Any output files from the job's dependencies are copied into the temporary folder The job is run All the files matching the specified output patterns are copied into the local repo The log files for the job are saved into the metadata/ directory The temporary directory is deleted Running your code with GitHub actions \ud83d\udd17 Every time you create a pull request to merge a development branch onto the main remote branch, GitHub will automatically run a series of tests on the code; specifically, that your codelists are up-to-date, and that run_all completes successfully. Depending on your settings, you may receive email notifications about the results of these tests. You can view the tests, including any errors or failures, by going to the pull request page on GitHub and clicking the checks tab. You can re-run these tests by clicking the re-run jobs button. Running your code on the server \ud83d\udd17 To run code for real in the production environment, use the https://jobs.opensafely.org site. Here you can see (even without a login) all the ongoing projects within OpenSAFELY, and the specific jobs that have been run on the server. To submit jobs (i.e., to run actions), the general process is as follows: Log in using your GitHub credentials (this should happen automatically if you have access to the OpenSAFELY GitHub organisation). Create a workspace (or select an existing workspace): click the Add a New WorkSpace button choose a name, for example the name of the repo select a database to run against (either dummy data, real data, or a small sample of the real data) select the repo and branch that you want to run actions with click Submit . Select actions to run: select the actions you want to run by clicking the Run buttons if any of these actions have dependencies then they will also be run, unless their outputs already exist dependencies can be viewed by clicking the Needs button you can force dependencies to be run by clicking Force run dependencies , even if those actions have already been run when you're ready, click Submit . The workspace is available at https://jobs.opensafely.org/<WORKSPACE_NAME>/ . You can view the progress of these actions by click the Logs button from the workspace, or going to https://jobs.opensafely.org/<WORKSPACE_NAME>/logs . Click here for information on the exact steps that occur when each job is run on the server What happens: A new, empty temporary directory for the job is created Copy in all files on the selected branch The job is run All the files matching the specified output patterns are copied into the local repo The log files for the job are saved into the metadata/ directory The temporary directory is deleted The job will either succeed or fail. In either case, the output and log files are only visible in the secure environment to avoid disclosure of potentially sensitive information. Accessing the outputs \ud83d\udd17 Only users with access to Level 4 can view output files that are labelled as moderately sensitive and the automatically created log files of the run. For security reasons, they will be in a different directory than if you had run locally. For the TPP backend, outputs labelled moderately_sensitive in the project.yaml will be saved in D:/Level4Files/workspaces/<NAME_OF_YOUR_WORKSPACE> . These outputs can be reviewed on the server and released via GitHub if they are deemed non-disclosive. Outputs labelled highly_sensitive are not visible. If you have Level 3 access \ud83d\udd17 No data should ever be published from the Level 3 server. Access is only for permitted users, for the purpose of debugging problems in the secure environment. Highly sensitive outputs can be seen in E:/high_privacy/workspaces/<WORKSPACE_NAME> . This includes a directory called metadata , containing log files for each action e.g. generate_chorts.log , run_model.log . Moderately sensitive outputs can be seen in E:/FILESFORL4/workspaces/<WORKSPACE_NAME> . Running your code manually in the server \ud83d\udd17 This is only possible for people with Level 3 access. You'll want to refer to instructions for interacting with OpenSAFELY via the secure server (in restricted access repo). The live environment is set up via a wrapper script; instead of cohortextractor , you should run /e/bin/actionrunner.sh . For example, to run run_model on the Level 3 server, against the full database, you'd type: /e/bin/actionrunner.sh run full run_model tpp","title":"Running and testing code"},{"location":"pipelines/#general-code-writing-guidance","text":"Generally-speaking, you can write whatever code you like as long as it will run successfully on server, and it is possible to test this locally . However, note the following restrictions and guidance: Write analyses in Python, R, or Stata. You can can use more than one language in a single project if necessary. You can find more information about the available libraries here . Do not write code that requires an internet connection to run. Any research objects (datasets, libraries, etc) that are retrieved via the internet should be imported to the repo locally first. If this is not possible (for instance if the object size is too large to be transferred via GitHub) then get in touch. Avoid code that consumes a lot of time or memory. The server is not an infinite resource. We can advise on code optimisation if run-times become problematic. A good strategy is to split your processing into separate project pipeline actions; the job runner can then choose to run them in parallel if sufficient resources are available. Write code that runs across different platforms. Since code will be run both locally and within a Linux-based Docker environment. For example use forward-slashes / for directories. Structure your code into discrete chunks, both within scripts, and by splitting into different pipeline actions. This helps with: readability bug-finding parallelisation via the project pipeline","title":"General code-writing guidance"},{"location":"pipelines/#project-pipelines","text":"The cohortextractor section describes how to write commands to generate dummy datasets based on the instructions defined in your study_definition.py script . These dummy datasets are the basis for developing the analysis code that will eventually be passed to the server to run on real datasets. The code can be written and run on your local machine using whatever development set up you prefer (e.g., developing R in RStudio). However, it's important to ensure that this code will run successfully in OpenSAFELY's secure environment too, using the specific language and package versions that are installed there. To do this, you should use the Project Pipeline. The project pipeline , defined entirely in a project.yaml file, is a system for executing your code using a series of actions i.e., a discrete analytical step within the analysis, each of which may depend on previous actions. The primary purpose of the pipeline is to specify the execution order for all your code, so that it can be automatically run and tested from start to finish using dummy data and using the live database in the secure environment, using an identical software configuration. Arranging your code like this also has several other advantages: The pipeline knows if outputs for given actions already exist, and by default skips running them if so. This greatly speeds up the debugging cycle when testing against live data In production, actions that can be executed in parallel will be, automatically Thinking about your analysis in terms of actions makes it more readable and therefore easier to review and test. For example, being explicit about what the inputs and outputs of each actions are ensures you don't overwrite files by accident. The pipeline forces you to declare which outputs may be more or less disclosive.","title":"Project pipelines"},{"location":"pipelines/#projectyaml-format","text":"The project pipeline is defined in a single file, project.yaml , which lives in the repository's root directory. It is written using a configuration format called YAML , which uses indentation to indicate groupings of related variables. A simple example of a project.yaml is as follows: version : \"3.0\" expectations : population_size : 1000 actions : generate_study_population : run : cohortextractor:latest generate_cohort --study-definition study_definition outputs : highly_sensitive : cohort : output/input.csv run_model : run : stata-mp:latest analysis/model.do needs : [ generate_study_population ] outputs : moderately_sensitive : model : models/cox-model.txt figure : figures/survival-plot.png This example declares the pipeline version , the population_size for the dummy data, and two actions, generate_study_population and run_model . You only need to change version if you want to take advantage of features of newer versions of the pipeline framework. The generate_study_population action will create the highly sensitive input.csv dataset. It will be dummy data when run locally, and will be based on real data from the OpenSAFELY database when run in the secure environment. The run_model action will run a Stata script called model.do based on the the input.csv created by the previous action. It will output two moderately sensitive files cox-model.txt and survival-plot.png , which can be checked and released if appropriate. Every project.yaml requires a version , expectations , and actions section. In general, actions are composed as follows: Each action must be named using a valid YAML key (you won't go wrong with letters, numbers, and underscores) and must be unique. Each action must include a run key which includes an officially-supported command and a version ( latest will always select the most recent version, but following initial development you should specify the version to ensure reproducibility). The cohortextractor command has the same options as described in the cohortextractor section . The python , r , and stata-mp commands provide a locked-down execution environment can take one or more inputs which are passed to the code. Each action must include an outputs key with at least one output, classified as either highly_sensitive or moderately_sensitive highly_sensitive outputs are considered potentially highly-disclosive, and are never intended for publishing outside the secure environment moderately_sensitive outputs are automatically copied to the secure review area for redaction (otherwise known as Level 4 ) and potentially for publication back to Github. Each action can include a needs key which specifies a list of actions (contained within square brackets and separated by commas) that are required for it to successfully run. When an action runs, the outputs of all its needs actions are copied to its working directory. needs actions can be defined anywhere in the project.yaml , but it's more readable if they are defined above. When writing and running your pipeline, note that: All file paths must be declared relative to the repository's root directory. So for example use outputs/figures/ , not C:/users/elvis/documents/myrepo/outputs/figures . File paths are case-sensitive as everything is run inside a Linux Docker container. The location of each action's output is determined by the underlying code that the action invoked, not by the value of the outputs configuration. The purpose of outputs is to label the disclosivity of each output and indicate that it should be stored securely \u2014 any outputs not labelled will not be saved. Each action is run in its own isolated environment in a temporary working directory. This means that all the necessary libraries and data must be imported within the script for each action \u2014 For R users, this essentially means that the R is restarted for each action. If one or more dependencies of an action have not been run (i.e., their outputs do not exist) then these dependency actions will be run first. If a dependency has changed but has not been run (so the outputs are not up-to-date with the changes), then the dependency actions will not be run, and the dependent actions will be run using the out-of-date outputs.","title":"project.yaml format"},{"location":"pipelines/#execution-environments","text":"OpenSAFELY currently supports Stata, Python, and R for statistical analysis. For security reasons, available libraries are restricted to those provided by the framework, though you can request additions . The framework executes your scripts using Docker images which have been preloaded with a fixed set of libraries. These Docker images have yet to be optimised; if you have skills in creating Dockerfiles and would like to help, get in touch!","title":"Execution environments"},{"location":"pipelines/#stata","text":"We currently package version 16.1, with datacheck , safetab , and safecount libraries installed; when installed, new libraries will appear in the stata-docker Github repository . As Stata is a commercial product, and the image incorporates our license key, the Docker image and Github repository are currently private, pending work to separate the license from the image. Get in touch if you need to apply your own license and we can accelerate this work.","title":"Stata"},{"location":"pipelines/#python","text":"The docker image provided is Python 3.8, with this list of packages installed .","title":"Python"},{"location":"pipelines/#r","text":"The R image provided is R 4.0, with this list of libraries installed . Currently our configuration doesn't list the precise versions of the libraries. If you need this, get in touch and we will accelerate this work.","title":"R"},{"location":"pipelines/#running-your-code-locally","text":"Whilst you can develop and run code locally using your own installations of R, Stata or Python, it's important to check that these will also successfully run on the real data in an identical execution environment. The opensafely run command will execute one or more actions according to the project.yaml . To see its options, type opensafely run --help . For opensafely run to work: You need to have both Python and Docker installed. The Docker daemon must be running on your machine: For Windows users using Docker Desktop, there should be a Docker icon in your system tray. For Mac users using Docker Desktop, there should be a Docker icon in the top status bar. You may need credentials for our docker registry (for example, if you are running Stata actions, which require a licensed version). If you have access, you can see instructions for this here . To run the first action in the example above, using dummy data, you can use: opensafely run generate_study_population This will generate the input.csv file as explained in the cohortextractor section. To run the second action you can use: opensafely run run_model It will create the two files as specified in the analysis/model.do script. To force the dependencies to be run you can use for example opensafely run run_model --force-run-dependencies , or -f for short. This will ensure for example that both the run_model and generate_study_population actions are run, even if input.csv already exists. To run all actions, you can use a special run_all action which is created for you (no need to define it in your project.yaml ): opensafely run run_all Each time an action is run, logging information about your run will be put into the metadata/ folder. If any of your actions fail, you may find clues here as to why. Click here for information on the exact steps that occur when each job is run locally What happens: A new, empty temporary directory for the job is created Any files in the local repo that do not match the output patterns in the project.yaml are copied into the temporary folder Any output files from the job's dependencies are copied into the temporary folder The job is run All the files matching the specified output patterns are copied into the local repo The log files for the job are saved into the metadata/ directory The temporary directory is deleted","title":"Running your code locally"},{"location":"pipelines/#running-your-code-with-github-actions","text":"Every time you create a pull request to merge a development branch onto the main remote branch, GitHub will automatically run a series of tests on the code; specifically, that your codelists are up-to-date, and that run_all completes successfully. Depending on your settings, you may receive email notifications about the results of these tests. You can view the tests, including any errors or failures, by going to the pull request page on GitHub and clicking the checks tab. You can re-run these tests by clicking the re-run jobs button.","title":"Running your code with GitHub actions"},{"location":"pipelines/#running-your-code-on-the-server","text":"To run code for real in the production environment, use the https://jobs.opensafely.org site. Here you can see (even without a login) all the ongoing projects within OpenSAFELY, and the specific jobs that have been run on the server. To submit jobs (i.e., to run actions), the general process is as follows: Log in using your GitHub credentials (this should happen automatically if you have access to the OpenSAFELY GitHub organisation). Create a workspace (or select an existing workspace): click the Add a New WorkSpace button choose a name, for example the name of the repo select a database to run against (either dummy data, real data, or a small sample of the real data) select the repo and branch that you want to run actions with click Submit . Select actions to run: select the actions you want to run by clicking the Run buttons if any of these actions have dependencies then they will also be run, unless their outputs already exist dependencies can be viewed by clicking the Needs button you can force dependencies to be run by clicking Force run dependencies , even if those actions have already been run when you're ready, click Submit . The workspace is available at https://jobs.opensafely.org/<WORKSPACE_NAME>/ . You can view the progress of these actions by click the Logs button from the workspace, or going to https://jobs.opensafely.org/<WORKSPACE_NAME>/logs . Click here for information on the exact steps that occur when each job is run on the server What happens: A new, empty temporary directory for the job is created Copy in all files on the selected branch The job is run All the files matching the specified output patterns are copied into the local repo The log files for the job are saved into the metadata/ directory The temporary directory is deleted The job will either succeed or fail. In either case, the output and log files are only visible in the secure environment to avoid disclosure of potentially sensitive information.","title":"Running your code on the server"},{"location":"pipelines/#accessing-the-outputs","text":"Only users with access to Level 4 can view output files that are labelled as moderately sensitive and the automatically created log files of the run. For security reasons, they will be in a different directory than if you had run locally. For the TPP backend, outputs labelled moderately_sensitive in the project.yaml will be saved in D:/Level4Files/workspaces/<NAME_OF_YOUR_WORKSPACE> . These outputs can be reviewed on the server and released via GitHub if they are deemed non-disclosive. Outputs labelled highly_sensitive are not visible.","title":"Accessing the outputs"},{"location":"pipelines/#if-you-have-level-3-access","text":"No data should ever be published from the Level 3 server. Access is only for permitted users, for the purpose of debugging problems in the secure environment. Highly sensitive outputs can be seen in E:/high_privacy/workspaces/<WORKSPACE_NAME> . This includes a directory called metadata , containing log files for each action e.g. generate_chorts.log , run_model.log . Moderately sensitive outputs can be seen in E:/FILESFORL4/workspaces/<WORKSPACE_NAME> .","title":"If you have Level 3 access"},{"location":"pipelines/#running-your-code-manually-in-the-server","text":"This is only possible for people with Level 3 access. You'll want to refer to instructions for interacting with OpenSAFELY via the secure server (in restricted access repo). The live environment is set up via a wrapper script; instead of cohortextractor , you should run /e/bin/actionrunner.sh . For example, to run run_model on the Level 3 server, against the full database, you'd type: /e/bin/actionrunner.sh run full run_model tpp","title":"Running your code manually in the server"},{"location":"protocol/","text":"Pre-specifying your Research Question and Writing a Study Protocol \ud83d\udd17 This section is a work in progress, and will be further developed. Briefly, pre-specifying your research question and developing a study protocol which outlines your planned methodology is an important open science principle. Doing so can help reduce 'researcher degrees of freedom', and in turn minimise the risk for questonable research practices (such as HARKing or p-hacking). Taken together, this can improve both the quality and credibility of your research. Developing a detailed study plan, including figure and table shells, can be particularly helpful when using a federated analytics platform such as OpenSAFELY, as there is less scope for interactively developing these whilst working with the data. This page will eventually contain resources for how to develop an effective study protocol, as well as tips for how to pre-register these formally on OSF or EnCEPP, or informally by uploading \"locked\" protocol versions to Github. There is no specific template for a protocol that you should use when working with OpenSAFELY, but you can see examples of protocols we've written for OpenSAFELY studies on most of our public repos - for example here for ics research or here for ethnicity research","title":"Developing a protocol"},{"location":"protocol/#pre-specifying-your-research-question-and-writing-a-study-protocol","text":"This section is a work in progress, and will be further developed. Briefly, pre-specifying your research question and developing a study protocol which outlines your planned methodology is an important open science principle. Doing so can help reduce 'researcher degrees of freedom', and in turn minimise the risk for questonable research practices (such as HARKing or p-hacking). Taken together, this can improve both the quality and credibility of your research. Developing a detailed study plan, including figure and table shells, can be particularly helpful when using a federated analytics platform such as OpenSAFELY, as there is less scope for interactively developing these whilst working with the data. This page will eventually contain resources for how to develop an effective study protocol, as well as tips for how to pre-register these formally on OSF or EnCEPP, or informally by uploading \"locked\" protocol versions to Github. There is no specific template for a protocol that you should use when working with OpenSAFELY, but you can see examples of protocols we've written for OpenSAFELY studies on most of our public repos - for example here for ics research or here for ethnicity research","title":"Pre-specifying your Research Question and Writing a Study Protocol"},{"location":"releasing-files/","text":"All outputs from OpenSAFELY pipelines are subject to tiered levels of scrutiny , to provide assurance that identifiable data is not leaked accidentally, or maliciously. The final tier is review of so-called \" Level 4 \" outputs, where the OpenSAFELY framework stores outputs labelled as moderately_sensitive in the project.yaml file. Level 4 outputs can only be released by authorised users who have permission to log in to the secure server. Such users have responsibility for redacting sensitive information or choosing not to publish it at all. The study author should do everything they can to make this easy; for example, carrying out low number suppression automatically, documenting code clearly, and only selecting essential items for publication when deciding what to label as moderately_sensitive . Releasing output files from analysis runs \ud83d\udd17 The output and log files that are created by running code against the live database will appear in the secure environment in a workspace-specific folder. The reviewer releases outputs back to the original repo using git. To make this process easier and to reduce the likelihood of sensitive information being accidentally released, there is a script-based procedure to follow. In essence, the process is: create a git repo in the folder where the outputs were created; check and redact them as necessary; commit the safe files to the repo; run the osrelease command and follow the instructions. This last step will create a new branch containing the released outputs which can then be merged onto another branch in the repo via a pull request. Install \ud83d\udd17 Log into L4 server In a git-bash terminal, run /d/bin/install-osrelease.bat (or /e/bin/install-osrelease.bat on the L3 server). You can run this command multiple times without any problems if needed. Close the git-bash terminal and reopen it Check you can run osrelease --help (you'll get some help text) Instructions \ud83d\udd17 The following instructions assume you have submitted one or more jobs which have created outputs on the Level 4 server, including log files from failed runs. Log in to the Level 4 server \u2014 if you have access you will have been provided instructions on how to do this. Go to /d/Level4Files/workspaces/<NAME_OF_YOUR_WORKSPACE> (or /e/FILESFORL4/workspaces/<NAME_OF_YOUR_WORKSPACE> if you are in Level 3 , which you shouldn't be ). You should see: a metadata/ folder containing logs for each action, an outputs/ folder (by convention but this could be something else) containing the moderately_sensitive files intended for release. If these don't exist or haven't updated as you expect, double-check the workspace name and the status of the jobs on the job server . Open a console with this folder as root directory, using cd /d/Level4Files/workspaces/<NAME_OF_YOUR_WORKSPACE> . If this is the first time any releases have been made for this workspace, run git init to create a new git repo there. Run git status to see the changes made by the job(s) (if this says fatal: not a git repository then you need to run git init ). Run git add <names-of-files> to add any new files, or changes to any existing files, to the local repo. Edit or delete files to redact as necessary and commit the changes: Read the redaction instructions below . Use GitHub desktop or command line git to view the diffs and commit changes to the repo. Any previously-applied redactions from previously-run actions will need to be reapplied \u2014 these will be easy to spot in GitHub desktop, and you can choose to simply not commit any files if the redacted version will be identical between the previous and current runs. Only once you're satisfied that the committed changes are safe to release, run osrelease <github_remote_https_url> (e.g. osrelease https://github.com/opensafely/my-amazing-research ) and follow the instructions. Once finished, any files you have committed locally will be visible in the released_ouputs folder on the release-candidates branch on your repo (e.g., https://github.com/opensafely/my-amazing-research/tree/release-candidates ). This branch won't contain any of the intermediate git history, just the state of the redaction repo when you ran the osrelease command. You can merge the released-candidates branch onto another branch by creating a pull request. If you want to merge onto a branch that isn't the main branch, don't forget to select the correct base: branch from the drop-down box when creating the pull request. Click here to read in more detail about the osrelease command. The osrelease command runs the release.py script in the output-publisher repo . It: prompts the reviewer for the URL of a github repo to where the redacted outputs should be published (the study repo ) checks out the study repo and creates a branch release-candidates (if it doesn't already exist) copies every file that has been committed to the redaction repo into a subfolder released_outputs creates or updates an index file at released_outputs/README.md with links to all the release files adds all new changes as a single commit, using the most recent commit message in the redaction repo as the text. It also appends a trailer indicating from where the commit was originated force-pushes release-candidates to the study repo outputs a URL to the \"create Pull Request\" page in github for the release-candidates branch of the study repo The benefit of maintaining a separate redaction repo is that when new outputs are generated and written to that repo, the usual git tools can be used to diff outputs, making it easier to reapply redactions or decide where new redactions should be applied. Disclosivity checks and redaction \ud83d\udd17 Work through the moderately sensitive files in the workspace folder systematically to identify any tables, figures, and other outputted text and objects that may be a disclosure risk. The general principle is that any statistic describing 5 or fewer patients, either directly or indirectly, should be redacted . For example: Frequency tables containing counts between 1-5 should be redacted. The whole table, or at a minimum multiple rows within the table, should be redacted because values removed by single cell (or row, or column) redaction could be inferred from unredacted values. Summaries of numeric variables describing 5 or fewer patients should be redacted. Graphical figures whose underlying values describe 5 or fewer patients should be redacted. Figures which include print-outs of patient counts (such as KM plots) should be checked and redacted. Counts of zero can be retained. Other outputs, such as log files that reveal information about the underlying data, should also be checked and redacted if necessary. Where possible it should be clear what has been redacted, so for example do not redact table titles and category names. By convention redactions take the form [REDACTED] to make redacted elements easier to search for. Ideally there shouldn't be any files in the folder that are not intended for release (whether potentially disclosive or not) as these should have been removed by the analysis scripts or placed elsewhere. If they are there, delete them. This current approach to disclosure control is conservative and deliberately reduces the need for judgement calls. It may be possible for exceptions to be made if they can be justified as being both analytically necessary and definitely non-disclosive. This must be discussed with the OpenSAFELY team. If you are unsure about anything, ask. Redaction data breaches and how to recover from them \ud83d\udd17 The issues \ud83d\udd17 One of the great strengths of using git is that it is easy to recreate the contents of any file in the repository exactly as it appeared at any point in the repository's stored history. However, this means that if any sensitive data is inadvertently committed to a repository, we need to be careful to completely remove that data from the history. Access to output-publisher repositories is intended to be restricted, and their histories are not transferred to study repos in the release process. However, study repos are intended to eventually become public, so if sensitive data is committed then care should be taken to fully clean up. From the moment that the osrelease command is run in an output-publisher repo, we need to be careful with the study repo's git history. For example, if sensitive data was committed to a study repo, it is explicitly not safe to use either git's revert command, or to delete the file and commit the deletion. Both of these methods would leave the commit containing the sensitive data in the history of the git repository - and would be trivial for anyone to recover in the future. Another aspect of git is that it uses a decentralised model. This means that everyone that has a copy of a git repository has their own copy of the entire history. So, if there is a sensitive data leak, it is not sufficient to clean just your own copy of the git history & the history on github, you should also clean the git histories of all other copies. What to do if you find a data breach \ud83d\udd17 If you discover files in a study repository that have been insufficiently redacted and still contain sensitive information, you should contact Amir Mehrkahr or Ben Goldacre as soon as possible. If you are able, you can attempt to make the repository safe by temporarily restricting access to it. For instance, if the repository is public (accessible to the world), make it private (accessible only to the OpenSAFELY team). If the repository has external contributors that are not authorised to handle sensitive data, consider temporarily removing their access to the repository. This will reduce the scope for harm until the sensitive information can be removed from the repository. If you are an author of the study, you should also liaise with an engineer from the OpenSAFELY team as soon as possible to safely clean the sensitive information from the repository. Depending on the exact situation this may be relatively straightforward or relatively complicated. You should also attempt to trace all copies of the repository for cleaning or deletion.","title":"Releasing files from the server"},{"location":"releasing-files/#releasing-output-files-from-analysis-runs","text":"The output and log files that are created by running code against the live database will appear in the secure environment in a workspace-specific folder. The reviewer releases outputs back to the original repo using git. To make this process easier and to reduce the likelihood of sensitive information being accidentally released, there is a script-based procedure to follow. In essence, the process is: create a git repo in the folder where the outputs were created; check and redact them as necessary; commit the safe files to the repo; run the osrelease command and follow the instructions. This last step will create a new branch containing the released outputs which can then be merged onto another branch in the repo via a pull request.","title":"Releasing output files from analysis runs"},{"location":"releasing-files/#install","text":"Log into L4 server In a git-bash terminal, run /d/bin/install-osrelease.bat (or /e/bin/install-osrelease.bat on the L3 server). You can run this command multiple times without any problems if needed. Close the git-bash terminal and reopen it Check you can run osrelease --help (you'll get some help text)","title":"Install"},{"location":"releasing-files/#instructions","text":"The following instructions assume you have submitted one or more jobs which have created outputs on the Level 4 server, including log files from failed runs. Log in to the Level 4 server \u2014 if you have access you will have been provided instructions on how to do this. Go to /d/Level4Files/workspaces/<NAME_OF_YOUR_WORKSPACE> (or /e/FILESFORL4/workspaces/<NAME_OF_YOUR_WORKSPACE> if you are in Level 3 , which you shouldn't be ). You should see: a metadata/ folder containing logs for each action, an outputs/ folder (by convention but this could be something else) containing the moderately_sensitive files intended for release. If these don't exist or haven't updated as you expect, double-check the workspace name and the status of the jobs on the job server . Open a console with this folder as root directory, using cd /d/Level4Files/workspaces/<NAME_OF_YOUR_WORKSPACE> . If this is the first time any releases have been made for this workspace, run git init to create a new git repo there. Run git status to see the changes made by the job(s) (if this says fatal: not a git repository then you need to run git init ). Run git add <names-of-files> to add any new files, or changes to any existing files, to the local repo. Edit or delete files to redact as necessary and commit the changes: Read the redaction instructions below . Use GitHub desktop or command line git to view the diffs and commit changes to the repo. Any previously-applied redactions from previously-run actions will need to be reapplied \u2014 these will be easy to spot in GitHub desktop, and you can choose to simply not commit any files if the redacted version will be identical between the previous and current runs. Only once you're satisfied that the committed changes are safe to release, run osrelease <github_remote_https_url> (e.g. osrelease https://github.com/opensafely/my-amazing-research ) and follow the instructions. Once finished, any files you have committed locally will be visible in the released_ouputs folder on the release-candidates branch on your repo (e.g., https://github.com/opensafely/my-amazing-research/tree/release-candidates ). This branch won't contain any of the intermediate git history, just the state of the redaction repo when you ran the osrelease command. You can merge the released-candidates branch onto another branch by creating a pull request. If you want to merge onto a branch that isn't the main branch, don't forget to select the correct base: branch from the drop-down box when creating the pull request. Click here to read in more detail about the osrelease command. The osrelease command runs the release.py script in the output-publisher repo . It: prompts the reviewer for the URL of a github repo to where the redacted outputs should be published (the study repo ) checks out the study repo and creates a branch release-candidates (if it doesn't already exist) copies every file that has been committed to the redaction repo into a subfolder released_outputs creates or updates an index file at released_outputs/README.md with links to all the release files adds all new changes as a single commit, using the most recent commit message in the redaction repo as the text. It also appends a trailer indicating from where the commit was originated force-pushes release-candidates to the study repo outputs a URL to the \"create Pull Request\" page in github for the release-candidates branch of the study repo The benefit of maintaining a separate redaction repo is that when new outputs are generated and written to that repo, the usual git tools can be used to diff outputs, making it easier to reapply redactions or decide where new redactions should be applied.","title":"Instructions"},{"location":"releasing-files/#disclosivity-checks-and-redaction","text":"Work through the moderately sensitive files in the workspace folder systematically to identify any tables, figures, and other outputted text and objects that may be a disclosure risk. The general principle is that any statistic describing 5 or fewer patients, either directly or indirectly, should be redacted . For example: Frequency tables containing counts between 1-5 should be redacted. The whole table, or at a minimum multiple rows within the table, should be redacted because values removed by single cell (or row, or column) redaction could be inferred from unredacted values. Summaries of numeric variables describing 5 or fewer patients should be redacted. Graphical figures whose underlying values describe 5 or fewer patients should be redacted. Figures which include print-outs of patient counts (such as KM plots) should be checked and redacted. Counts of zero can be retained. Other outputs, such as log files that reveal information about the underlying data, should also be checked and redacted if necessary. Where possible it should be clear what has been redacted, so for example do not redact table titles and category names. By convention redactions take the form [REDACTED] to make redacted elements easier to search for. Ideally there shouldn't be any files in the folder that are not intended for release (whether potentially disclosive or not) as these should have been removed by the analysis scripts or placed elsewhere. If they are there, delete them. This current approach to disclosure control is conservative and deliberately reduces the need for judgement calls. It may be possible for exceptions to be made if they can be justified as being both analytically necessary and definitely non-disclosive. This must be discussed with the OpenSAFELY team. If you are unsure about anything, ask.","title":"Disclosivity checks and redaction"},{"location":"releasing-files/#redaction-data-breaches-and-how-to-recover-from-them","text":"","title":"Redaction data breaches and how to recover from them"},{"location":"releasing-files/#the-issues","text":"One of the great strengths of using git is that it is easy to recreate the contents of any file in the repository exactly as it appeared at any point in the repository's stored history. However, this means that if any sensitive data is inadvertently committed to a repository, we need to be careful to completely remove that data from the history. Access to output-publisher repositories is intended to be restricted, and their histories are not transferred to study repos in the release process. However, study repos are intended to eventually become public, so if sensitive data is committed then care should be taken to fully clean up. From the moment that the osrelease command is run in an output-publisher repo, we need to be careful with the study repo's git history. For example, if sensitive data was committed to a study repo, it is explicitly not safe to use either git's revert command, or to delete the file and commit the deletion. Both of these methods would leave the commit containing the sensitive data in the history of the git repository - and would be trivial for anyone to recover in the future. Another aspect of git is that it uses a decentralised model. This means that everyone that has a copy of a git repository has their own copy of the entire history. So, if there is a sensitive data leak, it is not sufficient to clean just your own copy of the git history & the history on github, you should also clean the git histories of all other copies.","title":"The issues"},{"location":"releasing-files/#what-to-do-if-you-find-a-data-breach","text":"If you discover files in a study repository that have been insufficiently redacted and still contain sensitive information, you should contact Amir Mehrkahr or Ben Goldacre as soon as possible. If you are able, you can attempt to make the repository safe by temporarily restricting access to it. For instance, if the repository is public (accessible to the world), make it private (accessible only to the OpenSAFELY team). If the repository has external contributors that are not authorised to handle sensitive data, consider temporarily removing their access to the repository. This will reduce the scope for harm until the sensitive information can be removed from the repository. If you are an author of the study, you should also liaise with an engineer from the OpenSAFELY team as soon as possible to safely clean the sensitive information from the repository. Depending on the exact situation this may be relatively straightforward or relatively complicated. You should also attempt to trace all copies of the repository for cleaning or deletion.","title":"What to do if you find a data breach"},{"location":"repositories/","text":"This section provides information on the git repositories for each OpenSAFELY research project. The repository, or repo, contains all the analysis scripts, codelists, released outputs, and other research objects needed to understand and run the project. Changes to the repo are audited using git , a version control system for recording, sharing and collaborating on code. The repo's canonical location is on GitHub, a website that makes it easy to use git, and adds extra collaboration and security tools on top. You can download a copy of the repo (\"clone\"), create a development \"branch\", make changes (\"commit\") on that branch, then upload these changes (\"push\") back to the remote repo on GitHub \u2014 for more details see the GitHub and Git section. GitHub is the means by which code in the repository is passed to the server to be run against the OpenSAFELY database \u2014 it is the only entry point between the secure server and the outside world. Creating a repository for a new project \ud83d\udd17 For ease of use, we have created a research template that you should use for your study. Go to the OpenSAFELY research template repo on GitHub. Click the green button that says Use this template . Fill in the details: owner : select your personal GitHub for testing/experimenting, or select the opensafely organisation for a bona fide OpenSAFELY-approved study. The repo can be transferred into opensafely later if needed. repository name : It needs to be short but informative \u2014 browse existing repo names for inspiration. Description : This will appear at the top of the repo on GitHub. No more than a sentence is needed as the repo should be explained fully in the README. public / private : select private initially, this can be changed later. Include all branches : Leave unchecked. And submit. You will now be at the GitHub landing page for the repo. You should also download a copy of this repo to your machine so you can work on it locally. This is necessary because you can: develop your code using familiar editing tools test and run code without disturbing other contributors To clone your new repository to your machine, follow these instructions which explains cloning both via GitHub Deskop or via the command line. When this is done, you should have a folder whose name is the same as the repo on your machine. Repository structure \ud83d\udd17 README.md \ud83d\udd17 This file introduces your project, helps people understand the purpose of the repo, and how to navigate and use the code. Any new repo will include a template README. It should be updated to briefly describe the intended study and to reflect the repo's current status as a work in progress . The README should also be updated frequently to reflect changes to the repo, and should certainly be up-to-date before publication of any research outputs. The README is written in Markdown. If you're not familiar with Markdown syntax, read this guide on GitHub-flavoured Markdown . There's a handy cheatsheet for the most useful Markdown syntax here . You can update the README directly in GitHub. Click the edit button (a little pencil in the top-right), change the text, and commit the changes. This is a standard commit so there's not need to write more than \" first README update \", but typically commits should have a bit more detail than that. project.yaml \ud83d\udd17 This file defines a \"pipeline\": how all the components of your analysis can run together, efficiently, either on the server or locally on your computer. See the pipeline documentation for more information. .github/ \ud83d\udd17 This is an important folder, used internally by git, that you can happily ignore. Do not delete . analysis/ \ud83d\udd17 By convention, this folder contains: Any study_definition.py script that defines the study definition Analysis scripts in R, Python or Stata codelists/ \ud83d\udd17 This contains a .txt document listing the codelists that you want to retrieve from codelists.opensafely.org , and the .csv files of the retrieved codelists themselves. You should not edit the CSV files directly; see the codelists documentation for more on how to update the codelists. output/ \ud83d\udd17 This folder contains: the input.csv file containing the (dummy or real) dataset. You will only have access to the dummy version of this dataset when working locally. By convention, any other files outputted by the analysis scripts that convert input.csv into study results, tables, figures, etc. Be aware that input.csv is included in the .gitignore file (see below), which means it can't be committed and uploaded to Github. You don't have to store things in these locations, but that's the convention we suggest. released-output/ \ud83d\udd17 Outputs that have been reviewed (and possibly edited) to ensure they are not disclosive are stored here. docs/ \ud83d\udd17 Used for documentation. (other folders)/ \ud83d\udd17 Feel free to add more folders to the repo and organise your project as you wish. However, we recommend including all active scripts and codelists in the analysis/ and codelists/ folders. If you don't want any additional files or folders to be pushed to the remote repo, use .gitignore . .gitignore \ud83d\udd17 This is a text document, used by git, which lists all the files and folders that you don't want to be uploaded to the remote repo on GitHub when you push changes from your local repo ( untracked files). As a system for keeping private files private, it's vulnerable to human error so don't rely on it for this purpose. Instructions for how to list ignored files properly in .gitignore are here . If you need to create an empty folder to save files in, put a file in the folder that is tracked by git \u2014 by convention this is a .gitkeep file. If you want to create an empty folder to save files in, but you never want its contents to be committed to the repo, you can add a .gitignore file to that folder with the following contents: # Ignore all files in this folder * # Apart from this very file !/.gitignore This can be useful if you want to for example add a output/plots/ subfolder to put your analysis plots into without having to check and create that folder explicitly every time in the analysis script. This is necessary because the contents output/ folder is ignored by .gitignore .","title":"Project repositories"},{"location":"repositories/#creating-a-repository-for-a-new-project","text":"For ease of use, we have created a research template that you should use for your study. Go to the OpenSAFELY research template repo on GitHub. Click the green button that says Use this template . Fill in the details: owner : select your personal GitHub for testing/experimenting, or select the opensafely organisation for a bona fide OpenSAFELY-approved study. The repo can be transferred into opensafely later if needed. repository name : It needs to be short but informative \u2014 browse existing repo names for inspiration. Description : This will appear at the top of the repo on GitHub. No more than a sentence is needed as the repo should be explained fully in the README. public / private : select private initially, this can be changed later. Include all branches : Leave unchecked. And submit. You will now be at the GitHub landing page for the repo. You should also download a copy of this repo to your machine so you can work on it locally. This is necessary because you can: develop your code using familiar editing tools test and run code without disturbing other contributors To clone your new repository to your machine, follow these instructions which explains cloning both via GitHub Deskop or via the command line. When this is done, you should have a folder whose name is the same as the repo on your machine.","title":"Creating a repository for a new project"},{"location":"repositories/#repository-structure","text":"","title":"Repository structure"},{"location":"repositories/#readmemd","text":"This file introduces your project, helps people understand the purpose of the repo, and how to navigate and use the code. Any new repo will include a template README. It should be updated to briefly describe the intended study and to reflect the repo's current status as a work in progress . The README should also be updated frequently to reflect changes to the repo, and should certainly be up-to-date before publication of any research outputs. The README is written in Markdown. If you're not familiar with Markdown syntax, read this guide on GitHub-flavoured Markdown . There's a handy cheatsheet for the most useful Markdown syntax here . You can update the README directly in GitHub. Click the edit button (a little pencil in the top-right), change the text, and commit the changes. This is a standard commit so there's not need to write more than \" first README update \", but typically commits should have a bit more detail than that.","title":"README.md"},{"location":"repositories/#projectyaml","text":"This file defines a \"pipeline\": how all the components of your analysis can run together, efficiently, either on the server or locally on your computer. See the pipeline documentation for more information.","title":"project.yaml"},{"location":"repositories/#github","text":"This is an important folder, used internally by git, that you can happily ignore. Do not delete .","title":".github/"},{"location":"repositories/#analysis","text":"By convention, this folder contains: Any study_definition.py script that defines the study definition Analysis scripts in R, Python or Stata","title":"analysis/"},{"location":"repositories/#codelists","text":"This contains a .txt document listing the codelists that you want to retrieve from codelists.opensafely.org , and the .csv files of the retrieved codelists themselves. You should not edit the CSV files directly; see the codelists documentation for more on how to update the codelists.","title":"codelists/"},{"location":"repositories/#output","text":"This folder contains: the input.csv file containing the (dummy or real) dataset. You will only have access to the dummy version of this dataset when working locally. By convention, any other files outputted by the analysis scripts that convert input.csv into study results, tables, figures, etc. Be aware that input.csv is included in the .gitignore file (see below), which means it can't be committed and uploaded to Github. You don't have to store things in these locations, but that's the convention we suggest.","title":"output/"},{"location":"repositories/#released-output","text":"Outputs that have been reviewed (and possibly edited) to ensure they are not disclosive are stored here.","title":"released-output/"},{"location":"repositories/#docs","text":"Used for documentation.","title":"docs/"},{"location":"repositories/#other-folders","text":"Feel free to add more folders to the repo and organise your project as you wish. However, we recommend including all active scripts and codelists in the analysis/ and codelists/ folders. If you don't want any additional files or folders to be pushed to the remote repo, use .gitignore .","title":"(other folders)/"},{"location":"repositories/#gitignore","text":"This is a text document, used by git, which lists all the files and folders that you don't want to be uploaded to the remote repo on GitHub when you push changes from your local repo ( untracked files). As a system for keeping private files private, it's vulnerable to human error so don't rely on it for this purpose. Instructions for how to list ignored files properly in .gitignore are here . If you need to create an empty folder to save files in, put a file in the folder that is tracked by git \u2014 by convention this is a .gitkeep file. If you want to create an empty folder to save files in, but you never want its contents to be committed to the repo, you can add a .gitignore file to that folder with the following contents: # Ignore all files in this folder * # Apart from this very file !/.gitignore This can be useful if you want to for example add a output/plots/ subfolder to put your analysis plots into without having to check and create that folder explicitly every time in the analysis script. This is necessary because the contents output/ folder is ignored by .gitignore .","title":".gitignore"},{"location":"requests-documentation/","text":"OpenSAFELY is a rapidly changing platform and the user documentation should be updated frequently to keep pace. If you are an OpenSAFELY user and want to contribute corrections, clarifications, or new materials to the documentation, please do! You can either: Suggest improvements in an issue . Clone the repo locally, make edits on a new branch, then create a pull request for it. Edit directly on Github , making sure to \"Create a new branch for this commit and start a pull request\". Do not commit changes directly to the master branch. If you want to make changes to the study definition variables here , edit the docstrings in the patients.py file in the cohort-extractor repository . If you don't have write access, you can fork the repo, make a change, and submit a pull request. Editing directly in GitHub will take you through these steps automatically. At least one commit in the pull request should be named using the prefix fix: or feature: . For example fix: typo in age_as_of docstring . This ensures that a new version of cohortextractor is released and can be imported by the documentation via GitHub actions. Additionally, the requirements.txt file in the documentation repo itself has to be updated to match the new incremented version of cohortextractor .","title":"Updating the Documentation"},{"location":"requests-intro/","text":"OpenSAFELY uses GitHub to manage and share code and other platform resources. If you want to request any changes to the platform then GitHub issues should be your first port of call. Issues can be submitted for lots of different things \u2014 new variables or other features, bug reports, additional R or Stata packages, documentation updates, and so on. You will need to choose the most appropriate repo to submit an issue. This will usually be obvious but issues can be moved to different repos if there's a better place so don't worry if you're not sure. Before submitting a new issue, search existing issues to check your needs haven't already been reported or addressed. By default, a search of a repository's issues will look for open issues only. It's often useful to also check closed issues, as it may be for example that your request has already been implemented or is considered not possible. The remaining pages provide details on how to submit issues for specific requests in OpenSAFELY.","title":"Overview"},{"location":"requests-packages/","text":"Additional R, Stata, or Python packages in OpenSAFELY must be added by the OpenSAFELY development team. Installing packages via commands that pull the package from the internet (e.g install.packages() in R or ssc install in Stata) won't work because internet access is restricted in the server. Requesting additional R packages \ud83d\udd17 The OpenSAFELY R Image ships with a given set of packages baked in. Currently the best way to see the packages that are available is to grab them from a recently-updated docker image as follows: Create an R script, get_packages.R say, with the following line: write.csv ( installed.packages ()[, c ( \"Package\" , \"Version\" )], row.names = FALSE , file = \"output/installed_packages.csv\" ) Add an action to project.yaml that runs this script: get_packages : run : r:latest analysis/get_packages.R outputs : moderately_sensitive : cohort : output/installed_packages.csv Run that action using opensafely run get_packages This will create a CSV file containing the version of available packages in OpenSAFELY's R docker image. If you don't run this script via opensafely then it will return the packages available on your local R installation, not the packages in the docker image. If the package you need is not available, you can request it as follows: Make a new Issue in https://github.com/opensafely-core/r-docker/issues Explain the rationale Get another member of the suppoRt group to chip in on the issue (e.g. do they agree; do they think a different package might do the same thing better) Assign to Simon when discussion finished. Requesting additional Stata packages \ud83d\udd17 In many cases Stata packages can be added by copying the relevant ado files into the project repo. Requesting additional Python packages \ud83d\udd17 TODO Manual installation \ud83d\udd17 Whilst the long-term solution in most cases should be to install additional packages properly, an occassion short-term fix is to add the required package (or individual functions) into your project repo directly and load/import them manually. This will only be feasible if the functions do not have a complex hierachy of dependencies. Either way, you should make an Issue for the package so that other users are aware of the package's history in OpenSAFELY.","title":"Adding packages"},{"location":"requests-packages/#requesting-additional-r-packages","text":"The OpenSAFELY R Image ships with a given set of packages baked in. Currently the best way to see the packages that are available is to grab them from a recently-updated docker image as follows: Create an R script, get_packages.R say, with the following line: write.csv ( installed.packages ()[, c ( \"Package\" , \"Version\" )], row.names = FALSE , file = \"output/installed_packages.csv\" ) Add an action to project.yaml that runs this script: get_packages : run : r:latest analysis/get_packages.R outputs : moderately_sensitive : cohort : output/installed_packages.csv Run that action using opensafely run get_packages This will create a CSV file containing the version of available packages in OpenSAFELY's R docker image. If you don't run this script via opensafely then it will return the packages available on your local R installation, not the packages in the docker image. If the package you need is not available, you can request it as follows: Make a new Issue in https://github.com/opensafely-core/r-docker/issues Explain the rationale Get another member of the suppoRt group to chip in on the issue (e.g. do they agree; do they think a different package might do the same thing better) Assign to Simon when discussion finished.","title":"Requesting additional R packages"},{"location":"requests-packages/#requesting-additional-stata-packages","text":"In many cases Stata packages can be added by copying the relevant ado files into the project repo.","title":"Requesting additional Stata packages"},{"location":"requests-packages/#requesting-additional-python-packages","text":"TODO","title":"Requesting additional Python packages"},{"location":"requests-packages/#manual-installation","text":"Whilst the long-term solution in most cases should be to install additional packages properly, an occassion short-term fix is to add the required package (or individual functions) into your project repo directly and load/import them manually. This will only be feasible if the functions do not have a complex hierachy of dependencies. Either way, you should make an Issue for the package so that other users are aware of the package's history in OpenSAFELY.","title":"Manual installation"},{"location":"requests-variables/","text":"To request new functions that create variables via a study definition , follow these instructions: Check that the variable does not already exist, by searching the study definition variables section Check that the variable has not already been requested as an Issue in the cohort-extractor repository. Look at both open and closed Issues in case the variable has been considered by deemed unworkable or low priorty. Create a new Issue in the cohort-extractor repository, and add the enhancement label Explain the rationale Where possible, describe how you expect the function to look for this variable, or how it will modify or enhance an existing variable: what will it be called? what are the function arguments? what are the returning values? Where possible, provide example SQL code for the underlying database query (it doesn't have to be perfect).","title":"Adding Study Definition variables"},{"location":"security-levels/","text":"The OpenSAFELY platform is highly secure. The data available follows a tiered structure of data of four different levels, each of which is permissioned separately. Each stage is generated from the preceding stage \u2014 at each step, data privacy is increased through the removal of potentially identifiable data. Level 1 \ud83d\udd17 This is the most restrictive level and includes the complete, raw, fully-identifiable, event-level patient data. EHR vendor data engineers store data at an identifiable level as part of their business-as-usual; they are instructed to process this data by the GPs (who are in routine practice the data controllers) in order to manage and store this information. No-one outside the EHR vendor has any access to this data. Where is this data held? \ud83d\udd17 Data is held within the EHR vendor's secure environment. Who has access? \ud83d\udd17 Only data processor staff working for the EHR vendor have access at this level (as well as GP clinical staff who can access the data for the purposes of direct patient care). No additional access was granted to members of the OpenSAFELY collaborative to access data at this level. Example \ud83d\udd17 NHS number Name DoB Event Date Practice 979384758 Seb Colbert 12/3/1971 2 month prescription of Glaberol 2mg twice a day. 30/3/2020 10:31 Parkway Practice, Birmingham, B1 2JP 979384758 Seb Colbert 12/3/1971 Diagnosis asthma 2/12/2012 11:22 Grove Practice, London, SE5 8AZ This example demonstrates the level of detail available in level 1 data. It is not representative of how the data is structured. Level 2 \ud83d\udd17 This level includes pseudonymised versions of the coded event-level data produced every week by the EHR vendor for the vendor-OpenSAFELY database. It also includes external datasets imported into the database, for instance hospital admissions and death registry data. Only data for patients who are present in the EHR database are imported from external datasets. The schema for this database can be seen in this notebook (currently accessible only to OpenSAFELY users). Where is this data held? \ud83d\udd17 Data is held within the EHR vendor's secure environment on the OpenSAFELY server. Who has access? \ud83d\udd17 Researchers who hold honorary contracts with NHS England and have signed Data Access Agreements for level 2 or level 3 have access. This includes OpenSAFELY software developers and some researchers. Example \ud83d\udd17 Pseudonym Event Date Location aj834nasdlk 2 month prescription of Glaberol 2mg twice a day. 30/3/2020 10:31 MSOA (approximate location) aj834nasdlk Urea result 7.1 mmol/L 2/03/2020 09:22 MSOA aj834nasdlk Urea result 8.2 mmol/L 2/02/2020 10:41 MSOA aj834nasdlk Diagnosis asthma 2/12/2012 11:22 MSOA This example demonstrates the level of detail available in level 2 data. It is not representative of how the data is structured. Level 3 \ud83d\udd17 This level includes analysis-ready extracts of Level 2 data for specific analyses. I.e., anything that is generated by a study definition . Where is this data held? \ud83d\udd17 Data is held within the EHR vendor's secure environment on the OpenSAFELY server (same as level 2). Who has access? \ud83d\udd17 Currently, anyone with Level 2 access. Level 4 \ud83d\udd17 This level includes tables, figures, and other structured files produced as a result of the analysis of the Level 3 data, for example summary statistics and statistical models. Following scrict disclosivity checks and redactions, files can be released out of the server to the remote git repository on GitHub for further processing and public consumption. Where is this data held? \ud83d\udd17 Data is held within the EHR vendor's secure environment on a specific server, separate from the Level 2 and 3 server. Who has access? \ud83d\udd17 Anyone with Level 2/3 access. In addition, researchers who hold honorary contracts with NHS England and have signed Data Access Agreements relevant to level 4 access (who do not have level 2/3 access) for the purposes of checking and redacting data prior to release. Unrestricted data \ud83d\udd17 Any level 4 files that have undergone strict disclosivity checks and redaction, and therefore considered to have negligible disclosure risk, can be released. Files are released by committing them to the remote git repository on GitHub. Diagram \ud83d\udd17","title":"Security"},{"location":"security-levels/#level-1","text":"This is the most restrictive level and includes the complete, raw, fully-identifiable, event-level patient data. EHR vendor data engineers store data at an identifiable level as part of their business-as-usual; they are instructed to process this data by the GPs (who are in routine practice the data controllers) in order to manage and store this information. No-one outside the EHR vendor has any access to this data.","title":"Level 1"},{"location":"security-levels/#where-is-this-data-held","text":"Data is held within the EHR vendor's secure environment.","title":"Where is this data held?"},{"location":"security-levels/#who-has-access","text":"Only data processor staff working for the EHR vendor have access at this level (as well as GP clinical staff who can access the data for the purposes of direct patient care). No additional access was granted to members of the OpenSAFELY collaborative to access data at this level.","title":"Who has access?"},{"location":"security-levels/#example","text":"NHS number Name DoB Event Date Practice 979384758 Seb Colbert 12/3/1971 2 month prescription of Glaberol 2mg twice a day. 30/3/2020 10:31 Parkway Practice, Birmingham, B1 2JP 979384758 Seb Colbert 12/3/1971 Diagnosis asthma 2/12/2012 11:22 Grove Practice, London, SE5 8AZ This example demonstrates the level of detail available in level 1 data. It is not representative of how the data is structured.","title":"Example"},{"location":"security-levels/#level-2","text":"This level includes pseudonymised versions of the coded event-level data produced every week by the EHR vendor for the vendor-OpenSAFELY database. It also includes external datasets imported into the database, for instance hospital admissions and death registry data. Only data for patients who are present in the EHR database are imported from external datasets. The schema for this database can be seen in this notebook (currently accessible only to OpenSAFELY users).","title":"Level 2"},{"location":"security-levels/#where-is-this-data-held_1","text":"Data is held within the EHR vendor's secure environment on the OpenSAFELY server.","title":"Where is this data held?"},{"location":"security-levels/#who-has-access_1","text":"Researchers who hold honorary contracts with NHS England and have signed Data Access Agreements for level 2 or level 3 have access. This includes OpenSAFELY software developers and some researchers.","title":"Who has access?"},{"location":"security-levels/#example_1","text":"Pseudonym Event Date Location aj834nasdlk 2 month prescription of Glaberol 2mg twice a day. 30/3/2020 10:31 MSOA (approximate location) aj834nasdlk Urea result 7.1 mmol/L 2/03/2020 09:22 MSOA aj834nasdlk Urea result 8.2 mmol/L 2/02/2020 10:41 MSOA aj834nasdlk Diagnosis asthma 2/12/2012 11:22 MSOA This example demonstrates the level of detail available in level 2 data. It is not representative of how the data is structured.","title":"Example"},{"location":"security-levels/#level-3","text":"This level includes analysis-ready extracts of Level 2 data for specific analyses. I.e., anything that is generated by a study definition .","title":"Level 3"},{"location":"security-levels/#where-is-this-data-held_2","text":"Data is held within the EHR vendor's secure environment on the OpenSAFELY server (same as level 2).","title":"Where is this data held?"},{"location":"security-levels/#who-has-access_2","text":"Currently, anyone with Level 2 access.","title":"Who has access?"},{"location":"security-levels/#level-4","text":"This level includes tables, figures, and other structured files produced as a result of the analysis of the Level 3 data, for example summary statistics and statistical models. Following scrict disclosivity checks and redactions, files can be released out of the server to the remote git repository on GitHub for further processing and public consumption.","title":"Level 4"},{"location":"security-levels/#where-is-this-data-held_3","text":"Data is held within the EHR vendor's secure environment on a specific server, separate from the Level 2 and 3 server.","title":"Where is this data held?"},{"location":"security-levels/#who-has-access_3","text":"Anyone with Level 2/3 access. In addition, researchers who hold honorary contracts with NHS England and have signed Data Access Agreements relevant to level 4 access (who do not have level 2/3 access) for the purposes of checking and redacting data prior to release.","title":"Who has access?"},{"location":"security-levels/#unrestricted-data","text":"Any level 4 files that have undergone strict disclosivity checks and redaction, and therefore considered to have negligible disclosure risk, can be released. Files are released by committing them to the remote git repository on GitHub.","title":"Unrestricted data"},{"location":"security-levels/#diagram","text":"","title":"Diagram"},{"location":"study-def-flowcharts/","text":"Flowcharts (temporary workaround) \ud83d\udd17 Many studies will require a flowchart to show inclusion/exclusion of patients in the study. Eventually the numbers of patients excluded/included will be summarised automatically following cohort extract, but for now, a slightly manual approach is required: Make a copy of the study definition (called study_definition_flow_chart.py ). The population=patients.satisfying() function should be replaced with population=patients.all() . Then all variables except for those that appeared in the population definition logic should be removed (this will mean that it runs much faster than the main study definition ). An example of such a study definition can be seen in this repository on NSAIDS use and COVID-related outcomes . Then write a script that reads the input_flow_chart.csv and then sequentially drops each of the variables and counts the remaining population, in whatever order you'd like to report them. Here's an example written in Stata","title":"Inclusion/exclusion flow charts"},{"location":"study-def-flowcharts/#flowcharts-temporary-workaround","text":"Many studies will require a flowchart to show inclusion/exclusion of patients in the study. Eventually the numbers of patients excluded/included will be summarised automatically following cohort extract, but for now, a slightly manual approach is required: Make a copy of the study definition (called study_definition_flow_chart.py ). The population=patients.satisfying() function should be replaced with population=patients.all() . Then all variables except for those that appeared in the population definition logic should be removed (this will mean that it runs much faster than the main study definition ). An example of such a study definition can be seen in this repository on NSAIDS use and COVID-related outcomes . Then write a script that reads the input_flow_chart.csv and then sequentially drops each of the variables and counts the remaining population, in whatever order you'd like to report them. Here's an example written in Stata","title":"Flowcharts (temporary workaround)"},{"location":"study-def-variables/","text":"This section describes each available function for creating variables within a study definition . For more information on the datasets contained within the OpenSAFELY database, see the Data sources section . For more information on writing a study definition , go to the study definition section . Primary Care Record \ud83d\udd17 These variables are derived from data held in the patients' primary care records. registered_as_of ( reference_date , return_expectations = None ) \ud83d\udd17 All patients registered on the given date. Note this function passes arguments to registered_with_one_practice_between() Parameters: Name Description Default reference_date date of interest as a string with the format YYYY-MM-DD . Filters results to patients registered at a practice on the given date. required return_expectations a dictionary containing an expectation definition defining an incidence between 0 and 1 . None Returns: Type Description list of integers of 1 or 0 . Examples: This creates a variable \"registered\" with patient returning an integer of 1 if patient registered at date. Patients who are not registered return an integer of 0 : registered=patients.registered_as_of( \"2020-03-01\", return_expectations={\"incidence\": 0.98} ) registered_with_one_practice_between ( start_date , end_date , return_expectations = None ) \ud83d\udd17 All patients registered with the same practice through the given period Parameters: Name Description Default start_date start date of interest of period as a string with the format YYYY-MM-DD . Together with end date, this filters results to patients registered at a practice between two dates required end_date end date of interest of period as a string with the format YYYY-MM-DD . Together with start date, this filters results to patients registered at a practice between two dates required return_expectations a dictionary containing an expectation definition defining an incidence between 0 and 1 . None Returns: Type Description list of integers of 1 or 0 . Examples: This creates a variable registered_one with patient returning an integer of 1 if patient registered at one practice between two dates. Patients who are not registered return an integer of 0 . registered_one=patients.registered_with_one_practice_between( start_date=\"2020-03-01\", end_date=\"2020-06-01\", return_expectations={\"incidence\": 0.90} ) date_deregistered_from_all_supported_practices ( on_or_before = None , on_or_after = None , between = None , date_format = None , return_expectations = None ) \ud83d\udd17 Returns the date (if any) on which the patient de-registered from all practices for which OpenSAFELY has data. Events which occur in primary care after this date will not be recorded in the platform (though there may be data from other sources e.g. SGSS, CPNS). Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of strings with a date format returned if patient had deregistered, otherwise empty Examples: A variable called dereg_date is created with returns a date of de-registration if patient has deregistered from a practice within the dataset within the specified time period. dereg_date=patients.date_deregistered_from_all_supported_practices( on_or_after=\"2020-03-01\", date_format=\"YYYY-MM\", return_expectations={ {\"date\": {\"earliest\": \"2020-03-01\"}, \"incidence\": 0.05 } ) with_complete_history_between ( start_date , end_date , return_expectations = None ) \ud83d\udd17 All patients for which we have a full set of records between the given dates Parameters: Name Description Default start_date start date of interest of period as a string with the format YYYY-MM-DD . Together with end date, this filters results to patients registered at a practice between two dates who have a complete history. required end_date end date of interest of period as a string with the format YYYY-MM-DD . Together with start date, this filters results to patients registered at a practice between two dates who have a complete history. required return_expectations a dictionary containing an expectation definition defining an incidence between 0 and 1 . None Returns: Type Description list of integers of 1 or 0 Examples: This creates a variable has_consultation_history with patient returning an integer of 1 if patient registered at one practice between two dates and has a completed record. Patients who are not registered with a complete record return an integer of 0 . has_consultation_history=patients.with_complete_gp_consultation_history_between( start_date=\"2019-02-01\", end_date=\"2020-01-31\", return_expectations={\"incidence\": 0.9}, ) with_complete_gp_consultation_history_between ( start_date , end_date , return_expectations = None ) \ud83d\udd17 The concept of a \"consultation\" in EHR systems does not map exactly to the GP-patient interaction we're interested in (see above) so there is some processing required on the part of the EHR vendor to produce the consultation record we need. This does not happen automatically as part of the GP2GP transfer, and therefore this query can be used to find just those patients for which the full history is available. This means finding patients who have been continuously registered with a single TPP-using practice throughout a time period. Parameters: Name Description Default start_date start date of interest as a string with the format YYYY-MM-DD required end_date end date of interest as a string with the format YYYY-MM-DD required return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None registered_practice_as_of ( date , returning = None , return_expectations = None ) \ud83d\udd17 Return patients' practice address characteristics such as STP or MSOA Parameters: Name Description Default date date of interest as a string with the format YYYY-MM-DD . Filters results to the given date. required returning a str defining the type of data to be returned. options include msoa , nuts1_region_name, and stp_code . The default value is None . None return_expectations a dict defining the rate and the categories returned with ratios None Returns: Type Description list of strings Exceptions: Type Description ValueError if unsupported returning argument is provided Examples: This creates a variable called region based on practice address of the patient: region=patients.registered_practice_as_of( \"2020-02-01\", returning=\"nuts1_region_name\", return_expectations={ \"rate\": \"universal\", \"category\": { \"ratios\": { \"North East\": 0.1, \"North West\": 0.1, \"Yorkshire and the Humber\": 0.1, \"East Midlands\": 0.1, \"West Midlands\": 0.1, \"East of England\": 0.1, \"London\": 0.2, \"South East\": 0.2, }, }, }, ) address_as_of ( date , returning = None , round_to_nearest = None , return_expectations = None ) \ud83d\udd17 Return patients' address characteristics such as IMD as of a particular date Parameters: Name Description Default date date of interest as a string with the format YYYY-MM-DD . Filters results to the given date. required returning a str defining the type of data to be returned. options include index_of_multiple_deprivation rural_urban_classification , and msoa . The default value is None . None round_to_nearest an integer that represents how index_of_multiple_deprivation value are rounded. Only use when returning is index_of_multiple_deprivation None return_expectations a dict defining the rate and the categories returned with ratios None Returns: Type Description list of integers for rural_urban_classification and index_of_multiple_deprivation , strings for msoa Exceptions: Type Description ValueError if unsupported returning argument is provided Examples: This creates a variable called imd based on patient address. imd=patients.address_as_of( \"2020-02-29\", returning=\"index_of_multiple_deprivation\", round_to_nearest=100, return_expectations={ \"rate\": \"universal\", \"category\": {\"ratios\": {\"100\": 0.1, \"200\": 0.2, \"300\": 0.7}}, }, ) with_gp_consultations ( on_or_before = None , on_or_after = None , between = None , find_first_match_in_period = None , find_last_match_in_period = None , returning = 'binary_flag' , date_format = None , return_expectations = None ) \ud83d\udd17 These are GP-patient interactions, either in person or via phone/video call. The concept of a \"consultation\" in EHR systems is generally broader and might include things like updating a phone number with the receptionist. Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None find_first_match_in_period a boolean that indicates if the data returned is first event if there are multiple matches within the time period None find_last_match_in_period a boolean that indicates if the data returned is last event if there are multiple matches within the time period None returning a string indicating what type of value should be returned. The options are limited to binary_flag (which indicates if they have had the an event or not), date (which indicate date of event and used with either find_first_match_in_period or find_last_match_in_period), or number_of_matches_in_period (which counts the events in the period) 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date ; a list of integers if returning argument is set to number_of_matches_in_period Examples: A variable called gp_count is created that counts number of GP consultation between two dates in 2019. gp_count=patients.with_gp_consultations( between=[\"2019-01-01\", \"2020-12-31\"], returning=\"number_of_matches_in_period\", return_expectations={ \"int\": {\"distribution\": \"normal\", \"mean\": 6, \"stddev\": 3}, \"incidence\": 0.6, }, ) sex ( return_expectations = None ) \ud83d\udd17 Returns the sex of the patient. Parameters: Name Description Default return_expectations a dict containing an expectation definition defining a rate and a ratio for sexes None Returns: Type Description list \"M\" male, \"F\" female, \"I\" intersex, or \"U\" unknown. Examples: This creates a variable 'sex' with all patients returning a sex of either \"M\", \"F\" or \"\" sex=patients.sex( return_expectations={ \"rate\": \"universal\", \"category\": {\"ratios\": {\"M\": 0.49, \"F\": 0.51}}, } ) age_as_of ( reference_date , return_expectations = None ) \ud83d\udd17 Returns age of patient of at a particular date. Note can be negative if born after reference_date . Parameters: Name Description Default reference_date date of interest as a string with the format YYYY-MM-DD required return_expectations a dict defining an expectation definition that includes at least a rate and a distribution. If distribution is defined as \"population_ages\" it returns likely distribution based on known UK age bands in 2018 (see file: \"uk_population_bands_2018.csv\") None Returns: Type Description list ages as integers Examples: This creates a variable \"age\" with all patient returning an age as an integer: age=patients.age_as_of( \"2020-02-01\", return_expectations={ \"rate\" : \"universal\", \"int\" : {\"distribution\" : \"population_ages\"} } ) date_of_birth ( date_format = None , return_expectations = None ) \ud83d\udd17 Returns date of birth as a string with format \"YYYY-MM\" Parameters: Name Description Default date_format a string detailing the format of the dates for date of birth to be returned. It can be \"YYYY-MM\" or \"YYYY\" and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with month and year. None return_expectations a dictionary containing an expectation definition defining a rate and a distribution None Returns: Type Description list dates as strings with \"YYYY-MM\" format Exceptions: Type Description ValueError if Date of Birth is attempted to be returned with a YYYY-MM-DD format. Examples: This creates a variable dob with all patient returning a year and month as a string: dob=patients.date_of_birth( \"YYYY-MM\", return_expectations={ \"date\": {\"earliest\": \"1950-01-01\", \"latest\": \"today\"}, \"rate\": \"uniform\", } ) most_recent_bmi ( on_or_before = None , on_or_after = None , between = None , minimum_age_at_measurement = 16 , return_expectations = None , include_measurement_date = False , date_format = None , include_month = False , include_day = False ) \ud83d\udd17 Return patients' most recent BMI (in the defined period) either computed from weight and height measurements or, where they are not availble, from recorded BMI values. Measurements taken when a patient was below the minimum age are ignored. The height measurement can be taken before (but not after) the defined period as long as the patient was over the minimum age at the time. The date of the measurement can be obtained using date_of(\"<bmi-column-name>\") . If the BMI is computed from weight and height then we use the date of the weight measurement for this. Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to measurements on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to measurements on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to measurements between the two dates provided. The default value is None . None minimum_age_at_measurement Measurements taken before this age will not count towards BMI calculations. It is an integer and the default value is 16. 16 return_expectations a dictionary defining the incidence and distribution of expected BMI within the population in question. This is a 3-item key-value dictionary of \"date\" and \"float\". \"date\" is dictionary itself and should contain the earliest and latest dates needed in the dummy data. float is a dictionary of distribution , mean , and stddev . These values determine the shape of the dummy data returned, and the float means a float will be returned rather than an integer. incidence must have a value and this is what percentage of dummy patients have a BMI. It needs to be a number between 0 and 1. None include_measurement_date a boolean indicating if an extra column, named date_of_bmi , should be included in the output. The default value is False . False date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. Only used if include_measurement_date is True None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False Returns: Type Description float most recent BMI Examples: This creates a variable \"bmi\" returning a float of the most recent bmi calculated from recorded height and weight, or from a recorded bmi record. Patient who do not have this information available do not return a value: bmi=patients.most_recent_bmi( between=[\"2010-02-01\", \"2020-01-31\"], minimum_age_at_measurement=18, include_measurement_date=True, date_format=\"YYYY-MM\", return_expectations={ \"date\": {\"earliest\": \"2010-02-01\", \"latest\": \"2020-01-31\"}, \"float\": {\"distribution\": \"normal\", \"mean\": 28, \"stddev\": 8}, \"incidence\": 0.80, } ) mean_recorded_value ( codelist , on_most_recent_day_of_measurement = None , return_expectations = None , on_or_before = None , on_or_after = None , between = None , include_measurement_date = False , date_format = None , include_month = False , include_day = False ) \ud83d\udd17 Return patients' mean recorded value of a numerical value as defined by a codelist on a particular day within the defined period. This is important as allows us to account for multiple measurements taken on one day. The date of the measurement can be included by flagging with date format options. Parameters: Name Description Default codelist a codelist for requested value required on_most_recent_day_of_measurement boolean flag for requesting measurements be on most recent date None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. This is a 3-item key-value dictionary of \"date\" and \"float\". \"date\" is dictionary itself and should contain the earliest and latest dates needed in the dummy data. float is a dictionary of distribution , mean , and stddev . These values determine the shape of the dummy data returned, and the float means a float will be returned rather than an integer. incidence must have a value and this is what percentage of dummy patients have a value. It needs to be a number between 0 and 1. None on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to measurements on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to measurements on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to measurements between the two dates provided. The default value is None . None include_measurement_date a boolean indicating if an extra column, named date_of_bmi , should be included in the output. The default value is False . False date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. Only used if include_measurement_date is True None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False Returns: Type Description float mean of value Examples: This creates a variable bp_sys returning a float of the most recent systolic blood pressure from the record within the time period. In the event of repeated measurements on the same day, these are averaged. Patient who do not have this information available do not return a value: bp_sys=patients.mean_recorded_value( systolic_blood_pressure_codes, on_most_recent_day_of_measurement=True, between=[\"2017-02-01\", \"2020-01-31\"], include_measurement_date=True, date_format=\"YYYY-MM\", return_expectations={ \"float\": {\"distribution\": \"normal\", \"mean\": 80, \"stddev\": 10}, \"date\": {\"earliest\": \"2019-02-01\", \"latest\": \"2020-01-31\"}, \"incidence\": 0.95, }, ) with_these_medications ( codelist , return_expectations = None , on_or_before = None , on_or_after = None , between = None , find_first_match_in_period = None , find_last_match_in_period = None , returning = 'binary_flag' , include_date_of_match = False , date_format = None , ignore_days_where_these_clinical_codes_occur = None , episode_defined_as = None , return_binary_flag = None , return_number_of_matches_in_period = False , return_first_date_in_period = False , return_last_date_in_period = False , include_month = False , include_day = False ) \ud83d\udd17 Patients who have been prescribed at least one of this list of medications in the defined period Parameters: Name Description Default codelist a codelist for requested medication(s) required return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. If returning an integer (returning number_of_matches_in_period, number_of_episodes), this is a 2-item key-value dictionary of int and incidence . int is a dictionary of distribution , mean , and stddev . These values determine the shape of the dummy data returned, and the int means a int will be returned rather than a float. incidence must have a value and this is what percentage of dummy patients have a value. It needs to be a number between 0 and 1. If returning binary_flag this is a 1-item dictionary of incidence as described above. If returning either first_date_in_period or last_date_in_period , this is a 2-item dictionary of date and incidence . date is a dict of earliest and/or latest date possible. None on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a str defining the type of data to be returned. Options include binary_flag , date , number_of_matches_in_period , number_of_episodes , code , category . The default value is binary_flag . 'binary_flag' find_first_match_in_period a boolean indicating if any returned date, code, category, or numeric value should be based on the first match in the period. None find_last_match_in_period a boolean indicating if any returned date, code, category, or numeric value should be based on the last match in the period. None include_date_of_match a boolean indicating if an extra column should be included in the output. The default value is False . False date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. Only used if include_date_of_match is True None ignore_days_where_these_clinical_codes_occur a codelist that contains codes for medications to be ignored. if a medication is found on this day, the date is not matched even it matches a code in the main codelist None episode_defined_as a string expression indicating how an episode should be defined None return_binary_flag a bool indicatin if a binary flag should be returned (deprecated: use date_format instead) None return_number_of_matches_in_period a boolean indicating if the number of matches in a period should be returned (deprecated: use date_format instead) False return_first_date_in_period a boolean indicating if the first matches in a period should be returned (deprecated: use date_format instead) False return_last_date_in_period a boolean indicating if the last matches in a period should be returned (deprecated: use date_format instead) False include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag , number_of_episodes or number_of_matches_in_period ; list of strings with a date format returned if returning argument is set to first_date_in_period or last_date_in_period . Examples: This creates a variable exacerbation_count returning an int of the number of episodes of oral steroids being prescribed within the time period where a prescription is counted as part of the same episode if it falls within 28 days of a previous prescription. Days where oral steroids are prescribed on the same day as a COPD review are also ignored as may not represent true exacerbations. exacerbation_count=patients.with_these_medications( oral_steroid_med_codes, between=[\"2019-03-01\", \"2020-02-29\"], ignore_days_where_these_clinical_codes_occur=copd_reviews, returning=\"number_of_episodes\", episode_defined_as=\"series of events each <= 28 days apart\", return_expectations={ \"int\": {\"distribution\": \"normal\", \"mean\": 2, \"stddev\": 1}, \"incidence\": 0.2, }, ) with_these_clinical_events ( codelist , return_expectations = None , on_or_before = None , on_or_after = None , between = None , find_first_match_in_period = None , find_last_match_in_period = None , returning = 'binary_flag' , include_date_of_match = False , date_format = None , ignore_days_where_these_codes_occur = None , episode_defined_as = None , return_binary_flag = None , return_number_of_matches_in_period = False , return_first_date_in_period = False , return_last_date_in_period = False , include_month = False , include_day = False ) \ud83d\udd17 Patients who have had at least one of these clinical events in the defined period Parameters: Name Description Default codelist a codelist for requested event(s) required return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. If returning an integer ( returning=number_of_matches_in_period or returning=number_of_episodes ), this is a 2-item key-value dictionary of int and incidence . int is a dictionary of distribution , mean , and stddev . These values determine the shape of the dummy data returned, and the int means a int will be returned rather than a float. incidence must have a value and this is what percentage of dummy patients have a value. It needs to be a number between 0 and 1. If returning binary_flag this is a 1-item dictionary of incidence as described above. If returning either first_date_in_period or last_date_in_period , this is a 2-item dictionary of date and incidence . date is a dict of earliest and/or latest date possible. None on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a str defining the type of data to be returned. Options include binary_flag , date , number_of_matches_in_period , number_of_episodes , code , category , or numeric_value . The default value is binary_flag . 'binary_flag' find_first_match_in_period a boolean indicating if any returned date, code, category, or numeric value should be based on the first match in the period. None find_last_match_in_period a boolean indicating if any returned date, code, category, or numeric value should be based on the last match in the period. None include_date_of_match a boolean indicating if an extra column should be included in the output. The default value is False . False date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. Only used if include_date_of_match is True None ignore_days_where_these_codes_occur a codelist that contains codes for events to be ignored. if a events is found on this day, the date is not matched even it matches a code in the main codelist None episode_defined_as a string expression indicating how an episode should be defined None return_binary_flag a boolean indicating if the number of matches in a period should be returned (deprecated: use date_format instead), None return_number_of_matches_in_period a boolean indicating if the number of matches in a period should be returned (deprecated: use date_format instead) False return_first_date_in_period a boolean indicating if the first matches in a period should be returned (deprecated: use date_format instead) False return_last_date_in_period a boolean indicating if the last matches in a period should be returned (deprecated: use date_format instead) False include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag , number_of_episodes or number_of_matches_in_period ; list of strings with a date format returned if returning argument is set to first_date_in_period or last_date_in_period . a list of strings with a category represented in an extra column in the codelist object category is returned. Examples: This creates a variable haem_cancer returning the first date of a diagnosis of haematology malignancy within the time period. haem_cancer=patients.with_these_clinical_events( haem_cancer_codes, between=[\"2015-03-01\", \"2020-02-29\"], returning=\"date\", find_first_match_in_period=True, return_expectations={\"date\": {earliest; \"2015-03-01\", \"latest\": \"2020-02-29\"}}, ) with_death_recorded_in_primary_care ( on_or_before = None , on_or_after = None , between = None , returning = 'binary_flag' , date_format = None , return_expectations = None ) \ud83d\udd17 Identify patients with a date-of-death in their primary care record. There is generally a lag between the death being recorded in ONS data and appearing in the primary care record, but the date itself is usually reliable when it appears. By contrast, cause of death is often not accurate in the primary care record so we don't make it available to query here. Args: !!! on_or_before \"date of interest as a string with the format `YYYY-MM-DD`. Filters results\" on or before the given date. The default value is `None`. !!! on_or_after \"date of interest as a string with the format `YYYY-MM-DD`. Filters results\" on or after the given date. The default value is `None`. !!! between \"two dates of interest as a list with each date as a string with the format `YYYY-MM-DD`.\" Filters results to between the two dates provided. The default value is `None`. !!! returning \"a string indicating what type of value should be returned. The options are:\" date_of_death: Date of death binary_flag: If they died or not !!! date_format \"a string detailing the format of the dates to be returned. It can be `YYYY-MM-DD`,\" `YYYY-MM` or `YYYY` and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. !!! return_expectations \"a dictionary defining the incidence and distribution of expected value\" within the population in question. Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date_of_death Examples: A variable called died_date_gp is created that returns the date of death for any patients have died in the GP dataset. died_date_gp=patients.with_death_recorded_in_primary_care( on_or_after=\"2020-02-01\", returning=\"date_of_death\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ), care_home_status_as_of ( date , categorised_as = None , return_expectations = None ) \ud83d\udd17 TPP have attempted to match patient addresses to care homes as stored in the CQC database. At its most simple this query returns a boolean indicating whether the patient's address (as of the supplied time) matched with a care home. It is also possible return a more complex categorisation based on attributes of the care homes in the CQC database, which can be freely downloaded here: https://www.cqc.org.uk/about-us/transparency/using-cqc-data At present the only imported fields are: LocationRequiresNursing LocationDoesNotRequireNursing But we can ask for more fields to be imported if needed. The categorised_as argument acts in effectively the same way as for the categorised_as function except that the only columns that can be referred to are those belonging to the care home table (i.e. the two nursing fields above) and the boolean IsPotentialCareHome Parameters: Name Description Default date date of interest as a string with the format YYYY-MM-DD . Filters results to the given date required categorised_as a logic expression that applies an algorithm to specific variables to create categories None return_expectations a dict defining the rate and the categories returned with ratios None Returns: Type Description list of strings which each letter representing a category as defined by the algorithm Examples: This creates a variable called care_home_type which contains a 2 letter string which represents a type of care home environment. care_home_type=patients.care_home_status_as_of( \"2020-02-01\", categorised_as={ \"PC\": \"\"\" IsPotentialCareHome AND LocationDoesNotRequireNursing='Y' AND LocationRequiresNursing='N' \"\"\", \"PN\": \"\"\" IsPotentialCareHome AND LocationDoesNotRequireNursing='N' AND LocationRequiresNursing='Y' \"\"\", \"PS\": \"IsPotentialCareHome\", \"U\": \"DEFAULT\", }, return_expectations={ \"rate\": \"universal\", \"category\": {\"ratios\": {\"PC\": 0.05, \"PN\": 0.05, \"PS\": 0.05, \"U\": 0.85,},}, }, ), with_tpp_vaccination_record ( target_disease_matches = None , product_name_matches = None , on_or_before = None , on_or_after = None , between = None , returning = 'binary_flag' , date_format = None , find_first_match_in_period = None , find_last_match_in_period = None , return_expectations = None ) \ud83d\udd17 Identify patients with a vaccination record for a target disease within the tpp vaccination record Vaccinations can be recorded via a Vaccination Record or via prescription of a vaccine i.e a product code. Parameters: Name Description Default target_disease_matches the target disease as a string None product_name_matches the product name as a string None on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a string indicating what type of value should be returned. The options are limited to binary_flag (which indicates if they have had the vaccination or not) or a date of vaccination 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None find_first_match_in_period a boolean that indicates if the data returned is first indication of vaccination if there are multiple matches within the time period None find_last_match_in_period a boolean that indicates if the data returned is last indication of vaccination if there are multiple matches within the time period None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date Examples: A variable called flu_vaccine is created that returns the date of vaccination for any patients in the GP dataset between 2 dates. flu_vaccine=patients.with_tpp_vaccination_record( target_disease_matches=\"influenza\", between=[\"2019-09-01\", \"2020-04-01\"], returning=\"date\", date_format=\"YYYY-MM\", find_first_match_in_period=True, return_expectations={ date\": {\"earliest\": \"2019-09-01\", \"latest\": \"2020-03-29\"} } ), household_as_of ( reference_date , returning = None , return_expectations = None ) \ud83d\udd17 Return information about the household to which the patient belonged as of the reference date. This is inferred from address data using an algorithm developed by TPP (to be documented soon) so the results are not 100% reliable but are apparently pretty good. !!! args reference_date: date of interest as a string with the format `YYYY-MM-DD`. Filters results to a particular set date !!! returning \"a string indicating what type of value should be returned. The options for `returning` are:\" !!! pseudo_id \"An integer identifier for the household which has no meaning\" other than to identify individual members of the same household (0 if no household information available) !!! household_size \"the number of individuals in the household (0 if no\" household information available) !!! is_prison \"Boolean indicating whether household is a prison. See\" https://github.com/opensafely/cohort-extractor/issues/271#issuecomment-679069981 for details of how this is determined. !!! has_members_in_other_ehr_systems \"Boolean indicating whether some household\" members are registered with GPs using a different EHR system, meaning that our coverage of the household is incomplete. !!! percentage_of_members_with_data_in_this_backend \"Integer giving the (estimated)\" percentage of household members where we have EHR data available in this backend (i.e. not in other systems as above) msoa: Returns the MSOA (Middle Super Output Area) in which the household is situated return_expectations: a dictionary defining the incidence and distribution of expected value within the population in question. Returns: Type Description list of integers if returning argument is set to pseudo_id , household_size or percentage_of_members_with_data_in_this_backend . a list of 1 or 0 is returning is set to is_prison or has_members_in_other_ehr_systems Examples: household_id=patients.household_as_of( \"2020-02-01\", returning=\"pseudo_id\" ) household_size=patients.household_as_of( \"2020-02-01\", returning=\"household_size\" ), APCS \ud83d\udd17 These variables are derived from Admitted Patient Care Statistics (APCS) data on in-patient hospital admissions across England. For more information, see the APCS data section . admitted_to_hospital ( on_or_before = None , on_or_after = None , between = None , returning = 'binary_flag' , find_first_match_in_period = None , find_last_match_in_period = None , date_format = None , with_these_diagnoses = None , with_these_primary_diagnoses = None , with_these_procedures = None , return_expectations = None ) \ud83d\udd17 Return information about admission to hospital. See https://github.com/opensafely/cohort-extractor/issues/186 for in-depth discussion and background. Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a string indicating what type of value should be returned. Options for returning are: binary_flag: if they were admitted at all date_admitted: date patient admitted to hospital date_discharged: date patient discharged from hospital number_of_matches_in_period: number of times patient was admitted in time period specified primary_diagnosis: primary diagnosis code for admission 'binary_flag' find_first_match_in_period a boolean that indicates if the data returned is first event if there are multiple matches within the time period None find_last_match_in_period a boolean that indicates if the data returned is last event if there are multiple matches within the time period None date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None with_these_diagnoses icd10 codes to match against any diagnosis None with_these_primary_diagnoses icd10 codes to match against the primary diagnosis None with_these_procedures opcs4 codes to match against the procedure None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date_admitted or date_discharged ; of integers if returning argument is set to number_of_matches_in_period . list of strings with alphanumerical code format for ICD10 code if returning argument is set to primary_diagnosis Examples: The day of each patient's first hospital admission for Covid19: covid_admission_date=patients.admitted_to_hospital( returning= \"date_admitted\", with_these_diagnoses=covid_codelist, on_or_after=\"2020-02-01\", find_first_match_in_period=True, date_format=\"YYYY-MM-DD\", return_expectations={\"date\": {\"earliest\": \"2020-03-01\"}}, ) ECDS \ud83d\udd17 These variables are derived from Emergency Care Data Set ( ECDS ) data on emergency department attendances across England. For more information, see the ECDS data section . attended_emergency_care ( on_or_before = None , on_or_after = None , between = None , returning = 'binary_flag' , find_first_match_in_period = None , find_last_match_in_period = None , date_format = None , with_these_diagnoses = None , discharged_to = None , return_expectations = None ) \ud83d\udd17 Return information about attendance of A&E from the ECDS dataset. Please note that there is a limited number of diagnoses allowed within this dataset, and so will not match with the range of diagnoses allowed in other datasets such as the primary care record. Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a string indicating what type of value should be returned. Options for returning are: binary_flag: Whether patient attended A&E date_arrived: date patient arrived in A&E number_of_matches_in_period: number of times patient attended A&E discharge_destination: SNOMED CT code of discharge destination. This will be a member of refset 999003011000000105. 'binary_flag' find_first_match_in_period a boolean that indicates if the data returned is first event if there are multiple matches within the time period None find_last_match_in_period a boolean that indicates if the data returned is last event if there are multiple matches within the time period None date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None with_these_diagnoses a list of SNOMED CT codes None discharged_to a list of members of refset 999003011000000105. None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date_arrived ; of integers if returning argument is set to number_of_matches_in_period or discharge_destination (with SNOMED CT code as a numerical value) Examples: A variable called emergency_care is created with returns a date of first attendence in A&E if patient had attended emergency room during the time period. emergency_care=patients.attended_emergency_care( on_or_after=\"2020-01-01\", returning=\"date_arrived\", date_format=\"YYYY-MM-DD\", find_first_match_in_period=True, return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ) ICNARC \ud83d\udd17 These variables are derived from the Intensive Care National Audit and Research Centre Case-Mix Programme ( ICNARC -CMP), which collects information on ICU admissions across England. For more information, see the ICNARC data section . admitted_to_icu ( on_or_after = None , on_or_before = None , between = None , find_first_match_in_period = None , find_last_match_in_period = None , returning = 'binary_flag' , date_format = None , return_expectations = None , include_month = False , include_day = False ) \ud83d\udd17 Return information about being admitted to ICU. Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . None find_first_match_in_period a boolean that indicates if the data returned is first admission to icu if there are multiple admissions within the time period None find_last_match_in_period a boolean that indicates if the data returned is last admission to icu if there are multiple admissions within the time period None returning binary_flag: Whether patient attended A&E date_admitted: Date patient arrived in A&E had_respiratory_support: Whether patient received any form of respiratory support had_basic_respiratory_support: Whether patient received \"basic\" respiratory support had_advanced_respiratory_support: Whether patient received \"advanced\" respiratory support (Note that the terms \"basic\" and \"advanced\" are derived from the underlying ICNARC data.) 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. Only used if returning is binary_flag None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. This is a 2-item key-value dictionary of date and rate . None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag , had_respiratory_support , had_basic_respiratory_support or had_advanced_respiratory_support ; list of strings with a date format returned if returning argument is set to date_admitted Examples: This returns two variables \u2014 one called icu_date_admitted and another had_resp_support : has_resp_support=patients.admitted_to_icu( on_or_after=\"2020-02-01\", find_first_match_in_period=True, returning=\"had_respiratory_support\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ), icu_date_admitted=patients.admitted_to_icu( on_or_after=\"2020-02-01\", find_first_match_in_period=True, returning=\"date_admitted\", date_format=\"YYYY-MM-DD\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ), SGSS \ud83d\udd17 These variables are derived from Second Generation Surveillance System ( SGSS ) data which captures routine laboratory surveillance data on infectious diseases across England. For more information, see the SGSS data section . with_test_result_in_sgss ( pathogen = None , test_result = 'any' , on_or_before = None , on_or_after = None , between = None , find_first_match_in_period = None , find_last_match_in_period = None , returning = 'binary_flag' , date_format = None , return_expectations = None ) \ud83d\udd17 Finds lab test results recorded in SGSS (Second Generation Surveillance System). Please note for the dates this is used in the database as the date the specimen was taken, rather than the date of the lab result. There's an important caveat here: where a patient has multiple positive tests, SGSS groups these into \"episodes\" (referred to as \"Organism-Patient-Illness-Episodes\"). Each pathogen has a maximum episode duration (usually 2 weeks) and unless positive tests are separated by longer than this period they are assumed to be the same episode of illness. The specimen date recorded is the earliest positive specimen within the episode. For SARS-CoV-2 the episode length has been set to infinity, meaning that once a patient has tested positive every positive test will be part of the same episode and record the same specimen date. This means that using find_last_match_in_period is pointless when querying for positive results as only one date will ever be recorded and it will be the earliest. Our natural assumption, though it doesn't seem to be explicity stated in the documentation, is that every negative result is treated as unique. For more detail on SGSS in general see: https://assets.publishing.service.gov.uk/government/uploads/system/uploads/attachment_data/file/739854/PHE_Laboratory_Reporting_Guidelines.pdf Information about the SARS-CoV-2 episode length was via email from someone at the National Infection Service: The COVID-19 episode length in SGSS was set to indefinite, so all COVID-19 records from a single patient will be classified as one episode. This may change, but is set as it is due to limited information around re-infection and virus clearance. Parameters: Name Description Default pathogen pathogen we are interested in. Only SARS-CoV-2 results are included in our data extract so this will throw an error if the specified pathogen is anything other than \"SARS-CoV-2\". None test_result must be one of \"positive\", \"negative\" or \"any\" 'any' on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None find_first_match_in_period a boolean that indicates if the data returned is first event if there are multiple matches within the time period None find_last_match_in_period a boolean that indicates if the data returned is last event if there are multiple matches within the time period None returning a string indicating what type of value should be returned. The options are limited to binary_flag (which indicates if they have had the an event or not) and date (which indicate date of event and used with either find_first_match_in_period or find_last_match_in_period) 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date ; Examples: Two variables are created. One called first_tested_for_covid is the first date that a patient has a covid test never mind the result. The second called first_positive_test_date is the first date that a patient has a positive test result. first_tested_for_covid=patients.with_test_result_in_sgss( pathogen=\"SARS-CoV-2\", test_result=\"any\", on_or_after=\"2020-02-01\", find_first_match_in_period=True, returning=\"date\", date_format=\"YYYY-MM-DD\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ), first_positive_test_date=patients.with_test_result_in_sgss( pathogen=\"SARS-CoV-2\", test_result=\"positive\", on_or_after=\"2020-02-01\", find_first_match_in_period=True, returning=\"date\", date_format=\"YYYY-MM-DD\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ), CPNS \ud83d\udd17 These variables are derived from the COVID-19 Patient Notification System ( CPNS ), which collects info on all in-hospital covid-related deaths. For more information, see the CPNS data section . with_death_recorded_in_cpns ( on_or_before = None , on_or_after = None , between = None , returning = 'binary_flag' , date_format = None , include_month = False , include_day = False , return_expectations = None ) \ud83d\udd17 Identify patients who with death registered in CPNS dataset Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a string indicating what type of value should be returned. The options are: date_of_death: Date of death binary_flag: If they died or not 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date_of_death Examples: A variable called died_date_cpns is created that returns the date of death for any patients have died in the CPNS dataset. died_date_cpns=patients.with_death_recorded_in_cpns( on_or_after=\"2020-02-01\", returning=\"date_of_death\", include_month=True, include_day=True, return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ), ONS deaths \ud83d\udd17 These variables are derived from the Death Registry data provided by the Office for National Statistics. For more information, see the ONS deaths section . died_from_any_cause ( on_or_before = None , on_or_after = None , between = None , returning = 'binary_flag' , date_format = None , include_month = False , include_day = False , return_expectations = None ) \ud83d\udd17 Identify patients who with ONS-registered deaths Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a string indicating what type of value should be returned. The options are: date_of_death: Date of death binary_flag: If they died or not 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date_of_death Examples: A variable called died_any is created that returns the date of death for any patients that have died in the time period. died_any=patients.died_from_any_cause( on_or_after=\"2020-02-01\", returning=\"date_of_death\", date_format=\"YYYY-MM-DD\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ) with_these_codes_on_death_certificate ( codelist , on_or_before = None , on_or_after = None , between = None , match_only_underlying_cause = False , returning = 'binary_flag' , date_format = None , include_month = False , include_day = False , return_expectations = None ) \ud83d\udd17 Identify patients with ONS-registered death, where cause of death matches the supplied icd10 codelist Parameters: Name Description Default codelist a codelist for requested value required on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results between the two dates provided. The default value is None . None match_only_underlying_cause boolean for indicating if filters results to only specified cause of death. False returning a string indicating what type of value should be returned. The options are: date_of_death: Date of death binary_flag: If they died or not underlying_cause_of_death: The icd10 code corresponding to the underlying cause of death 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag or underlying_cause_of_death ; list of strings with a date format returned if returning argument is set to date_of_death Examples: A variable called died_ons_covid_flag_any is created that returns the date of death for any patients that have covid on their death certificate even if that is the not the underlying cause of death. died_ons_covid_flag_any=patients.with_these_codes_on_death_certificate( covid_codelist, on_or_after=\"2020-02-01\", match_only_underlying_cause=False, return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ) High Cost Drugs \ud83d\udd17 (Documentation on the source of this data will be forthcoming later.) with_high_cost_drugs ( drug_name_matches = None , on_or_before = None , on_or_after = None , between = None , returning = 'binary_flag' , date_format = None , find_first_match_in_period = None , find_last_match_in_period = None , return_expectations = None ) \ud83d\udd17 Returns data from the High Cost Drugs Dataset More details available in this notebook: https://github.com/opensafely/highcostdrugs-research/blob/master/analysis/High%20Cost%20Drugs%20Dataset.ipynb Parameters: Name Description Default drug_name_matches a drug name as a string, or a list of such names, or a codelist containing such names. Results will be filtered to just rows matching any of the supplied names exactly. Note these are not standardised names, they are just the names however they come to us in the original data. None returning a string indicating what type of value should be returned. Options are: binary_flag: if the patient received any matching drugs date: date drug received 'binary_flag' on_or_before as described elsewhere None on_or_after as described elsewhere None between as described elsewhere None find_first_match_in_period as described elsewhere None find_last_match_in_period as described elsewhere None date_format only \"YYYY\" and \"YYYY-MM\" supported here as day level data not available None return_expectations as described elsewhere None Examples: The first month in which each patient received \"ACME Drug\" after March 2019: covid_admission_date=patients.with_high_cost_drugs( drug_name_matches=\"ACME Drug\", on_or_after=\"2019-03-01\", find_first_match_in_period=True, returning=\"date\", date_format=\"YYYY-MM\", return_expectations={\"date\": {\"earliest\": \"2019-03-01\"}}, ) Utility functions \ud83d\udd17 These variables create new variable from existing variables. They do not extract any data directly. random_sample ( percent = None , return_expectations = None ) \ud83d\udd17 Flags a random sample of approximately percent patients. Parameters: Name Description Default percent an integer between 1 and 100 for the percent of patients to include within the random sample None return_expectations a dict containing an expectations definition defining at least an incidence None Returns: Type Description list of integers of 1 or 0 Examples: This creates a variable example , flagging approximately 10% of the population with the value 1 : example=patients.random_sample(percent=10, expectations={'incidence': 0.1}) categorised_as ( category_definitions , return_expectations = None , ** extra_columns ) \ud83d\udd17 Patients who had had 1 or more code from 1 or more codelists are categorised into groups according to a prescribed algorithm. Parameters: Name Description Default category_definitions a dict that defines the algorithm and the associated category The keys of the dict are strings representing categories from a defined by other arguments such as with_these_clinical_events . The values are expressions of logic using statements and AND/OR statements. A default argument should be provided if a particular patient cannot be categorised to the algorithm. required return_expectations a dict that defined the ratios of each category. The keys are the category values as strings and the values are ratios as floats. The ratios should add up to 1. None Retyrns list: of strings which each letter representing a category as defined by the algorithm Examples: This creates a variable of asthma status based on codes for asthma and categorising for recent steroid use. current_asthma=patients.categorised_as( { \"1\": \"DEFAULT\", \"2\": \"recent_asthma_code AND prednisolone_last_year = 0\" \"3\": \"recent_asthma_code AND prednisolone_last_year > 0\" }, recent_asthma_code=patients.with_these_clinical_events( asthma_codes, between=[\"2017-02-01\", \"2020-01-31\"], ), prednisolone_last_year=patients.with_these_medications( pred_codes, between=[\"2019-02-01\", \"2020-01-31\"], returning=\"number_of_matches_in_period\", ), return_expectations={ \"category\":{\"ratios\": {\"0\": 0.8, \"1\": 0.1, \"2\": 0.1}} }, ) satisfying ( expression , return_expectations = None , ** extra_columns ) \ud83d\udd17 Patients who meet the criteria for one or more expressions. Used as a way of combining groups or making subgroups based on certain characteristics. Parameters: Name Description Default expression a string in that links together 2 or more expressions into one statement. key variables for this expression can be defined under this statement or anywhere in study definition. required return_expectations a dictionary defining the rate of expected value within the population in question None Returns: Type Description list of integers, either 1 or 0 Examples: This creates a study population where patients included have asthma and not copd: population=patients.satisfying( \"\"\" has_asthma AND NOT has_copd \"\"\", has_asthma=patients.with_these_clinical_events( asthma_codes, between=[\"2017-02-28\", \"2020-02-29\"], has_copd=patients.with_these_clinical_events( copd_codes, between=[\"2017-02-28\", \"2020-02-29\"], ), ) date_of ( source , date_format = None , include_month = False , include_day = False , return_expectations = None ) \ud83d\udd17 minimum_of ( * column_names , ** extra_columns ) \ud83d\udd17 Return the minimum value over the supplied columns e.g min_value=patients.minimum_of(\"some_column\", \"another_column\") Note: this ignores \"empty values\" (i.e. the values used if there is no data for a particular column, such as 0.0 for numeric values or the empty string for dates). This ensures that the minimum of a column with a defined value and one with a missing value is equal to the defined value. Additional columns can be defined within the function call which will be used in computing the minimum but won't themselves appear in the output: min_value=patients.minimum_of( \"some_column\", another_colum=patients.with_these_medications(...) ) maximum_of ( * column_names , ** extra_columns ) \ud83d\udd17 Return the maximum value over the supplied columns e.g max_value=patients.maximum_of(\"some_column\", \"another_column\") Additional columns can be defined within the function call which will be used in computing the maximum but won't themselves appear in the output: max_value=patients.maximum_of( \"some_column\", another_colum=patients.with_these_medications(...) )","title":"Study definition variable reference"},{"location":"study-def-variables/#primary-care-record","text":"These variables are derived from data held in the patients' primary care records.","title":"Primary Care Record"},{"location":"study-def-variables/#cohortextractor.patients.registered_as_of","text":"All patients registered on the given date. Note this function passes arguments to registered_with_one_practice_between() Parameters: Name Description Default reference_date date of interest as a string with the format YYYY-MM-DD . Filters results to patients registered at a practice on the given date. required return_expectations a dictionary containing an expectation definition defining an incidence between 0 and 1 . None Returns: Type Description list of integers of 1 or 0 . Examples: This creates a variable \"registered\" with patient returning an integer of 1 if patient registered at date. Patients who are not registered return an integer of 0 : registered=patients.registered_as_of( \"2020-03-01\", return_expectations={\"incidence\": 0.98} )","title":"registered_as_of()"},{"location":"study-def-variables/#cohortextractor.patients.registered_with_one_practice_between","text":"All patients registered with the same practice through the given period Parameters: Name Description Default start_date start date of interest of period as a string with the format YYYY-MM-DD . Together with end date, this filters results to patients registered at a practice between two dates required end_date end date of interest of period as a string with the format YYYY-MM-DD . Together with start date, this filters results to patients registered at a practice between two dates required return_expectations a dictionary containing an expectation definition defining an incidence between 0 and 1 . None Returns: Type Description list of integers of 1 or 0 . Examples: This creates a variable registered_one with patient returning an integer of 1 if patient registered at one practice between two dates. Patients who are not registered return an integer of 0 . registered_one=patients.registered_with_one_practice_between( start_date=\"2020-03-01\", end_date=\"2020-06-01\", return_expectations={\"incidence\": 0.90} )","title":"registered_with_one_practice_between()"},{"location":"study-def-variables/#cohortextractor.patients.date_deregistered_from_all_supported_practices","text":"Returns the date (if any) on which the patient de-registered from all practices for which OpenSAFELY has data. Events which occur in primary care after this date will not be recorded in the platform (though there may be data from other sources e.g. SGSS, CPNS). Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of strings with a date format returned if patient had deregistered, otherwise empty Examples: A variable called dereg_date is created with returns a date of de-registration if patient has deregistered from a practice within the dataset within the specified time period. dereg_date=patients.date_deregistered_from_all_supported_practices( on_or_after=\"2020-03-01\", date_format=\"YYYY-MM\", return_expectations={ {\"date\": {\"earliest\": \"2020-03-01\"}, \"incidence\": 0.05 } )","title":"date_deregistered_from_all_supported_practices()"},{"location":"study-def-variables/#cohortextractor.patients.with_complete_history_between","text":"All patients for which we have a full set of records between the given dates Parameters: Name Description Default start_date start date of interest of period as a string with the format YYYY-MM-DD . Together with end date, this filters results to patients registered at a practice between two dates who have a complete history. required end_date end date of interest of period as a string with the format YYYY-MM-DD . Together with start date, this filters results to patients registered at a practice between two dates who have a complete history. required return_expectations a dictionary containing an expectation definition defining an incidence between 0 and 1 . None Returns: Type Description list of integers of 1 or 0 Examples: This creates a variable has_consultation_history with patient returning an integer of 1 if patient registered at one practice between two dates and has a completed record. Patients who are not registered with a complete record return an integer of 0 . has_consultation_history=patients.with_complete_gp_consultation_history_between( start_date=\"2019-02-01\", end_date=\"2020-01-31\", return_expectations={\"incidence\": 0.9}, )","title":"with_complete_history_between()"},{"location":"study-def-variables/#cohortextractor.patients.with_complete_gp_consultation_history_between","text":"The concept of a \"consultation\" in EHR systems does not map exactly to the GP-patient interaction we're interested in (see above) so there is some processing required on the part of the EHR vendor to produce the consultation record we need. This does not happen automatically as part of the GP2GP transfer, and therefore this query can be used to find just those patients for which the full history is available. This means finding patients who have been continuously registered with a single TPP-using practice throughout a time period. Parameters: Name Description Default start_date start date of interest as a string with the format YYYY-MM-DD required end_date end date of interest as a string with the format YYYY-MM-DD required return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None","title":"with_complete_gp_consultation_history_between()"},{"location":"study-def-variables/#cohortextractor.patients.registered_practice_as_of","text":"Return patients' practice address characteristics such as STP or MSOA Parameters: Name Description Default date date of interest as a string with the format YYYY-MM-DD . Filters results to the given date. required returning a str defining the type of data to be returned. options include msoa , nuts1_region_name, and stp_code . The default value is None . None return_expectations a dict defining the rate and the categories returned with ratios None Returns: Type Description list of strings Exceptions: Type Description ValueError if unsupported returning argument is provided Examples: This creates a variable called region based on practice address of the patient: region=patients.registered_practice_as_of( \"2020-02-01\", returning=\"nuts1_region_name\", return_expectations={ \"rate\": \"universal\", \"category\": { \"ratios\": { \"North East\": 0.1, \"North West\": 0.1, \"Yorkshire and the Humber\": 0.1, \"East Midlands\": 0.1, \"West Midlands\": 0.1, \"East of England\": 0.1, \"London\": 0.2, \"South East\": 0.2, }, }, }, )","title":"registered_practice_as_of()"},{"location":"study-def-variables/#cohortextractor.patients.address_as_of","text":"Return patients' address characteristics such as IMD as of a particular date Parameters: Name Description Default date date of interest as a string with the format YYYY-MM-DD . Filters results to the given date. required returning a str defining the type of data to be returned. options include index_of_multiple_deprivation rural_urban_classification , and msoa . The default value is None . None round_to_nearest an integer that represents how index_of_multiple_deprivation value are rounded. Only use when returning is index_of_multiple_deprivation None return_expectations a dict defining the rate and the categories returned with ratios None Returns: Type Description list of integers for rural_urban_classification and index_of_multiple_deprivation , strings for msoa Exceptions: Type Description ValueError if unsupported returning argument is provided Examples: This creates a variable called imd based on patient address. imd=patients.address_as_of( \"2020-02-29\", returning=\"index_of_multiple_deprivation\", round_to_nearest=100, return_expectations={ \"rate\": \"universal\", \"category\": {\"ratios\": {\"100\": 0.1, \"200\": 0.2, \"300\": 0.7}}, }, )","title":"address_as_of()"},{"location":"study-def-variables/#cohortextractor.patients.with_gp_consultations","text":"These are GP-patient interactions, either in person or via phone/video call. The concept of a \"consultation\" in EHR systems is generally broader and might include things like updating a phone number with the receptionist. Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None find_first_match_in_period a boolean that indicates if the data returned is first event if there are multiple matches within the time period None find_last_match_in_period a boolean that indicates if the data returned is last event if there are multiple matches within the time period None returning a string indicating what type of value should be returned. The options are limited to binary_flag (which indicates if they have had the an event or not), date (which indicate date of event and used with either find_first_match_in_period or find_last_match_in_period), or number_of_matches_in_period (which counts the events in the period) 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date ; a list of integers if returning argument is set to number_of_matches_in_period Examples: A variable called gp_count is created that counts number of GP consultation between two dates in 2019. gp_count=patients.with_gp_consultations( between=[\"2019-01-01\", \"2020-12-31\"], returning=\"number_of_matches_in_period\", return_expectations={ \"int\": {\"distribution\": \"normal\", \"mean\": 6, \"stddev\": 3}, \"incidence\": 0.6, }, )","title":"with_gp_consultations()"},{"location":"study-def-variables/#cohortextractor.patients.sex","text":"Returns the sex of the patient. Parameters: Name Description Default return_expectations a dict containing an expectation definition defining a rate and a ratio for sexes None Returns: Type Description list \"M\" male, \"F\" female, \"I\" intersex, or \"U\" unknown. Examples: This creates a variable 'sex' with all patients returning a sex of either \"M\", \"F\" or \"\" sex=patients.sex( return_expectations={ \"rate\": \"universal\", \"category\": {\"ratios\": {\"M\": 0.49, \"F\": 0.51}}, } )","title":"sex()"},{"location":"study-def-variables/#cohortextractor.patients.age_as_of","text":"Returns age of patient of at a particular date. Note can be negative if born after reference_date . Parameters: Name Description Default reference_date date of interest as a string with the format YYYY-MM-DD required return_expectations a dict defining an expectation definition that includes at least a rate and a distribution. If distribution is defined as \"population_ages\" it returns likely distribution based on known UK age bands in 2018 (see file: \"uk_population_bands_2018.csv\") None Returns: Type Description list ages as integers Examples: This creates a variable \"age\" with all patient returning an age as an integer: age=patients.age_as_of( \"2020-02-01\", return_expectations={ \"rate\" : \"universal\", \"int\" : {\"distribution\" : \"population_ages\"} } )","title":"age_as_of()"},{"location":"study-def-variables/#cohortextractor.patients.date_of_birth","text":"Returns date of birth as a string with format \"YYYY-MM\" Parameters: Name Description Default date_format a string detailing the format of the dates for date of birth to be returned. It can be \"YYYY-MM\" or \"YYYY\" and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with month and year. None return_expectations a dictionary containing an expectation definition defining a rate and a distribution None Returns: Type Description list dates as strings with \"YYYY-MM\" format Exceptions: Type Description ValueError if Date of Birth is attempted to be returned with a YYYY-MM-DD format. Examples: This creates a variable dob with all patient returning a year and month as a string: dob=patients.date_of_birth( \"YYYY-MM\", return_expectations={ \"date\": {\"earliest\": \"1950-01-01\", \"latest\": \"today\"}, \"rate\": \"uniform\", } )","title":"date_of_birth()"},{"location":"study-def-variables/#cohortextractor.patients.most_recent_bmi","text":"Return patients' most recent BMI (in the defined period) either computed from weight and height measurements or, where they are not availble, from recorded BMI values. Measurements taken when a patient was below the minimum age are ignored. The height measurement can be taken before (but not after) the defined period as long as the patient was over the minimum age at the time. The date of the measurement can be obtained using date_of(\"<bmi-column-name>\") . If the BMI is computed from weight and height then we use the date of the weight measurement for this. Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to measurements on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to measurements on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to measurements between the two dates provided. The default value is None . None minimum_age_at_measurement Measurements taken before this age will not count towards BMI calculations. It is an integer and the default value is 16. 16 return_expectations a dictionary defining the incidence and distribution of expected BMI within the population in question. This is a 3-item key-value dictionary of \"date\" and \"float\". \"date\" is dictionary itself and should contain the earliest and latest dates needed in the dummy data. float is a dictionary of distribution , mean , and stddev . These values determine the shape of the dummy data returned, and the float means a float will be returned rather than an integer. incidence must have a value and this is what percentage of dummy patients have a BMI. It needs to be a number between 0 and 1. None include_measurement_date a boolean indicating if an extra column, named date_of_bmi , should be included in the output. The default value is False . False date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. Only used if include_measurement_date is True None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False Returns: Type Description float most recent BMI Examples: This creates a variable \"bmi\" returning a float of the most recent bmi calculated from recorded height and weight, or from a recorded bmi record. Patient who do not have this information available do not return a value: bmi=patients.most_recent_bmi( between=[\"2010-02-01\", \"2020-01-31\"], minimum_age_at_measurement=18, include_measurement_date=True, date_format=\"YYYY-MM\", return_expectations={ \"date\": {\"earliest\": \"2010-02-01\", \"latest\": \"2020-01-31\"}, \"float\": {\"distribution\": \"normal\", \"mean\": 28, \"stddev\": 8}, \"incidence\": 0.80, } )","title":"most_recent_bmi()"},{"location":"study-def-variables/#cohortextractor.patients.mean_recorded_value","text":"Return patients' mean recorded value of a numerical value as defined by a codelist on a particular day within the defined period. This is important as allows us to account for multiple measurements taken on one day. The date of the measurement can be included by flagging with date format options. Parameters: Name Description Default codelist a codelist for requested value required on_most_recent_day_of_measurement boolean flag for requesting measurements be on most recent date None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. This is a 3-item key-value dictionary of \"date\" and \"float\". \"date\" is dictionary itself and should contain the earliest and latest dates needed in the dummy data. float is a dictionary of distribution , mean , and stddev . These values determine the shape of the dummy data returned, and the float means a float will be returned rather than an integer. incidence must have a value and this is what percentage of dummy patients have a value. It needs to be a number between 0 and 1. None on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to measurements on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to measurements on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to measurements between the two dates provided. The default value is None . None include_measurement_date a boolean indicating if an extra column, named date_of_bmi , should be included in the output. The default value is False . False date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. Only used if include_measurement_date is True None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False Returns: Type Description float mean of value Examples: This creates a variable bp_sys returning a float of the most recent systolic blood pressure from the record within the time period. In the event of repeated measurements on the same day, these are averaged. Patient who do not have this information available do not return a value: bp_sys=patients.mean_recorded_value( systolic_blood_pressure_codes, on_most_recent_day_of_measurement=True, between=[\"2017-02-01\", \"2020-01-31\"], include_measurement_date=True, date_format=\"YYYY-MM\", return_expectations={ \"float\": {\"distribution\": \"normal\", \"mean\": 80, \"stddev\": 10}, \"date\": {\"earliest\": \"2019-02-01\", \"latest\": \"2020-01-31\"}, \"incidence\": 0.95, }, )","title":"mean_recorded_value()"},{"location":"study-def-variables/#cohortextractor.patients.with_these_medications","text":"Patients who have been prescribed at least one of this list of medications in the defined period Parameters: Name Description Default codelist a codelist for requested medication(s) required return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. If returning an integer (returning number_of_matches_in_period, number_of_episodes), this is a 2-item key-value dictionary of int and incidence . int is a dictionary of distribution , mean , and stddev . These values determine the shape of the dummy data returned, and the int means a int will be returned rather than a float. incidence must have a value and this is what percentage of dummy patients have a value. It needs to be a number between 0 and 1. If returning binary_flag this is a 1-item dictionary of incidence as described above. If returning either first_date_in_period or last_date_in_period , this is a 2-item dictionary of date and incidence . date is a dict of earliest and/or latest date possible. None on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a str defining the type of data to be returned. Options include binary_flag , date , number_of_matches_in_period , number_of_episodes , code , category . The default value is binary_flag . 'binary_flag' find_first_match_in_period a boolean indicating if any returned date, code, category, or numeric value should be based on the first match in the period. None find_last_match_in_period a boolean indicating if any returned date, code, category, or numeric value should be based on the last match in the period. None include_date_of_match a boolean indicating if an extra column should be included in the output. The default value is False . False date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. Only used if include_date_of_match is True None ignore_days_where_these_clinical_codes_occur a codelist that contains codes for medications to be ignored. if a medication is found on this day, the date is not matched even it matches a code in the main codelist None episode_defined_as a string expression indicating how an episode should be defined None return_binary_flag a bool indicatin if a binary flag should be returned (deprecated: use date_format instead) None return_number_of_matches_in_period a boolean indicating if the number of matches in a period should be returned (deprecated: use date_format instead) False return_first_date_in_period a boolean indicating if the first matches in a period should be returned (deprecated: use date_format instead) False return_last_date_in_period a boolean indicating if the last matches in a period should be returned (deprecated: use date_format instead) False include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag , number_of_episodes or number_of_matches_in_period ; list of strings with a date format returned if returning argument is set to first_date_in_period or last_date_in_period . Examples: This creates a variable exacerbation_count returning an int of the number of episodes of oral steroids being prescribed within the time period where a prescription is counted as part of the same episode if it falls within 28 days of a previous prescription. Days where oral steroids are prescribed on the same day as a COPD review are also ignored as may not represent true exacerbations. exacerbation_count=patients.with_these_medications( oral_steroid_med_codes, between=[\"2019-03-01\", \"2020-02-29\"], ignore_days_where_these_clinical_codes_occur=copd_reviews, returning=\"number_of_episodes\", episode_defined_as=\"series of events each <= 28 days apart\", return_expectations={ \"int\": {\"distribution\": \"normal\", \"mean\": 2, \"stddev\": 1}, \"incidence\": 0.2, }, )","title":"with_these_medications()"},{"location":"study-def-variables/#cohortextractor.patients.with_these_clinical_events","text":"Patients who have had at least one of these clinical events in the defined period Parameters: Name Description Default codelist a codelist for requested event(s) required return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. If returning an integer ( returning=number_of_matches_in_period or returning=number_of_episodes ), this is a 2-item key-value dictionary of int and incidence . int is a dictionary of distribution , mean , and stddev . These values determine the shape of the dummy data returned, and the int means a int will be returned rather than a float. incidence must have a value and this is what percentage of dummy patients have a value. It needs to be a number between 0 and 1. If returning binary_flag this is a 1-item dictionary of incidence as described above. If returning either first_date_in_period or last_date_in_period , this is a 2-item dictionary of date and incidence . date is a dict of earliest and/or latest date possible. None on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a str defining the type of data to be returned. Options include binary_flag , date , number_of_matches_in_period , number_of_episodes , code , category , or numeric_value . The default value is binary_flag . 'binary_flag' find_first_match_in_period a boolean indicating if any returned date, code, category, or numeric value should be based on the first match in the period. None find_last_match_in_period a boolean indicating if any returned date, code, category, or numeric value should be based on the last match in the period. None include_date_of_match a boolean indicating if an extra column should be included in the output. The default value is False . False date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. Only used if include_date_of_match is True None ignore_days_where_these_codes_occur a codelist that contains codes for events to be ignored. if a events is found on this day, the date is not matched even it matches a code in the main codelist None episode_defined_as a string expression indicating how an episode should be defined None return_binary_flag a boolean indicating if the number of matches in a period should be returned (deprecated: use date_format instead), None return_number_of_matches_in_period a boolean indicating if the number of matches in a period should be returned (deprecated: use date_format instead) False return_first_date_in_period a boolean indicating if the first matches in a period should be returned (deprecated: use date_format instead) False return_last_date_in_period a boolean indicating if the last matches in a period should be returned (deprecated: use date_format instead) False include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag , number_of_episodes or number_of_matches_in_period ; list of strings with a date format returned if returning argument is set to first_date_in_period or last_date_in_period . a list of strings with a category represented in an extra column in the codelist object category is returned. Examples: This creates a variable haem_cancer returning the first date of a diagnosis of haematology malignancy within the time period. haem_cancer=patients.with_these_clinical_events( haem_cancer_codes, between=[\"2015-03-01\", \"2020-02-29\"], returning=\"date\", find_first_match_in_period=True, return_expectations={\"date\": {earliest; \"2015-03-01\", \"latest\": \"2020-02-29\"}}, )","title":"with_these_clinical_events()"},{"location":"study-def-variables/#cohortextractor.patients.with_death_recorded_in_primary_care","text":"Identify patients with a date-of-death in their primary care record. There is generally a lag between the death being recorded in ONS data and appearing in the primary care record, but the date itself is usually reliable when it appears. By contrast, cause of death is often not accurate in the primary care record so we don't make it available to query here. Args: !!! on_or_before \"date of interest as a string with the format `YYYY-MM-DD`. Filters results\" on or before the given date. The default value is `None`. !!! on_or_after \"date of interest as a string with the format `YYYY-MM-DD`. Filters results\" on or after the given date. The default value is `None`. !!! between \"two dates of interest as a list with each date as a string with the format `YYYY-MM-DD`.\" Filters results to between the two dates provided. The default value is `None`. !!! returning \"a string indicating what type of value should be returned. The options are:\" date_of_death: Date of death binary_flag: If they died or not !!! date_format \"a string detailing the format of the dates to be returned. It can be `YYYY-MM-DD`,\" `YYYY-MM` or `YYYY` and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. !!! return_expectations \"a dictionary defining the incidence and distribution of expected value\" within the population in question. Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date_of_death Examples: A variable called died_date_gp is created that returns the date of death for any patients have died in the GP dataset. died_date_gp=patients.with_death_recorded_in_primary_care( on_or_after=\"2020-02-01\", returning=\"date_of_death\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ),","title":"with_death_recorded_in_primary_care()"},{"location":"study-def-variables/#cohortextractor.patients.care_home_status_as_of","text":"TPP have attempted to match patient addresses to care homes as stored in the CQC database. At its most simple this query returns a boolean indicating whether the patient's address (as of the supplied time) matched with a care home. It is also possible return a more complex categorisation based on attributes of the care homes in the CQC database, which can be freely downloaded here: https://www.cqc.org.uk/about-us/transparency/using-cqc-data At present the only imported fields are: LocationRequiresNursing LocationDoesNotRequireNursing But we can ask for more fields to be imported if needed. The categorised_as argument acts in effectively the same way as for the categorised_as function except that the only columns that can be referred to are those belonging to the care home table (i.e. the two nursing fields above) and the boolean IsPotentialCareHome Parameters: Name Description Default date date of interest as a string with the format YYYY-MM-DD . Filters results to the given date required categorised_as a logic expression that applies an algorithm to specific variables to create categories None return_expectations a dict defining the rate and the categories returned with ratios None Returns: Type Description list of strings which each letter representing a category as defined by the algorithm Examples: This creates a variable called care_home_type which contains a 2 letter string which represents a type of care home environment. care_home_type=patients.care_home_status_as_of( \"2020-02-01\", categorised_as={ \"PC\": \"\"\" IsPotentialCareHome AND LocationDoesNotRequireNursing='Y' AND LocationRequiresNursing='N' \"\"\", \"PN\": \"\"\" IsPotentialCareHome AND LocationDoesNotRequireNursing='N' AND LocationRequiresNursing='Y' \"\"\", \"PS\": \"IsPotentialCareHome\", \"U\": \"DEFAULT\", }, return_expectations={ \"rate\": \"universal\", \"category\": {\"ratios\": {\"PC\": 0.05, \"PN\": 0.05, \"PS\": 0.05, \"U\": 0.85,},}, }, ),","title":"care_home_status_as_of()"},{"location":"study-def-variables/#cohortextractor.patients.with_tpp_vaccination_record","text":"Identify patients with a vaccination record for a target disease within the tpp vaccination record Vaccinations can be recorded via a Vaccination Record or via prescription of a vaccine i.e a product code. Parameters: Name Description Default target_disease_matches the target disease as a string None product_name_matches the product name as a string None on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a string indicating what type of value should be returned. The options are limited to binary_flag (which indicates if they have had the vaccination or not) or a date of vaccination 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None find_first_match_in_period a boolean that indicates if the data returned is first indication of vaccination if there are multiple matches within the time period None find_last_match_in_period a boolean that indicates if the data returned is last indication of vaccination if there are multiple matches within the time period None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date Examples: A variable called flu_vaccine is created that returns the date of vaccination for any patients in the GP dataset between 2 dates. flu_vaccine=patients.with_tpp_vaccination_record( target_disease_matches=\"influenza\", between=[\"2019-09-01\", \"2020-04-01\"], returning=\"date\", date_format=\"YYYY-MM\", find_first_match_in_period=True, return_expectations={ date\": {\"earliest\": \"2019-09-01\", \"latest\": \"2020-03-29\"} } ),","title":"with_tpp_vaccination_record()"},{"location":"study-def-variables/#cohortextractor.patients.household_as_of","text":"Return information about the household to which the patient belonged as of the reference date. This is inferred from address data using an algorithm developed by TPP (to be documented soon) so the results are not 100% reliable but are apparently pretty good. !!! args reference_date: date of interest as a string with the format `YYYY-MM-DD`. Filters results to a particular set date !!! returning \"a string indicating what type of value should be returned. The options for `returning` are:\" !!! pseudo_id \"An integer identifier for the household which has no meaning\" other than to identify individual members of the same household (0 if no household information available) !!! household_size \"the number of individuals in the household (0 if no\" household information available) !!! is_prison \"Boolean indicating whether household is a prison. See\" https://github.com/opensafely/cohort-extractor/issues/271#issuecomment-679069981 for details of how this is determined. !!! has_members_in_other_ehr_systems \"Boolean indicating whether some household\" members are registered with GPs using a different EHR system, meaning that our coverage of the household is incomplete. !!! percentage_of_members_with_data_in_this_backend \"Integer giving the (estimated)\" percentage of household members where we have EHR data available in this backend (i.e. not in other systems as above) msoa: Returns the MSOA (Middle Super Output Area) in which the household is situated return_expectations: a dictionary defining the incidence and distribution of expected value within the population in question. Returns: Type Description list of integers if returning argument is set to pseudo_id , household_size or percentage_of_members_with_data_in_this_backend . a list of 1 or 0 is returning is set to is_prison or has_members_in_other_ehr_systems Examples: household_id=patients.household_as_of( \"2020-02-01\", returning=\"pseudo_id\" ) household_size=patients.household_as_of( \"2020-02-01\", returning=\"household_size\" ),","title":"household_as_of()"},{"location":"study-def-variables/#apcs","text":"These variables are derived from Admitted Patient Care Statistics (APCS) data on in-patient hospital admissions across England. For more information, see the APCS data section .","title":"APCS"},{"location":"study-def-variables/#cohortextractor.patients.admitted_to_hospital","text":"Return information about admission to hospital. See https://github.com/opensafely/cohort-extractor/issues/186 for in-depth discussion and background. Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a string indicating what type of value should be returned. Options for returning are: binary_flag: if they were admitted at all date_admitted: date patient admitted to hospital date_discharged: date patient discharged from hospital number_of_matches_in_period: number of times patient was admitted in time period specified primary_diagnosis: primary diagnosis code for admission 'binary_flag' find_first_match_in_period a boolean that indicates if the data returned is first event if there are multiple matches within the time period None find_last_match_in_period a boolean that indicates if the data returned is last event if there are multiple matches within the time period None date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None with_these_diagnoses icd10 codes to match against any diagnosis None with_these_primary_diagnoses icd10 codes to match against the primary diagnosis None with_these_procedures opcs4 codes to match against the procedure None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date_admitted or date_discharged ; of integers if returning argument is set to number_of_matches_in_period . list of strings with alphanumerical code format for ICD10 code if returning argument is set to primary_diagnosis Examples: The day of each patient's first hospital admission for Covid19: covid_admission_date=patients.admitted_to_hospital( returning= \"date_admitted\", with_these_diagnoses=covid_codelist, on_or_after=\"2020-02-01\", find_first_match_in_period=True, date_format=\"YYYY-MM-DD\", return_expectations={\"date\": {\"earliest\": \"2020-03-01\"}}, )","title":"admitted_to_hospital()"},{"location":"study-def-variables/#ecds","text":"These variables are derived from Emergency Care Data Set ( ECDS ) data on emergency department attendances across England. For more information, see the ECDS data section .","title":"ECDS"},{"location":"study-def-variables/#cohortextractor.patients.attended_emergency_care","text":"Return information about attendance of A&E from the ECDS dataset. Please note that there is a limited number of diagnoses allowed within this dataset, and so will not match with the range of diagnoses allowed in other datasets such as the primary care record. Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a string indicating what type of value should be returned. Options for returning are: binary_flag: Whether patient attended A&E date_arrived: date patient arrived in A&E number_of_matches_in_period: number of times patient attended A&E discharge_destination: SNOMED CT code of discharge destination. This will be a member of refset 999003011000000105. 'binary_flag' find_first_match_in_period a boolean that indicates if the data returned is first event if there are multiple matches within the time period None find_last_match_in_period a boolean that indicates if the data returned is last event if there are multiple matches within the time period None date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None with_these_diagnoses a list of SNOMED CT codes None discharged_to a list of members of refset 999003011000000105. None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date_arrived ; of integers if returning argument is set to number_of_matches_in_period or discharge_destination (with SNOMED CT code as a numerical value) Examples: A variable called emergency_care is created with returns a date of first attendence in A&E if patient had attended emergency room during the time period. emergency_care=patients.attended_emergency_care( on_or_after=\"2020-01-01\", returning=\"date_arrived\", date_format=\"YYYY-MM-DD\", find_first_match_in_period=True, return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, )","title":"attended_emergency_care()"},{"location":"study-def-variables/#icnarc","text":"These variables are derived from the Intensive Care National Audit and Research Centre Case-Mix Programme ( ICNARC -CMP), which collects information on ICU admissions across England. For more information, see the ICNARC data section .","title":"ICNARC"},{"location":"study-def-variables/#cohortextractor.patients.admitted_to_icu","text":"Return information about being admitted to ICU. Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . None find_first_match_in_period a boolean that indicates if the data returned is first admission to icu if there are multiple admissions within the time period None find_last_match_in_period a boolean that indicates if the data returned is last admission to icu if there are multiple admissions within the time period None returning binary_flag: Whether patient attended A&E date_admitted: Date patient arrived in A&E had_respiratory_support: Whether patient received any form of respiratory support had_basic_respiratory_support: Whether patient received \"basic\" respiratory support had_advanced_respiratory_support: Whether patient received \"advanced\" respiratory support (Note that the terms \"basic\" and \"advanced\" are derived from the underlying ICNARC data.) 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. Only used if returning is binary_flag None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. This is a 2-item key-value dictionary of date and rate . None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag , had_respiratory_support , had_basic_respiratory_support or had_advanced_respiratory_support ; list of strings with a date format returned if returning argument is set to date_admitted Examples: This returns two variables \u2014 one called icu_date_admitted and another had_resp_support : has_resp_support=patients.admitted_to_icu( on_or_after=\"2020-02-01\", find_first_match_in_period=True, returning=\"had_respiratory_support\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ), icu_date_admitted=patients.admitted_to_icu( on_or_after=\"2020-02-01\", find_first_match_in_period=True, returning=\"date_admitted\", date_format=\"YYYY-MM-DD\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ),","title":"admitted_to_icu()"},{"location":"study-def-variables/#sgss","text":"These variables are derived from Second Generation Surveillance System ( SGSS ) data which captures routine laboratory surveillance data on infectious diseases across England. For more information, see the SGSS data section .","title":"SGSS"},{"location":"study-def-variables/#cohortextractor.patients.with_test_result_in_sgss","text":"Finds lab test results recorded in SGSS (Second Generation Surveillance System). Please note for the dates this is used in the database as the date the specimen was taken, rather than the date of the lab result. There's an important caveat here: where a patient has multiple positive tests, SGSS groups these into \"episodes\" (referred to as \"Organism-Patient-Illness-Episodes\"). Each pathogen has a maximum episode duration (usually 2 weeks) and unless positive tests are separated by longer than this period they are assumed to be the same episode of illness. The specimen date recorded is the earliest positive specimen within the episode. For SARS-CoV-2 the episode length has been set to infinity, meaning that once a patient has tested positive every positive test will be part of the same episode and record the same specimen date. This means that using find_last_match_in_period is pointless when querying for positive results as only one date will ever be recorded and it will be the earliest. Our natural assumption, though it doesn't seem to be explicity stated in the documentation, is that every negative result is treated as unique. For more detail on SGSS in general see: https://assets.publishing.service.gov.uk/government/uploads/system/uploads/attachment_data/file/739854/PHE_Laboratory_Reporting_Guidelines.pdf Information about the SARS-CoV-2 episode length was via email from someone at the National Infection Service: The COVID-19 episode length in SGSS was set to indefinite, so all COVID-19 records from a single patient will be classified as one episode. This may change, but is set as it is due to limited information around re-infection and virus clearance. Parameters: Name Description Default pathogen pathogen we are interested in. Only SARS-CoV-2 results are included in our data extract so this will throw an error if the specified pathogen is anything other than \"SARS-CoV-2\". None test_result must be one of \"positive\", \"negative\" or \"any\" 'any' on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None find_first_match_in_period a boolean that indicates if the data returned is first event if there are multiple matches within the time period None find_last_match_in_period a boolean that indicates if the data returned is last event if there are multiple matches within the time period None returning a string indicating what type of value should be returned. The options are limited to binary_flag (which indicates if they have had the an event or not) and date (which indicate date of event and used with either find_first_match_in_period or find_last_match_in_period) 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date ; Examples: Two variables are created. One called first_tested_for_covid is the first date that a patient has a covid test never mind the result. The second called first_positive_test_date is the first date that a patient has a positive test result. first_tested_for_covid=patients.with_test_result_in_sgss( pathogen=\"SARS-CoV-2\", test_result=\"any\", on_or_after=\"2020-02-01\", find_first_match_in_period=True, returning=\"date\", date_format=\"YYYY-MM-DD\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ), first_positive_test_date=patients.with_test_result_in_sgss( pathogen=\"SARS-CoV-2\", test_result=\"positive\", on_or_after=\"2020-02-01\", find_first_match_in_period=True, returning=\"date\", date_format=\"YYYY-MM-DD\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ),","title":"with_test_result_in_sgss()"},{"location":"study-def-variables/#cpns","text":"These variables are derived from the COVID-19 Patient Notification System ( CPNS ), which collects info on all in-hospital covid-related deaths. For more information, see the CPNS data section .","title":"CPNS"},{"location":"study-def-variables/#cohortextractor.patients.with_death_recorded_in_cpns","text":"Identify patients who with death registered in CPNS dataset Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a string indicating what type of value should be returned. The options are: date_of_death: Date of death binary_flag: If they died or not 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date_of_death Examples: A variable called died_date_cpns is created that returns the date of death for any patients have died in the CPNS dataset. died_date_cpns=patients.with_death_recorded_in_cpns( on_or_after=\"2020-02-01\", returning=\"date_of_death\", include_month=True, include_day=True, return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ),","title":"with_death_recorded_in_cpns()"},{"location":"study-def-variables/#ons-deaths","text":"These variables are derived from the Death Registry data provided by the Office for National Statistics. For more information, see the ONS deaths section .","title":"ONS deaths"},{"location":"study-def-variables/#cohortextractor.patients.died_from_any_cause","text":"Identify patients who with ONS-registered deaths Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a string indicating what type of value should be returned. The options are: date_of_death: Date of death binary_flag: If they died or not 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date_of_death Examples: A variable called died_any is created that returns the date of death for any patients that have died in the time period. died_any=patients.died_from_any_cause( on_or_after=\"2020-02-01\", returning=\"date_of_death\", date_format=\"YYYY-MM-DD\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, )","title":"died_from_any_cause()"},{"location":"study-def-variables/#cohortextractor.patients.with_these_codes_on_death_certificate","text":"Identify patients with ONS-registered death, where cause of death matches the supplied icd10 codelist Parameters: Name Description Default codelist a codelist for requested value required on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results between the two dates provided. The default value is None . None match_only_underlying_cause boolean for indicating if filters results to only specified cause of death. False returning a string indicating what type of value should be returned. The options are: date_of_death: Date of death binary_flag: If they died or not underlying_cause_of_death: The icd10 code corresponding to the underlying cause of death 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag or underlying_cause_of_death ; list of strings with a date format returned if returning argument is set to date_of_death Examples: A variable called died_ons_covid_flag_any is created that returns the date of death for any patients that have covid on their death certificate even if that is the not the underlying cause of death. died_ons_covid_flag_any=patients.with_these_codes_on_death_certificate( covid_codelist, on_or_after=\"2020-02-01\", match_only_underlying_cause=False, return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, )","title":"with_these_codes_on_death_certificate()"},{"location":"study-def-variables/#high-cost-drugs","text":"(Documentation on the source of this data will be forthcoming later.)","title":"High Cost Drugs"},{"location":"study-def-variables/#cohortextractor.patients.with_high_cost_drugs","text":"Returns data from the High Cost Drugs Dataset More details available in this notebook: https://github.com/opensafely/highcostdrugs-research/blob/master/analysis/High%20Cost%20Drugs%20Dataset.ipynb Parameters: Name Description Default drug_name_matches a drug name as a string, or a list of such names, or a codelist containing such names. Results will be filtered to just rows matching any of the supplied names exactly. Note these are not standardised names, they are just the names however they come to us in the original data. None returning a string indicating what type of value should be returned. Options are: binary_flag: if the patient received any matching drugs date: date drug received 'binary_flag' on_or_before as described elsewhere None on_or_after as described elsewhere None between as described elsewhere None find_first_match_in_period as described elsewhere None find_last_match_in_period as described elsewhere None date_format only \"YYYY\" and \"YYYY-MM\" supported here as day level data not available None return_expectations as described elsewhere None Examples: The first month in which each patient received \"ACME Drug\" after March 2019: covid_admission_date=patients.with_high_cost_drugs( drug_name_matches=\"ACME Drug\", on_or_after=\"2019-03-01\", find_first_match_in_period=True, returning=\"date\", date_format=\"YYYY-MM\", return_expectations={\"date\": {\"earliest\": \"2019-03-01\"}}, )","title":"with_high_cost_drugs()"},{"location":"study-def-variables/#utility-functions","text":"These variables create new variable from existing variables. They do not extract any data directly.","title":"Utility functions"},{"location":"study-def-variables/#cohortextractor.patients.random_sample","text":"Flags a random sample of approximately percent patients. Parameters: Name Description Default percent an integer between 1 and 100 for the percent of patients to include within the random sample None return_expectations a dict containing an expectations definition defining at least an incidence None Returns: Type Description list of integers of 1 or 0 Examples: This creates a variable example , flagging approximately 10% of the population with the value 1 : example=patients.random_sample(percent=10, expectations={'incidence': 0.1})","title":"random_sample()"},{"location":"study-def-variables/#cohortextractor.patients.categorised_as","text":"Patients who had had 1 or more code from 1 or more codelists are categorised into groups according to a prescribed algorithm. Parameters: Name Description Default category_definitions a dict that defines the algorithm and the associated category The keys of the dict are strings representing categories from a defined by other arguments such as with_these_clinical_events . The values are expressions of logic using statements and AND/OR statements. A default argument should be provided if a particular patient cannot be categorised to the algorithm. required return_expectations a dict that defined the ratios of each category. The keys are the category values as strings and the values are ratios as floats. The ratios should add up to 1. None Retyrns list: of strings which each letter representing a category as defined by the algorithm Examples: This creates a variable of asthma status based on codes for asthma and categorising for recent steroid use. current_asthma=patients.categorised_as( { \"1\": \"DEFAULT\", \"2\": \"recent_asthma_code AND prednisolone_last_year = 0\" \"3\": \"recent_asthma_code AND prednisolone_last_year > 0\" }, recent_asthma_code=patients.with_these_clinical_events( asthma_codes, between=[\"2017-02-01\", \"2020-01-31\"], ), prednisolone_last_year=patients.with_these_medications( pred_codes, between=[\"2019-02-01\", \"2020-01-31\"], returning=\"number_of_matches_in_period\", ), return_expectations={ \"category\":{\"ratios\": {\"0\": 0.8, \"1\": 0.1, \"2\": 0.1}} }, )","title":"categorised_as()"},{"location":"study-def-variables/#cohortextractor.patients.satisfying","text":"Patients who meet the criteria for one or more expressions. Used as a way of combining groups or making subgroups based on certain characteristics. Parameters: Name Description Default expression a string in that links together 2 or more expressions into one statement. key variables for this expression can be defined under this statement or anywhere in study definition. required return_expectations a dictionary defining the rate of expected value within the population in question None Returns: Type Description list of integers, either 1 or 0 Examples: This creates a study population where patients included have asthma and not copd: population=patients.satisfying( \"\"\" has_asthma AND NOT has_copd \"\"\", has_asthma=patients.with_these_clinical_events( asthma_codes, between=[\"2017-02-28\", \"2020-02-29\"], has_copd=patients.with_these_clinical_events( copd_codes, between=[\"2017-02-28\", \"2020-02-29\"], ), )","title":"satisfying()"},{"location":"study-def-variables/#cohortextractor.patients.date_of","text":"","title":"date_of()"},{"location":"study-def-variables/#cohortextractor.patients.minimum_of","text":"Return the minimum value over the supplied columns e.g min_value=patients.minimum_of(\"some_column\", \"another_column\") Note: this ignores \"empty values\" (i.e. the values used if there is no data for a particular column, such as 0.0 for numeric values or the empty string for dates). This ensures that the minimum of a column with a defined value and one with a missing value is equal to the defined value. Additional columns can be defined within the function call which will be used in computing the minimum but won't themselves appear in the output: min_value=patients.minimum_of( \"some_column\", another_colum=patients.with_these_medications(...) )","title":"minimum_of()"},{"location":"study-def-variables/#cohortextractor.patients.maximum_of","text":"Return the maximum value over the supplied columns e.g max_value=patients.maximum_of(\"some_column\", \"another_column\") Additional columns can be defined within the function call which will be used in computing the maximum but won't themselves appear in the output: max_value=patients.maximum_of( \"some_column\", another_colum=patients.with_these_medications(...) )","title":"maximum_of()"},{"location":"study-def/","text":"What is a Study Definition? \ud83d\udd17 A study definition is a formal specification of the data that you want to extract from the OpenSAFELY database. This includes: the patient population (dataset rows) the variables (dataset columns) the expected distributions of these variables for use in dummy data It is written in the Python programming language, using an OpenSAFELY-specific format which is intended to be easily written, read, and reviewed by anyone with some epidemiological knowledge. Some knowledge of python is helpful! The following documentation should get you through most cases, but some will make little sense to a non-Python programmer. It is on our roadmap to replace the Python-based approach with a configuration-based approach which is more secure, and can be driven from a graphical user interface. The OpenSAFELY framework case use a single study definition to query different vendor EHR databases, and saves the results to the secure server in a CSV file of tabular data. A study definition also allows a researcher to define the shape of the values they expect to get back from the vendor data. This allows the framework to generate dummy data which the researcher can use to develop and test their analysis scripts, without ever having to touch real patient data. When you generate a study population from your study definition , the framework reads a study definition from the python script (usually analysis/study_definition.py ), and writes the output data frame in a tabular CSV file (usually output/input.csv ). In a production environment this file will contain real data; in a development environment this will be dummy data. Currently the framework supports one row per patient datasets. study_definition.py structure \ud83d\udd17 Importing code building blocks \ud83d\udd17 To create the study definition , we first need to import the functions and code to create this. You will need to put this codeblock at the top of your python file. from cohortextractor import ( StudyDefinition , patients , codelist_from_csv , codelist , filter_codes_by_category , combine_codelists ) This essentially says we want to import the some functions from the cohortextractor package which will be used throughout the script. A simple example \ud83d\udd17 The StudyDefinition() function (imported above) is used to define both the study population and the variables. study = StudyDefinition ( # define default dummy data behaviour default_expectations = { \"date\" : { \"earliest\" : \"1970-01-01\" , \"latest\" : \"today\" }, \"rate\" : \"uniform\" , \"incidence\" : 0.2 , }, # define the study index date index_date = \"2020-01-01\" # define the study population population = patients . all (), # define the study variables age = patients . age_as_of ( index_date ) # more variables ... ) default_expectations= is used to set default behaviour for the dummy data that is generated. In this case, we expect event dates to be between 1970-01-01 and today's date, uniformly distributed in that period, and to be recorded for 20% of patients (returning empty \"\" values otherwise). See Defining dummy data for more details. index_date= is used to set the index date against which all other dates can be defined. See Defining time periods for more details on how the index date is used. population= is where the population is defined. In this case, we want all patients available in the OpenSAFELY database and so we use the method all() to indicate this. See the study population section for more details on how to select a specific subset of patients in the OpenSAFELY database. The default_expectations , index_date , and population arguments are reserved names within StudyDefinition() . All other names are used to define the variables that will appear in the outputted dataset, using variable extractor functions of the form patients.function_name . age= is a simple example of an extractor function in use. The patients.age_as_of() function returns the age of each patient as of the date provided (in this case the index_date ). All other variables are defined similarly. To see the full list of currently available extractor functions, see Study definition variables reference . Codelists \ud83d\udd17 For more information about how to create and edit codelists on the OpenSAFELY Codelists website, see Codelists . Pulling Codelists into your Study Definition \ud83d\udd17 Many functions for defining variables take codelists as arguments. Codelists live as CSV files in the codelists/ directory, and are loaded into variables like this: chronic_cardiac_disease_codes = codelist_from_csv ( \"codelists/opensafely-chronic-cardiac-disease.csv\" , system = \"ctv3\" , column = \"CTV3ID\" ) You should put code that creates codelist variables before your StudyDefinition() , so it can refer to them, and users know where to look. You can do this in analysis/study_definition.py , but we recommend that you put all your codelist definitions into a file called codelists.py and importing it in at the top of your file: from codelists import * This keeps it cleaner and easier to read. Combining codelists \ud83d\udd17 Codelists can be combined where appropriate. This has the advantage of keeping codeslists separate for some studies but easily combining them for others. Codelists can be combined using the combine_codelist function from cohortextractor , for example: from cohortextractor import combine_codelists all_cardiac_disease_codes = combine_codelists ( chronic_cardiac_disease_codes , acute_cardiac_disease_codes ) Defining time periods \ud83d\udd17 Index Dates \ud83d\udd17 If you define an index_date on a study definition then everywhere that you might normally supply a date you can now supply a \"date expression\". Here is a simple example: study = StudyDefinition ( index_date = \"2015-06-01\" , population = patients . with_these_clinical_events ( copd_codes , between = [ \"first_day_of_year(index_date) - 2 years\" , \"last_day_of_year(index_date)\" , ], ), age = patients . age_as_of ( \"index_date\" ), ) This can make it easier to change the index date of a study by making sure it is only defined in once place. The simplest date expression is just index_date , which gets replaced by whatever the index date is set to. It's also possible to apply various functions to the index date. The available options (hopefully self-explanatory) are: \"first_day_of_month(index_date)\" \"last_day_of_month(index_date)\" \"first_day_of_year(index_date)\" \"last_day_of_year(index_date)\" Intervals of time can be added or subtracted from the index date (or from a function applied to the index date). The available units are year(s) , month(s) and day(s) . For example: \"index_date + 90 days\" \"first_day_of_month(index_date) + 9 months\" \"index_date - 1 year\" Note that if the index date is 29 February and you add or subtract some number of years which doesn't lead to a leap year, then an error will be thrown. An error will also be show if adding or subtracting months leads to a month with no equivalent day e.g. adding 1 month to 31 January to produce 31 February. Dynamic dates \ud83d\udd17 Dates used in variable definitions can also be taken from date variables defined elsewhere in the study definition , rather than using a common fixed value. For example, we may want to define a patient's age as at a thier first positive test result, rather than a fixed index date. In this case we first define positive test date as a variable in the study definition , then refer to this variable name in the age definition: study = StudyDefinition ( pos_test_date = patients . with_test_result_in_sgss ( pathogen = \"SARS-CoV-2\" , test_result = \"positive\" , find_first_match_in_period = True , returning = \"date\" , date_format = \"YYYY-MM-DD\" , age = patients . age_as_of ( \"pos_test_date\" ), ) Here, the patient-specific date pos_test_date is defined as the first SARS-CoV-2 positive test result in SGSS , which will differ for each patient. The age variable is now defined relative to this date, i.e. age is given at the time of the positive SARS-CoV-2 test. Note the need for the variable name to be passed as a string rather than unquoted. We can also use date expressions on these dates, for example \"pos_test_date - 1 year\" Wherever the inputted date is null, in this case when a patient doesn't have a positive test result, any variables that reference the date will take the null value for their variable type (0 for numeric variables; an empty string for character and date variables). Time periods \ud83d\udd17 Most variable extractor functions have arguments for specifying the date range over which you want to retrieve information. Most commonly this is on_or_before= , on_or_after= , or between= (see the variable reference for full documentation). You must use at most one. If no option is given then it will use all dates (including possibly future dates). As well as specifying dates explicitly with e.g., on_or_before=\"2019-12-31\" , you can use the date expressions discussed above. Defining and extracting variables \ud83d\udd17 All variables that you want to include in your dataset are declared within the StudyDefinition() function, using functions of the form patients.function_name() . To see the full documentation for all the variables that can be extracted with queries to the OpenSAFELY database, see Study Definition variable reference . Missing values and unmatched records \ud83d\udd17 If a query returns no matching record for a patient \u2014 for example if there are no blood pressure values recorded in a given period, or if there is no death date because the patient hasn't died, or if there is no household size available \u2014 then a default value will be returned. For strings and dates, the default value is the empty string \"\" . For booleans, integers, or floats, the default value is 0 . There is no universal null value outputted to input.csv because these may be handled inconsistently across different programs. It's possible that a record is matched, but the value is not valid. In this case, the value will be returned as-is. For example, a date set to \"9999-99-99\" or a blood pressure reading set to -1 . These will indicate missing / unknown / unrecorded / not applicable values in the source dataset. The meaning of these values will depend on the data source, and this should be documented in the dataset documentation . Variables that return value-date pairs \ud83d\udd17 Some functions will produce two variables: a value and the corresponding date. In this case, expectations for both the value and the date can be specified, for example as follows: sbp = patients . mean_recorded_value ( systolic_blood_pressure_codes , on_most_recent_day_of_measurement = True , include_measurement_date = True , on_or_after = index_date , date_format = \"YYYY-MM-DD\" , return_expectations = { \"incidence\" : 0.8 , \"float\" : { \"distribution\" : \"normal\" , \"mean\" : 110 , \"stddev\" : 20 }, \"date\" : { \"earliest\" : index_date , \"latest\" : \"today\" }, \"rate\" : \"uniform\" }, ) This says that we expect the returned systolic blood pressure values to be normally distributed and available for 80% of patients, at dates between the index_date and \"today\" 's date. The date of the most recent measurement is distributed uniformly between those dates. Defining dummy data \ud83d\udd17 Every variable in a study definition must have a return_expectations argument defined (with the exception of the population variable). This defines the general shape or distribution of the variables in the dummy data used for developing the code. It is currently relatively unsophisticated; each variable is generated independently of all others. This is sufficient for testing that it is possible to run your study from start to finish in most cases, but sometimes not. You can find (and contribute to!) discussions on improving the dummy data framework here Specifying default distributions \ud83d\udd17 All variables use a default defined at the top of the study definition , with the default_expectations argument, as follows: study = StudyDefinition ( # Configure the expectations framework default_expectations = { \"date\" : { \"earliest\" : \"1900-01-01\" , \"latest\" : \"today\" }, \"rate\" : \"exponential_increase\" , \"incidence\" : 0.5 }, ... In this case, we are saying that: * Events dates are expected to be distributed between 1900 and today, with exponentially-increasing frequenc, with events occurring for 50% of patients. * Values for binary variables are expected to be positive 50% of the time. * Values for categorical variables are expected to be present (i.e., non-missing) 50% of the time. * Values for numeric variables are expected to be present (i.e., non-missing) 50% of the time. Specifying variable-specific distributions \ud83d\udd17 If the defaults need to be overridden, then use the return_expectations argument within the variable extractor function, for example as follows: copd = patients . with_these_clinical_events ( copd_codes , returning = \"binary_flag\" , find_first_match_in_period = True , between = [ index_date , \"today\" ], return_expectations = { \"incidence\" : 0.2 }, ), This overrides the 50% default incidence for the binary variable copd to be 20% instead. All options \ud83d\udd17 The following options are currently available for dummy data: integers {\"int\" : {\"distribution\": \"normal\", \"mean\": 25, \"stddev\": 5}, \"incidence\" : 0.5} {\"int\" : {\"distribution\": \"population_ages\"}, \"incidence\" : 1} numeric {\"float\" : {\"distribution\": \"normal\", \"mean\": 25, \"stddev\": 5}, \"incidence\" : 0.75} binary {\"incidence\": 0.33} categorical {\"category\": {\"ratios\": {\"cat1\": 0.1, \"cat2\": 0.2, \"cat3\": 0.7}}, \"incidence\" : 1} date {\"date\": {\"earliest\": \"1900-01-01\", \"latest\": \"today\"}, \"rate\" : \"exponential_increase\"} {\"date\": {\"earliest\": \"1900-01-01\", \"latest\": \"today\"}, \"rate\" : \"uniform\"} Note that \"incidence\" is used either for the actual incidence of a binary variable ( returning=\"binary_flag\" ), or to indicate non-missingness for other variable types. \"rate\" is used for the distribution of date values (with either \"exponential_increase\" or \"uniform\" ), but can also be used as an alias for incidence=1 by specifying rate=\"universal\" for non-date values. population_ages samples from the distribution of ages in the UK taken from the Office for National Statistics . Defining study populations \ud83d\udd17 Most commonly, you will want to include only patients with certain characteristics, rather than every patient in the database. Using variables to define your population \ud83d\udd17 To define a study population with one particular characteristic, you need to define the characteristic within the study population. population = patients . with_these_clinical_events ( copd_codes , on_or_before = \"2017-03-01\" , ) Using time registered in one practice \ud83d\udd17 Researchers often want to exclude patients who have switched practice recently and hence may have an incomplete record of their conditions as it can take some time for their records to come from their previous practice. population = patients . registered_with_one_practice_between ( \"2019-03-01\" , \"2020-03-01\" ) Combining population criteria \ud83d\udd17 Population criteria may need to be combined. Here we have combined both COPD and registration details to find only patients who have COPD and have been registered at a practice for more than a year. population = patients . satisfying ( \"has_follow_up AND has_copd\" , has_copd = patients . with_these_clinical_events ( copd_codes , on_or_before = \"2017-03-01\" ), has_follow_up = patients . registered_with_one_practice_between ( \"2019-03-01\" , \"2020-03-01\" ), ) If a variable has been defined elsewhere in StudyDefinition() , then that variable can be used in the patients.satisfying() function without needing to be defined again. For example, study = StudyDefinition ( population = patients . satisfying ( \"\"\" has_follow_up AND (sex = \"M\" OR sex = \"F\") \"\"\" , has_follow_up = patients . registered_with_one_practice_between ( \"2019-03-01\" , \"2020-03-01\" ), ) sex = patients . sex ( \"incidence\" : 1 , returning_expectations = { \"category\" : { \"ratios\" : { \"M\" : 0.49 , \"F\" : 0.51 }}} ), ) Here sex is defined outside of patients.satisfying() but can still be used inside of it. In this case, it's being used to exclude patients without a \"valid\" sex category ( \"M\" or \"F\" ) from the study population. Dummy data versus real data \ud83d\udd17 The population= argument has no bearing at all on the dummy data. It is just used to select patients in the real data. If in the example above we had \"incidence\" : 0.95 , then 5% of patients in the dummy data would have missing sex values, but 0% of patients in the real data would have missing sex values because they have been excluded with population= . It's important therefore to match the dummy data with what you would expect to see conditional on the chosen patient population, rather than in the data as a whole. Multiple study definitions \ud83d\udd17 Naming \ud83d\udd17 A study_definition.py will produce a file called input.csv . If you only require one study population, we recommend you stick with this. Multiple study definition files can be specified using a suffix like: study_definition_copd.py study_definition_asthma.py And all the corresponding output files will have the same suffix e.g. input_copd.csv input_asthma.csv You should reflect this by creating two cohortextractor actions in the project.yaml , one for each study definition : version : \"3.0\" expectations : population_size : 1000 actions : generate_copd_cohort : run : cohortextractor:latest generate_cohort --study-definition study_definition_copd outputs : highly_sensitive : cohort : output/input_copd.csv generate_asthma_cohort : run : cohortextractor:latest generate_cohort --study-definition study_definition_asthma outputs : highly_sensitive : cohort : output/input_asthma.csv Sharing common study definition variables \ud83d\udd17 When using multiple study definitions, there's often a lot of common variables between them, with just the population and maybe a couple of other variables that differ. This means you have to separately specify the common variables in each definition, and it's easy to make an error, particularly when something needs changing. To avoid this, there is a way to share these common variables between study definitions: Make a file called common_variables.py containing the following code: from cohortextractor import patients from codelists import * You can then define your common variables in a dictionary ( dict ) rather than in a StudyDefinition . In this case we use age and sex. common_variables.py common_variables = dict ( age = patients . age_as_of ( \"2020-02-01\" , return_expectations = { \"rate\" : \"universal\" , \"int\" : { \"distribution\" : \"population_ages\" }, }, ), sex = patients . sex ( return_expectations = { \"rate\" : \"universal\" , \"category\" : { \"ratios\" : { \"M\" : 0.49 , \"F\" : 0.51 }}, } ), ) Define the specific study definitions \ud83d\udd17 Within each study_definition_*.py , add the line from common_variables import common_variables near the top with the other imports. You then add **common_variables just before the final closing brackets at the end of the file. This approach can also use different index dates, that are then passed to variables in common_variables.py . study_definition_copd.py from cohortextractor import ( StudyDefinition , patients , codelist_from_csv , codelist , combine_codelists ) from common_variables import common_variables from codelists import * study = StudyDefinition ( default_expectations = { \"date\" : { \"earliest\" : \"1970-01-01\" , \"latest\" : \"today\" }, \"rate\" : \"uniform\" , \"incidence\" : 0.2 , }, # define the study index date index_date = \"2020-01-01\" # STUDY POPULATION population = patients . all (), # COPD copd = patients . with_these_clinical_events ( copd_codes , find_first_match_in_period = True , date_format = \"YYYY-MM\" , ), ** common_variables ) Identical study definitions with different index dates \ud83d\udd17 Though the common_variables approach described above can be used to make cohorts using different index dates, if you want two cohorts that are entirely identical except for the index date, we can do this more simply. We start by using just one study definition , then within the project.yaml we define two actions, one for each index date you want to use. We then borrow the --index-date-range argument from the measures function to specify the index dates: version : \"3.0\" expectations : population_size : 1000 actions : generate_study_population_1 : run : cohortextractor:latest generate_cohort --study-definition study_definition --index-date-range \"2020-01-01\" outputs : highly_sensitive : cohort : output/input-2020-01-01.csv generate_study_population_2 : run : cohortextractor:latest generate_cohort --study-definition study_definition --index-date-range \"2020-09-01\" outputs : highly_sensitive : cohort : output/input-2020-09-01.csv Currently the study definition called above must have the index date defined within the StudyDefinition (e.g. index_date=\"2020-01-01\", ), though the date defined is arbitrary and is replaced by the arguments defined above.","title":"Study definitions"},{"location":"study-def/#what-is-a-study-definition","text":"A study definition is a formal specification of the data that you want to extract from the OpenSAFELY database. This includes: the patient population (dataset rows) the variables (dataset columns) the expected distributions of these variables for use in dummy data It is written in the Python programming language, using an OpenSAFELY-specific format which is intended to be easily written, read, and reviewed by anyone with some epidemiological knowledge. Some knowledge of python is helpful! The following documentation should get you through most cases, but some will make little sense to a non-Python programmer. It is on our roadmap to replace the Python-based approach with a configuration-based approach which is more secure, and can be driven from a graphical user interface. The OpenSAFELY framework case use a single study definition to query different vendor EHR databases, and saves the results to the secure server in a CSV file of tabular data. A study definition also allows a researcher to define the shape of the values they expect to get back from the vendor data. This allows the framework to generate dummy data which the researcher can use to develop and test their analysis scripts, without ever having to touch real patient data. When you generate a study population from your study definition , the framework reads a study definition from the python script (usually analysis/study_definition.py ), and writes the output data frame in a tabular CSV file (usually output/input.csv ). In a production environment this file will contain real data; in a development environment this will be dummy data. Currently the framework supports one row per patient datasets.","title":"What is a Study Definition?"},{"location":"study-def/#study_definitionpy-structure","text":"","title":"study_definition.py structure"},{"location":"study-def/#importing-code-building-blocks","text":"To create the study definition , we first need to import the functions and code to create this. You will need to put this codeblock at the top of your python file. from cohortextractor import ( StudyDefinition , patients , codelist_from_csv , codelist , filter_codes_by_category , combine_codelists ) This essentially says we want to import the some functions from the cohortextractor package which will be used throughout the script.","title":"Importing code building blocks"},{"location":"study-def/#a-simple-example","text":"The StudyDefinition() function (imported above) is used to define both the study population and the variables. study = StudyDefinition ( # define default dummy data behaviour default_expectations = { \"date\" : { \"earliest\" : \"1970-01-01\" , \"latest\" : \"today\" }, \"rate\" : \"uniform\" , \"incidence\" : 0.2 , }, # define the study index date index_date = \"2020-01-01\" # define the study population population = patients . all (), # define the study variables age = patients . age_as_of ( index_date ) # more variables ... ) default_expectations= is used to set default behaviour for the dummy data that is generated. In this case, we expect event dates to be between 1970-01-01 and today's date, uniformly distributed in that period, and to be recorded for 20% of patients (returning empty \"\" values otherwise). See Defining dummy data for more details. index_date= is used to set the index date against which all other dates can be defined. See Defining time periods for more details on how the index date is used. population= is where the population is defined. In this case, we want all patients available in the OpenSAFELY database and so we use the method all() to indicate this. See the study population section for more details on how to select a specific subset of patients in the OpenSAFELY database. The default_expectations , index_date , and population arguments are reserved names within StudyDefinition() . All other names are used to define the variables that will appear in the outputted dataset, using variable extractor functions of the form patients.function_name . age= is a simple example of an extractor function in use. The patients.age_as_of() function returns the age of each patient as of the date provided (in this case the index_date ). All other variables are defined similarly. To see the full list of currently available extractor functions, see Study definition variables reference .","title":"A simple example"},{"location":"study-def/#codelists","text":"For more information about how to create and edit codelists on the OpenSAFELY Codelists website, see Codelists .","title":"Codelists"},{"location":"study-def/#pulling-codelists-into-your-study-definition","text":"Many functions for defining variables take codelists as arguments. Codelists live as CSV files in the codelists/ directory, and are loaded into variables like this: chronic_cardiac_disease_codes = codelist_from_csv ( \"codelists/opensafely-chronic-cardiac-disease.csv\" , system = \"ctv3\" , column = \"CTV3ID\" ) You should put code that creates codelist variables before your StudyDefinition() , so it can refer to them, and users know where to look. You can do this in analysis/study_definition.py , but we recommend that you put all your codelist definitions into a file called codelists.py and importing it in at the top of your file: from codelists import * This keeps it cleaner and easier to read.","title":"Pulling Codelists into your Study Definition"},{"location":"study-def/#combining-codelists","text":"Codelists can be combined where appropriate. This has the advantage of keeping codeslists separate for some studies but easily combining them for others. Codelists can be combined using the combine_codelist function from cohortextractor , for example: from cohortextractor import combine_codelists all_cardiac_disease_codes = combine_codelists ( chronic_cardiac_disease_codes , acute_cardiac_disease_codes )","title":"Combining codelists"},{"location":"study-def/#defining-time-periods","text":"","title":"Defining time periods"},{"location":"study-def/#index-dates","text":"If you define an index_date on a study definition then everywhere that you might normally supply a date you can now supply a \"date expression\". Here is a simple example: study = StudyDefinition ( index_date = \"2015-06-01\" , population = patients . with_these_clinical_events ( copd_codes , between = [ \"first_day_of_year(index_date) - 2 years\" , \"last_day_of_year(index_date)\" , ], ), age = patients . age_as_of ( \"index_date\" ), ) This can make it easier to change the index date of a study by making sure it is only defined in once place. The simplest date expression is just index_date , which gets replaced by whatever the index date is set to. It's also possible to apply various functions to the index date. The available options (hopefully self-explanatory) are: \"first_day_of_month(index_date)\" \"last_day_of_month(index_date)\" \"first_day_of_year(index_date)\" \"last_day_of_year(index_date)\" Intervals of time can be added or subtracted from the index date (or from a function applied to the index date). The available units are year(s) , month(s) and day(s) . For example: \"index_date + 90 days\" \"first_day_of_month(index_date) + 9 months\" \"index_date - 1 year\" Note that if the index date is 29 February and you add or subtract some number of years which doesn't lead to a leap year, then an error will be thrown. An error will also be show if adding or subtracting months leads to a month with no equivalent day e.g. adding 1 month to 31 January to produce 31 February.","title":"Index Dates"},{"location":"study-def/#dynamic-dates","text":"Dates used in variable definitions can also be taken from date variables defined elsewhere in the study definition , rather than using a common fixed value. For example, we may want to define a patient's age as at a thier first positive test result, rather than a fixed index date. In this case we first define positive test date as a variable in the study definition , then refer to this variable name in the age definition: study = StudyDefinition ( pos_test_date = patients . with_test_result_in_sgss ( pathogen = \"SARS-CoV-2\" , test_result = \"positive\" , find_first_match_in_period = True , returning = \"date\" , date_format = \"YYYY-MM-DD\" , age = patients . age_as_of ( \"pos_test_date\" ), ) Here, the patient-specific date pos_test_date is defined as the first SARS-CoV-2 positive test result in SGSS , which will differ for each patient. The age variable is now defined relative to this date, i.e. age is given at the time of the positive SARS-CoV-2 test. Note the need for the variable name to be passed as a string rather than unquoted. We can also use date expressions on these dates, for example \"pos_test_date - 1 year\" Wherever the inputted date is null, in this case when a patient doesn't have a positive test result, any variables that reference the date will take the null value for their variable type (0 for numeric variables; an empty string for character and date variables).","title":"Dynamic dates"},{"location":"study-def/#time-periods","text":"Most variable extractor functions have arguments for specifying the date range over which you want to retrieve information. Most commonly this is on_or_before= , on_or_after= , or between= (see the variable reference for full documentation). You must use at most one. If no option is given then it will use all dates (including possibly future dates). As well as specifying dates explicitly with e.g., on_or_before=\"2019-12-31\" , you can use the date expressions discussed above.","title":"Time periods"},{"location":"study-def/#defining-and-extracting-variables","text":"All variables that you want to include in your dataset are declared within the StudyDefinition() function, using functions of the form patients.function_name() . To see the full documentation for all the variables that can be extracted with queries to the OpenSAFELY database, see Study Definition variable reference .","title":"Defining and extracting variables"},{"location":"study-def/#missing-values-and-unmatched-records","text":"If a query returns no matching record for a patient \u2014 for example if there are no blood pressure values recorded in a given period, or if there is no death date because the patient hasn't died, or if there is no household size available \u2014 then a default value will be returned. For strings and dates, the default value is the empty string \"\" . For booleans, integers, or floats, the default value is 0 . There is no universal null value outputted to input.csv because these may be handled inconsistently across different programs. It's possible that a record is matched, but the value is not valid. In this case, the value will be returned as-is. For example, a date set to \"9999-99-99\" or a blood pressure reading set to -1 . These will indicate missing / unknown / unrecorded / not applicable values in the source dataset. The meaning of these values will depend on the data source, and this should be documented in the dataset documentation .","title":"Missing values and unmatched records"},{"location":"study-def/#variables-that-return-value-date-pairs","text":"Some functions will produce two variables: a value and the corresponding date. In this case, expectations for both the value and the date can be specified, for example as follows: sbp = patients . mean_recorded_value ( systolic_blood_pressure_codes , on_most_recent_day_of_measurement = True , include_measurement_date = True , on_or_after = index_date , date_format = \"YYYY-MM-DD\" , return_expectations = { \"incidence\" : 0.8 , \"float\" : { \"distribution\" : \"normal\" , \"mean\" : 110 , \"stddev\" : 20 }, \"date\" : { \"earliest\" : index_date , \"latest\" : \"today\" }, \"rate\" : \"uniform\" }, ) This says that we expect the returned systolic blood pressure values to be normally distributed and available for 80% of patients, at dates between the index_date and \"today\" 's date. The date of the most recent measurement is distributed uniformly between those dates.","title":"Variables that return value-date pairs"},{"location":"study-def/#defining-dummy-data","text":"Every variable in a study definition must have a return_expectations argument defined (with the exception of the population variable). This defines the general shape or distribution of the variables in the dummy data used for developing the code. It is currently relatively unsophisticated; each variable is generated independently of all others. This is sufficient for testing that it is possible to run your study from start to finish in most cases, but sometimes not. You can find (and contribute to!) discussions on improving the dummy data framework here","title":"Defining dummy data"},{"location":"study-def/#specifying-default-distributions","text":"All variables use a default defined at the top of the study definition , with the default_expectations argument, as follows: study = StudyDefinition ( # Configure the expectations framework default_expectations = { \"date\" : { \"earliest\" : \"1900-01-01\" , \"latest\" : \"today\" }, \"rate\" : \"exponential_increase\" , \"incidence\" : 0.5 }, ... In this case, we are saying that: * Events dates are expected to be distributed between 1900 and today, with exponentially-increasing frequenc, with events occurring for 50% of patients. * Values for binary variables are expected to be positive 50% of the time. * Values for categorical variables are expected to be present (i.e., non-missing) 50% of the time. * Values for numeric variables are expected to be present (i.e., non-missing) 50% of the time.","title":"Specifying default distributions"},{"location":"study-def/#specifying-variable-specific-distributions","text":"If the defaults need to be overridden, then use the return_expectations argument within the variable extractor function, for example as follows: copd = patients . with_these_clinical_events ( copd_codes , returning = \"binary_flag\" , find_first_match_in_period = True , between = [ index_date , \"today\" ], return_expectations = { \"incidence\" : 0.2 }, ), This overrides the 50% default incidence for the binary variable copd to be 20% instead.","title":"Specifying variable-specific distributions"},{"location":"study-def/#all-options","text":"The following options are currently available for dummy data: integers {\"int\" : {\"distribution\": \"normal\", \"mean\": 25, \"stddev\": 5}, \"incidence\" : 0.5} {\"int\" : {\"distribution\": \"population_ages\"}, \"incidence\" : 1} numeric {\"float\" : {\"distribution\": \"normal\", \"mean\": 25, \"stddev\": 5}, \"incidence\" : 0.75} binary {\"incidence\": 0.33} categorical {\"category\": {\"ratios\": {\"cat1\": 0.1, \"cat2\": 0.2, \"cat3\": 0.7}}, \"incidence\" : 1} date {\"date\": {\"earliest\": \"1900-01-01\", \"latest\": \"today\"}, \"rate\" : \"exponential_increase\"} {\"date\": {\"earliest\": \"1900-01-01\", \"latest\": \"today\"}, \"rate\" : \"uniform\"} Note that \"incidence\" is used either for the actual incidence of a binary variable ( returning=\"binary_flag\" ), or to indicate non-missingness for other variable types. \"rate\" is used for the distribution of date values (with either \"exponential_increase\" or \"uniform\" ), but can also be used as an alias for incidence=1 by specifying rate=\"universal\" for non-date values. population_ages samples from the distribution of ages in the UK taken from the Office for National Statistics .","title":"All options"},{"location":"study-def/#defining-study-populations","text":"Most commonly, you will want to include only patients with certain characteristics, rather than every patient in the database.","title":"Defining study populations"},{"location":"study-def/#using-variables-to-define-your-population","text":"To define a study population with one particular characteristic, you need to define the characteristic within the study population. population = patients . with_these_clinical_events ( copd_codes , on_or_before = \"2017-03-01\" , )","title":"Using variables to define your population"},{"location":"study-def/#using-time-registered-in-one-practice","text":"Researchers often want to exclude patients who have switched practice recently and hence may have an incomplete record of their conditions as it can take some time for their records to come from their previous practice. population = patients . registered_with_one_practice_between ( \"2019-03-01\" , \"2020-03-01\" )","title":"Using time registered in one practice"},{"location":"study-def/#combining-population-criteria","text":"Population criteria may need to be combined. Here we have combined both COPD and registration details to find only patients who have COPD and have been registered at a practice for more than a year. population = patients . satisfying ( \"has_follow_up AND has_copd\" , has_copd = patients . with_these_clinical_events ( copd_codes , on_or_before = \"2017-03-01\" ), has_follow_up = patients . registered_with_one_practice_between ( \"2019-03-01\" , \"2020-03-01\" ), ) If a variable has been defined elsewhere in StudyDefinition() , then that variable can be used in the patients.satisfying() function without needing to be defined again. For example, study = StudyDefinition ( population = patients . satisfying ( \"\"\" has_follow_up AND (sex = \"M\" OR sex = \"F\") \"\"\" , has_follow_up = patients . registered_with_one_practice_between ( \"2019-03-01\" , \"2020-03-01\" ), ) sex = patients . sex ( \"incidence\" : 1 , returning_expectations = { \"category\" : { \"ratios\" : { \"M\" : 0.49 , \"F\" : 0.51 }}} ), ) Here sex is defined outside of patients.satisfying() but can still be used inside of it. In this case, it's being used to exclude patients without a \"valid\" sex category ( \"M\" or \"F\" ) from the study population.","title":"Combining population criteria"},{"location":"study-def/#dummy-data-versus-real-data","text":"The population= argument has no bearing at all on the dummy data. It is just used to select patients in the real data. If in the example above we had \"incidence\" : 0.95 , then 5% of patients in the dummy data would have missing sex values, but 0% of patients in the real data would have missing sex values because they have been excluded with population= . It's important therefore to match the dummy data with what you would expect to see conditional on the chosen patient population, rather than in the data as a whole.","title":"Dummy data versus real data"},{"location":"study-def/#multiple-study-definitions","text":"","title":"Multiple study definitions"},{"location":"study-def/#naming","text":"A study_definition.py will produce a file called input.csv . If you only require one study population, we recommend you stick with this. Multiple study definition files can be specified using a suffix like: study_definition_copd.py study_definition_asthma.py And all the corresponding output files will have the same suffix e.g. input_copd.csv input_asthma.csv You should reflect this by creating two cohortextractor actions in the project.yaml , one for each study definition : version : \"3.0\" expectations : population_size : 1000 actions : generate_copd_cohort : run : cohortextractor:latest generate_cohort --study-definition study_definition_copd outputs : highly_sensitive : cohort : output/input_copd.csv generate_asthma_cohort : run : cohortextractor:latest generate_cohort --study-definition study_definition_asthma outputs : highly_sensitive : cohort : output/input_asthma.csv","title":"Naming"},{"location":"study-def/#sharing-common-study-definition-variables","text":"When using multiple study definitions, there's often a lot of common variables between them, with just the population and maybe a couple of other variables that differ. This means you have to separately specify the common variables in each definition, and it's easy to make an error, particularly when something needs changing. To avoid this, there is a way to share these common variables between study definitions: Make a file called common_variables.py containing the following code: from cohortextractor import patients from codelists import * You can then define your common variables in a dictionary ( dict ) rather than in a StudyDefinition . In this case we use age and sex. common_variables.py common_variables = dict ( age = patients . age_as_of ( \"2020-02-01\" , return_expectations = { \"rate\" : \"universal\" , \"int\" : { \"distribution\" : \"population_ages\" }, }, ), sex = patients . sex ( return_expectations = { \"rate\" : \"universal\" , \"category\" : { \"ratios\" : { \"M\" : 0.49 , \"F\" : 0.51 }}, } ), )","title":"Sharing common study definition variables"},{"location":"study-def/#define-the-specific-study-definitions","text":"Within each study_definition_*.py , add the line from common_variables import common_variables near the top with the other imports. You then add **common_variables just before the final closing brackets at the end of the file. This approach can also use different index dates, that are then passed to variables in common_variables.py . study_definition_copd.py from cohortextractor import ( StudyDefinition , patients , codelist_from_csv , codelist , combine_codelists ) from common_variables import common_variables from codelists import * study = StudyDefinition ( default_expectations = { \"date\" : { \"earliest\" : \"1970-01-01\" , \"latest\" : \"today\" }, \"rate\" : \"uniform\" , \"incidence\" : 0.2 , }, # define the study index date index_date = \"2020-01-01\" # STUDY POPULATION population = patients . all (), # COPD copd = patients . with_these_clinical_events ( copd_codes , find_first_match_in_period = True , date_format = \"YYYY-MM\" , ), ** common_variables )","title":"Define the specific study definitions"},{"location":"study-def/#identical-study-definitions-with-different-index-dates","text":"Though the common_variables approach described above can be used to make cohorts using different index dates, if you want two cohorts that are entirely identical except for the index date, we can do this more simply. We start by using just one study definition , then within the project.yaml we define two actions, one for each index date you want to use. We then borrow the --index-date-range argument from the measures function to specify the index dates: version : \"3.0\" expectations : population_size : 1000 actions : generate_study_population_1 : run : cohortextractor:latest generate_cohort --study-definition study_definition --index-date-range \"2020-01-01\" outputs : highly_sensitive : cohort : output/input-2020-01-01.csv generate_study_population_2 : run : cohortextractor:latest generate_cohort --study-definition study_definition --index-date-range \"2020-09-01\" outputs : highly_sensitive : cohort : output/input-2020-09-01.csv Currently the study definition called above must have the index date defined within the StudyDefinition (e.g. index_date=\"2020-01-01\", ), though the date defined is arbitrary and is replaced by the arguments defined above.","title":"Identical study definitions with different index dates"},{"location":"study_definition_api/","text":"Full API \ud83d\udd17 patients \ud83d\udd17 This module provides the methods for making a study definition These methods don't do anything; they just return their name and arguments. This provides a friendlier API than having to build some big nested data structure by hand and means we can make use of autocomplete, docstrings etc to make it a bit more discoverable. address_as_of ( date , returning = None , round_to_nearest = None , return_expectations = None ) \ud83d\udd17 Return patients' address characteristics such as IMD as of a particular date Parameters: Name Description Default date date of interest as a string with the format YYYY-MM-DD . Filters results to the given date. required returning a str defining the type of data to be returned. options include index_of_multiple_deprivation rural_urban_classification , and msoa . The default value is None . None round_to_nearest an integer that represents how index_of_multiple_deprivation value are rounded. Only use when returning is index_of_multiple_deprivation None return_expectations a dict defining the rate and the categories returned with ratios None Returns: Type Description list of integers for rural_urban_classification and index_of_multiple_deprivation , strings for msoa Exceptions: Type Description ValueError if unsupported returning argument is provided Examples: This creates a variable called imd based on patient address. imd=patients.address_as_of( \"2020-02-29\", returning=\"index_of_multiple_deprivation\", round_to_nearest=100, return_expectations={ \"rate\": \"universal\", \"category\": {\"ratios\": {\"100\": 0.1, \"200\": 0.2, \"300\": 0.7}}, }, ) admitted_to_hospital ( on_or_before = None , on_or_after = None , between = None , returning = 'binary_flag' , find_first_match_in_period = None , find_last_match_in_period = None , date_format = None , with_these_diagnoses = None , with_these_primary_diagnoses = None , with_these_procedures = None , return_expectations = None ) \ud83d\udd17 Return information about admission to hospital. See https://github.com/opensafely/cohort-extractor/issues/186 for in-depth discussion and background. Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a string indicating what type of value should be returned. Options for returning are: binary_flag: if they were admitted at all date_admitted: date patient admitted to hospital date_discharged: date patient discharged from hospital number_of_matches_in_period: number of times patient was admitted in time period specified primary_diagnosis: primary diagnosis code for admission 'binary_flag' find_first_match_in_period a boolean that indicates if the data returned is first event if there are multiple matches within the time period None find_last_match_in_period a boolean that indicates if the data returned is last event if there are multiple matches within the time period None date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None with_these_diagnoses icd10 codes to match against any diagnosis None with_these_primary_diagnoses icd10 codes to match against the primary diagnosis None with_these_procedures opcs4 codes to match against the procedure None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date_admitted or date_discharged ; of integers if returning argument is set to number_of_matches_in_period . list of strings with alphanumerical code format for ICD10 code if returning argument is set to primary_diagnosis Examples: The day of each patient's first hospital admission for Covid19: covid_admission_date=patients.admitted_to_hospital( returning= \"date_admitted\", with_these_diagnoses=covid_codelist, on_or_after=\"2020-02-01\", find_first_match_in_period=True, date_format=\"YYYY-MM-DD\", return_expectations={\"date\": {\"earliest\": \"2020-03-01\"}}, ) admitted_to_icu ( on_or_after = None , on_or_before = None , between = None , find_first_match_in_period = None , find_last_match_in_period = None , returning = 'binary_flag' , date_format = None , return_expectations = None , include_month = False , include_day = False ) \ud83d\udd17 Return information about being admitted to ICU. Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . None find_first_match_in_period a boolean that indicates if the data returned is first admission to icu if there are multiple admissions within the time period None find_last_match_in_period a boolean that indicates if the data returned is last admission to icu if there are multiple admissions within the time period None returning binary_flag: Whether patient attended A&E date_admitted: Date patient arrived in A&E had_respiratory_support: Whether patient received any form of respiratory support had_basic_respiratory_support: Whether patient received \"basic\" respiratory support had_advanced_respiratory_support: Whether patient received \"advanced\" respiratory support (Note that the terms \"basic\" and \"advanced\" are derived from the underlying ICNARC data.) 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. Only used if returning is binary_flag None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. This is a 2-item key-value dictionary of date and rate . None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag , had_respiratory_support , had_basic_respiratory_support or had_advanced_respiratory_support ; list of strings with a date format returned if returning argument is set to date_admitted Examples: This returns two variables \u2014 one called icu_date_admitted and another had_resp_support : has_resp_support=patients.admitted_to_icu( on_or_after=\"2020-02-01\", find_first_match_in_period=True, returning=\"had_respiratory_support\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ), icu_date_admitted=patients.admitted_to_icu( on_or_after=\"2020-02-01\", find_first_match_in_period=True, returning=\"date_admitted\", date_format=\"YYYY-MM-DD\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ), age_as_of ( reference_date , return_expectations = None ) \ud83d\udd17 Returns age of patient of at a particular date. Note can be negative if born after reference_date . Parameters: Name Description Default reference_date date of interest as a string with the format YYYY-MM-DD required return_expectations a dict defining an expectation definition that includes at least a rate and a distribution. If distribution is defined as \"population_ages\" it returns likely distribution based on known UK age bands in 2018 (see file: \"uk_population_bands_2018.csv\") None Returns: Type Description list ages as integers Examples: This creates a variable \"age\" with all patient returning an age as an integer: age=patients.age_as_of( \"2020-02-01\", return_expectations={ \"rate\" : \"universal\", \"int\" : {\"distribution\" : \"population_ages\"} } ) all () \ud83d\udd17 attended_emergency_care ( on_or_before = None , on_or_after = None , between = None , returning = 'binary_flag' , find_first_match_in_period = None , find_last_match_in_period = None , date_format = None , with_these_diagnoses = None , discharged_to = None , return_expectations = None ) \ud83d\udd17 Return information about attendance of A&E from the ECDS dataset. Please note that there is a limited number of diagnoses allowed within this dataset, and so will not match with the range of diagnoses allowed in other datasets such as the primary care record. Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a string indicating what type of value should be returned. Options for returning are: binary_flag: Whether patient attended A&E date_arrived: date patient arrived in A&E number_of_matches_in_period: number of times patient attended A&E discharge_destination: SNOMED CT code of discharge destination. This will be a member of refset 999003011000000105. 'binary_flag' find_first_match_in_period a boolean that indicates if the data returned is first event if there are multiple matches within the time period None find_last_match_in_period a boolean that indicates if the data returned is last event if there are multiple matches within the time period None date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None with_these_diagnoses a list of SNOMED CT codes None discharged_to a list of members of refset 999003011000000105. None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date_arrived ; of integers if returning argument is set to number_of_matches_in_period or discharge_destination (with SNOMED CT code as a numerical value) Examples: A variable called emergency_care is created with returns a date of first attendence in A&E if patient had attended emergency room during the time period. emergency_care=patients.attended_emergency_care( on_or_after=\"2020-01-01\", returning=\"date_arrived\", date_format=\"YYYY-MM-DD\", find_first_match_in_period=True, return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ) care_home_status_as_of ( date , categorised_as = None , return_expectations = None ) \ud83d\udd17 TPP have attempted to match patient addresses to care homes as stored in the CQC database. At its most simple this query returns a boolean indicating whether the patient's address (as of the supplied time) matched with a care home. It is also possible return a more complex categorisation based on attributes of the care homes in the CQC database, which can be freely downloaded here: https://www.cqc.org.uk/about-us/transparency/using-cqc-data At present the only imported fields are: LocationRequiresNursing LocationDoesNotRequireNursing But we can ask for more fields to be imported if needed. The categorised_as argument acts in effectively the same way as for the categorised_as function except that the only columns that can be referred to are those belonging to the care home table (i.e. the two nursing fields above) and the boolean IsPotentialCareHome Parameters: Name Description Default date date of interest as a string with the format YYYY-MM-DD . Filters results to the given date required categorised_as a logic expression that applies an algorithm to specific variables to create categories None return_expectations a dict defining the rate and the categories returned with ratios None Returns: Type Description list of strings which each letter representing a category as defined by the algorithm Examples: This creates a variable called care_home_type which contains a 2 letter string which represents a type of care home environment. care_home_type=patients.care_home_status_as_of( \"2020-02-01\", categorised_as={ \"PC\": \"\"\" IsPotentialCareHome AND LocationDoesNotRequireNursing='Y' AND LocationRequiresNursing='N' \"\"\", \"PN\": \"\"\" IsPotentialCareHome AND LocationDoesNotRequireNursing='N' AND LocationRequiresNursing='Y' \"\"\", \"PS\": \"IsPotentialCareHome\", \"U\": \"DEFAULT\", }, return_expectations={ \"rate\": \"universal\", \"category\": {\"ratios\": {\"PC\": 0.05, \"PN\": 0.05, \"PS\": 0.05, \"U\": 0.85,},}, }, ), categorised_as ( category_definitions , return_expectations = None , ** extra_columns ) \ud83d\udd17 Patients who had had 1 or more code from 1 or more codelists are categorised into groups according to a prescribed algorithm. Parameters: Name Description Default category_definitions a dict that defines the algorithm and the associated category The keys of the dict are strings representing categories from a defined by other arguments such as with_these_clinical_events . The values are expressions of logic using statements and AND/OR statements. A default argument should be provided if a particular patient cannot be categorised to the algorithm. required return_expectations a dict that defined the ratios of each category. The keys are the category values as strings and the values are ratios as floats. The ratios should add up to 1. None Retyrns list: of strings which each letter representing a category as defined by the algorithm Examples: This creates a variable of asthma status based on codes for asthma and categorising for recent steroid use. current_asthma=patients.categorised_as( { \"1\": \"DEFAULT\", \"2\": \"recent_asthma_code AND prednisolone_last_year = 0\" \"3\": \"recent_asthma_code AND prednisolone_last_year > 0\" }, recent_asthma_code=patients.with_these_clinical_events( asthma_codes, between=[\"2017-02-01\", \"2020-01-31\"], ), prednisolone_last_year=patients.with_these_medications( pred_codes, between=[\"2019-02-01\", \"2020-01-31\"], returning=\"number_of_matches_in_period\", ), return_expectations={ \"category\":{\"ratios\": {\"0\": 0.8, \"1\": 0.1, \"2\": 0.1}} }, ) date_deregistered_from_all_supported_practices ( on_or_before = None , on_or_after = None , between = None , date_format = None , return_expectations = None ) \ud83d\udd17 Returns the date (if any) on which the patient de-registered from all practices for which OpenSAFELY has data. Events which occur in primary care after this date will not be recorded in the platform (though there may be data from other sources e.g. SGSS, CPNS). Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of strings with a date format returned if patient had deregistered, otherwise empty Examples: A variable called dereg_date is created with returns a date of de-registration if patient has deregistered from a practice within the dataset within the specified time period. dereg_date=patients.date_deregistered_from_all_supported_practices( on_or_after=\"2020-03-01\", date_format=\"YYYY-MM\", return_expectations={ {\"date\": {\"earliest\": \"2020-03-01\"}, \"incidence\": 0.05 } ) date_of ( source , date_format = None , include_month = False , include_day = False , return_expectations = None ) \ud83d\udd17 date_of_birth ( date_format = None , return_expectations = None ) \ud83d\udd17 Returns date of birth as a string with format \"YYYY-MM\" Parameters: Name Description Default date_format a string detailing the format of the dates for date of birth to be returned. It can be \"YYYY-MM\" or \"YYYY\" and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with month and year. None return_expectations a dictionary containing an expectation definition defining a rate and a distribution None Returns: Type Description list dates as strings with \"YYYY-MM\" format Exceptions: Type Description ValueError if Date of Birth is attempted to be returned with a YYYY-MM-DD format. Examples: This creates a variable dob with all patient returning a year and month as a string: dob=patients.date_of_birth( \"YYYY-MM\", return_expectations={ \"date\": {\"earliest\": \"1950-01-01\", \"latest\": \"today\"}, \"rate\": \"uniform\", } ) died_from_any_cause ( on_or_before = None , on_or_after = None , between = None , returning = 'binary_flag' , date_format = None , include_month = False , include_day = False , return_expectations = None ) \ud83d\udd17 Identify patients who with ONS-registered deaths Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a string indicating what type of value should be returned. The options are: date_of_death: Date of death binary_flag: If they died or not 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date_of_death Examples: A variable called died_any is created that returns the date of death for any patients that have died in the time period. died_any=patients.died_from_any_cause( on_or_after=\"2020-02-01\", returning=\"date_of_death\", date_format=\"YYYY-MM-DD\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ) household_as_of ( reference_date , returning = None , return_expectations = None ) \ud83d\udd17 Return information about the household to which the patient belonged as of the reference date. This is inferred from address data using an algorithm developed by TPP (to be documented soon) so the results are not 100% reliable but are apparently pretty good. !!! args reference_date: date of interest as a string with the format `YYYY-MM-DD`. Filters results to a particular set date !!! returning \"a string indicating what type of value should be returned. The options for `returning` are:\" !!! pseudo_id \"An integer identifier for the household which has no meaning\" other than to identify individual members of the same household (0 if no household information available) !!! household_size \"the number of individuals in the household (0 if no\" household information available) !!! is_prison \"Boolean indicating whether household is a prison. See\" https://github.com/opensafely/cohort-extractor/issues/271#issuecomment-679069981 for details of how this is determined. !!! has_members_in_other_ehr_systems \"Boolean indicating whether some household\" members are registered with GPs using a different EHR system, meaning that our coverage of the household is incomplete. !!! percentage_of_members_with_data_in_this_backend \"Integer giving the (estimated)\" percentage of household members where we have EHR data available in this backend (i.e. not in other systems as above) msoa: Returns the MSOA (Middle Super Output Area) in which the household is situated return_expectations: a dictionary defining the incidence and distribution of expected value within the population in question. Returns: Type Description list of integers if returning argument is set to pseudo_id , household_size or percentage_of_members_with_data_in_this_backend . a list of 1 or 0 is returning is set to is_prison or has_members_in_other_ehr_systems Examples: household_id=patients.household_as_of( \"2020-02-01\", returning=\"pseudo_id\" ) household_size=patients.household_as_of( \"2020-02-01\", returning=\"household_size\" ), maximum_of ( * column_names , ** extra_columns ) \ud83d\udd17 Return the maximum value over the supplied columns e.g max_value=patients.maximum_of(\"some_column\", \"another_column\") Additional columns can be defined within the function call which will be used in computing the maximum but won't themselves appear in the output: max_value=patients.maximum_of( \"some_column\", another_colum=patients.with_these_medications(...) ) mean_recorded_value ( codelist , on_most_recent_day_of_measurement = None , return_expectations = None , on_or_before = None , on_or_after = None , between = None , include_measurement_date = False , date_format = None , include_month = False , include_day = False ) \ud83d\udd17 Return patients' mean recorded value of a numerical value as defined by a codelist on a particular day within the defined period. This is important as allows us to account for multiple measurements taken on one day. The date of the measurement can be included by flagging with date format options. Parameters: Name Description Default codelist a codelist for requested value required on_most_recent_day_of_measurement boolean flag for requesting measurements be on most recent date None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. This is a 3-item key-value dictionary of \"date\" and \"float\". \"date\" is dictionary itself and should contain the earliest and latest dates needed in the dummy data. float is a dictionary of distribution , mean , and stddev . These values determine the shape of the dummy data returned, and the float means a float will be returned rather than an integer. incidence must have a value and this is what percentage of dummy patients have a value. It needs to be a number between 0 and 1. None on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to measurements on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to measurements on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to measurements between the two dates provided. The default value is None . None include_measurement_date a boolean indicating if an extra column, named date_of_bmi , should be included in the output. The default value is False . False date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. Only used if include_measurement_date is True None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False Returns: Type Description float mean of value Examples: This creates a variable bp_sys returning a float of the most recent systolic blood pressure from the record within the time period. In the event of repeated measurements on the same day, these are averaged. Patient who do not have this information available do not return a value: bp_sys=patients.mean_recorded_value( systolic_blood_pressure_codes, on_most_recent_day_of_measurement=True, between=[\"2017-02-01\", \"2020-01-31\"], include_measurement_date=True, date_format=\"YYYY-MM\", return_expectations={ \"float\": {\"distribution\": \"normal\", \"mean\": 80, \"stddev\": 10}, \"date\": {\"earliest\": \"2019-02-01\", \"latest\": \"2020-01-31\"}, \"incidence\": 0.95, }, ) minimum_of ( * column_names , ** extra_columns ) \ud83d\udd17 Return the minimum value over the supplied columns e.g min_value=patients.minimum_of(\"some_column\", \"another_column\") Note: this ignores \"empty values\" (i.e. the values used if there is no data for a particular column, such as 0.0 for numeric values or the empty string for dates). This ensures that the minimum of a column with a defined value and one with a missing value is equal to the defined value. Additional columns can be defined within the function call which will be used in computing the minimum but won't themselves appear in the output: min_value=patients.minimum_of( \"some_column\", another_colum=patients.with_these_medications(...) ) most_recent_bmi ( on_or_before = None , on_or_after = None , between = None , minimum_age_at_measurement = 16 , return_expectations = None , include_measurement_date = False , date_format = None , include_month = False , include_day = False ) \ud83d\udd17 Return patients' most recent BMI (in the defined period) either computed from weight and height measurements or, where they are not availble, from recorded BMI values. Measurements taken when a patient was below the minimum age are ignored. The height measurement can be taken before (but not after) the defined period as long as the patient was over the minimum age at the time. The date of the measurement can be obtained using date_of(\"<bmi-column-name>\") . If the BMI is computed from weight and height then we use the date of the weight measurement for this. Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to measurements on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to measurements on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to measurements between the two dates provided. The default value is None . None minimum_age_at_measurement Measurements taken before this age will not count towards BMI calculations. It is an integer and the default value is 16. 16 return_expectations a dictionary defining the incidence and distribution of expected BMI within the population in question. This is a 3-item key-value dictionary of \"date\" and \"float\". \"date\" is dictionary itself and should contain the earliest and latest dates needed in the dummy data. float is a dictionary of distribution , mean , and stddev . These values determine the shape of the dummy data returned, and the float means a float will be returned rather than an integer. incidence must have a value and this is what percentage of dummy patients have a BMI. It needs to be a number between 0 and 1. None include_measurement_date a boolean indicating if an extra column, named date_of_bmi , should be included in the output. The default value is False . False date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. Only used if include_measurement_date is True None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False Returns: Type Description float most recent BMI Examples: This creates a variable \"bmi\" returning a float of the most recent bmi calculated from recorded height and weight, or from a recorded bmi record. Patient who do not have this information available do not return a value: bmi=patients.most_recent_bmi( between=[\"2010-02-01\", \"2020-01-31\"], minimum_age_at_measurement=18, include_measurement_date=True, date_format=\"YYYY-MM\", return_expectations={ \"date\": {\"earliest\": \"2010-02-01\", \"latest\": \"2020-01-31\"}, \"float\": {\"distribution\": \"normal\", \"mean\": 28, \"stddev\": 8}, \"incidence\": 0.80, } ) random_sample ( percent = None , return_expectations = None ) \ud83d\udd17 Flags a random sample of approximately percent patients. Parameters: Name Description Default percent an integer between 1 and 100 for the percent of patients to include within the random sample None return_expectations a dict containing an expectations definition defining at least an incidence None Returns: Type Description list of integers of 1 or 0 Examples: This creates a variable example , flagging approximately 10% of the population with the value 1 : example=patients.random_sample(percent=10, expectations={'incidence': 0.1}) registered_as_of ( reference_date , return_expectations = None ) \ud83d\udd17 All patients registered on the given date. Note this function passes arguments to registered_with_one_practice_between() Parameters: Name Description Default reference_date date of interest as a string with the format YYYY-MM-DD . Filters results to patients registered at a practice on the given date. required return_expectations a dictionary containing an expectation definition defining an incidence between 0 and 1 . None Returns: Type Description list of integers of 1 or 0 . Examples: This creates a variable \"registered\" with patient returning an integer of 1 if patient registered at date. Patients who are not registered return an integer of 0 : registered=patients.registered_as_of( \"2020-03-01\", return_expectations={\"incidence\": 0.98} ) registered_practice_as_of ( date , returning = None , return_expectations = None ) \ud83d\udd17 Return patients' practice address characteristics such as STP or MSOA Parameters: Name Description Default date date of interest as a string with the format YYYY-MM-DD . Filters results to the given date. required returning a str defining the type of data to be returned. options include msoa , nuts1_region_name, and stp_code . The default value is None . None return_expectations a dict defining the rate and the categories returned with ratios None Returns: Type Description list of strings Exceptions: Type Description ValueError if unsupported returning argument is provided Examples: This creates a variable called region based on practice address of the patient: region=patients.registered_practice_as_of( \"2020-02-01\", returning=\"nuts1_region_name\", return_expectations={ \"rate\": \"universal\", \"category\": { \"ratios\": { \"North East\": 0.1, \"North West\": 0.1, \"Yorkshire and the Humber\": 0.1, \"East Midlands\": 0.1, \"West Midlands\": 0.1, \"East of England\": 0.1, \"London\": 0.2, \"South East\": 0.2, }, }, }, ) registered_with_one_practice_between ( start_date , end_date , return_expectations = None ) \ud83d\udd17 All patients registered with the same practice through the given period Parameters: Name Description Default start_date start date of interest of period as a string with the format YYYY-MM-DD . Together with end date, this filters results to patients registered at a practice between two dates required end_date end date of interest of period as a string with the format YYYY-MM-DD . Together with start date, this filters results to patients registered at a practice between two dates required return_expectations a dictionary containing an expectation definition defining an incidence between 0 and 1 . None Returns: Type Description list of integers of 1 or 0 . Examples: This creates a variable registered_one with patient returning an integer of 1 if patient registered at one practice between two dates. Patients who are not registered return an integer of 0 . registered_one=patients.registered_with_one_practice_between( start_date=\"2020-03-01\", end_date=\"2020-06-01\", return_expectations={\"incidence\": 0.90} ) satisfying ( expression , return_expectations = None , ** extra_columns ) \ud83d\udd17 Patients who meet the criteria for one or more expressions. Used as a way of combining groups or making subgroups based on certain characteristics. Parameters: Name Description Default expression a string in that links together 2 or more expressions into one statement. key variables for this expression can be defined under this statement or anywhere in study definition. required return_expectations a dictionary defining the rate of expected value within the population in question None Returns: Type Description list of integers, either 1 or 0 Examples: This creates a study population where patients included have asthma and not copd: population=patients.satisfying( \"\"\" has_asthma AND NOT has_copd \"\"\", has_asthma=patients.with_these_clinical_events( asthma_codes, between=[\"2017-02-28\", \"2020-02-29\"], has_copd=patients.with_these_clinical_events( copd_codes, between=[\"2017-02-28\", \"2020-02-29\"], ), ) sex ( return_expectations = None ) \ud83d\udd17 Returns the sex of the patient. Parameters: Name Description Default return_expectations a dict containing an expectation definition defining a rate and a ratio for sexes None Returns: Type Description list \"M\" male, \"F\" female, \"I\" intersex, or \"U\" unknown. Examples: This creates a variable 'sex' with all patients returning a sex of either \"M\", \"F\" or \"\" sex=patients.sex( return_expectations={ \"rate\": \"universal\", \"category\": {\"ratios\": {\"M\": 0.49, \"F\": 0.51}}, } ) with_complete_gp_consultation_history_between ( start_date , end_date , return_expectations = None ) \ud83d\udd17 The concept of a \"consultation\" in EHR systems does not map exactly to the GP-patient interaction we're interested in (see above) so there is some processing required on the part of the EHR vendor to produce the consultation record we need. This does not happen automatically as part of the GP2GP transfer, and therefore this query can be used to find just those patients for which the full history is available. This means finding patients who have been continuously registered with a single TPP-using practice throughout a time period. Parameters: Name Description Default start_date start date of interest as a string with the format YYYY-MM-DD required end_date end date of interest as a string with the format YYYY-MM-DD required return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None with_complete_history_between ( start_date , end_date , return_expectations = None ) \ud83d\udd17 All patients for which we have a full set of records between the given dates Parameters: Name Description Default start_date start date of interest of period as a string with the format YYYY-MM-DD . Together with end date, this filters results to patients registered at a practice between two dates who have a complete history. required end_date end date of interest of period as a string with the format YYYY-MM-DD . Together with start date, this filters results to patients registered at a practice between two dates who have a complete history. required return_expectations a dictionary containing an expectation definition defining an incidence between 0 and 1 . None Returns: Type Description list of integers of 1 or 0 Examples: This creates a variable has_consultation_history with patient returning an integer of 1 if patient registered at one practice between two dates and has a completed record. Patients who are not registered with a complete record return an integer of 0 . has_consultation_history=patients.with_complete_gp_consultation_history_between( start_date=\"2019-02-01\", end_date=\"2020-01-31\", return_expectations={\"incidence\": 0.9}, ) with_death_recorded_in_cpns ( on_or_before = None , on_or_after = None , between = None , returning = 'binary_flag' , date_format = None , include_month = False , include_day = False , return_expectations = None ) \ud83d\udd17 Identify patients who with death registered in CPNS dataset Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a string indicating what type of value should be returned. The options are: date_of_death: Date of death binary_flag: If they died or not 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date_of_death Examples: A variable called died_date_cpns is created that returns the date of death for any patients have died in the CPNS dataset. died_date_cpns=patients.with_death_recorded_in_cpns( on_or_after=\"2020-02-01\", returning=\"date_of_death\", include_month=True, include_day=True, return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ), with_death_recorded_in_primary_care ( on_or_before = None , on_or_after = None , between = None , returning = 'binary_flag' , date_format = None , return_expectations = None ) \ud83d\udd17 Identify patients with a date-of-death in their primary care record. There is generally a lag between the death being recorded in ONS data and appearing in the primary care record, but the date itself is usually reliable when it appears. By contrast, cause of death is often not accurate in the primary care record so we don't make it available to query here. Args: !!! on_or_before \"date of interest as a string with the format `YYYY-MM-DD`. Filters results\" on or before the given date. The default value is `None`. !!! on_or_after \"date of interest as a string with the format `YYYY-MM-DD`. Filters results\" on or after the given date. The default value is `None`. !!! between \"two dates of interest as a list with each date as a string with the format `YYYY-MM-DD`.\" Filters results to between the two dates provided. The default value is `None`. !!! returning \"a string indicating what type of value should be returned. The options are:\" date_of_death: Date of death binary_flag: If they died or not !!! date_format \"a string detailing the format of the dates to be returned. It can be `YYYY-MM-DD`,\" `YYYY-MM` or `YYYY` and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. !!! return_expectations \"a dictionary defining the incidence and distribution of expected value\" within the population in question. Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date_of_death Examples: A variable called died_date_gp is created that returns the date of death for any patients have died in the GP dataset. died_date_gp=patients.with_death_recorded_in_primary_care( on_or_after=\"2020-02-01\", returning=\"date_of_death\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ), with_gp_consultations ( on_or_before = None , on_or_after = None , between = None , find_first_match_in_period = None , find_last_match_in_period = None , returning = 'binary_flag' , date_format = None , return_expectations = None ) \ud83d\udd17 These are GP-patient interactions, either in person or via phone/video call. The concept of a \"consultation\" in EHR systems is generally broader and might include things like updating a phone number with the receptionist. Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None find_first_match_in_period a boolean that indicates if the data returned is first event if there are multiple matches within the time period None find_last_match_in_period a boolean that indicates if the data returned is last event if there are multiple matches within the time period None returning a string indicating what type of value should be returned. The options are limited to binary_flag (which indicates if they have had the an event or not), date (which indicate date of event and used with either find_first_match_in_period or find_last_match_in_period), or number_of_matches_in_period (which counts the events in the period) 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date ; a list of integers if returning argument is set to number_of_matches_in_period Examples: A variable called gp_count is created that counts number of GP consultation between two dates in 2019. gp_count=patients.with_gp_consultations( between=[\"2019-01-01\", \"2020-12-31\"], returning=\"number_of_matches_in_period\", return_expectations={ \"int\": {\"distribution\": \"normal\", \"mean\": 6, \"stddev\": 3}, \"incidence\": 0.6, }, ) with_high_cost_drugs ( drug_name_matches = None , on_or_before = None , on_or_after = None , between = None , returning = 'binary_flag' , date_format = None , find_first_match_in_period = None , find_last_match_in_period = None , return_expectations = None ) \ud83d\udd17 Returns data from the High Cost Drugs Dataset More details available in this notebook: https://github.com/opensafely/highcostdrugs-research/blob/master/analysis/High%20Cost%20Drugs%20Dataset.ipynb Parameters: Name Description Default drug_name_matches a drug name as a string, or a list of such names, or a codelist containing such names. Results will be filtered to just rows matching any of the supplied names exactly. Note these are not standardised names, they are just the names however they come to us in the original data. None returning a string indicating what type of value should be returned. Options are: binary_flag: if the patient received any matching drugs date: date drug received 'binary_flag' on_or_before as described elsewhere None on_or_after as described elsewhere None between as described elsewhere None find_first_match_in_period as described elsewhere None find_last_match_in_period as described elsewhere None date_format only \"YYYY\" and \"YYYY-MM\" supported here as day level data not available None return_expectations as described elsewhere None Examples: The first month in which each patient received \"ACME Drug\" after March 2019: covid_admission_date=patients.with_high_cost_drugs( drug_name_matches=\"ACME Drug\", on_or_after=\"2019-03-01\", find_first_match_in_period=True, returning=\"date\", date_format=\"YYYY-MM\", return_expectations={\"date\": {\"earliest\": \"2019-03-01\"}}, ) with_test_result_in_sgss ( pathogen = None , test_result = 'any' , on_or_before = None , on_or_after = None , between = None , find_first_match_in_period = None , find_last_match_in_period = None , returning = 'binary_flag' , date_format = None , return_expectations = None ) \ud83d\udd17 Finds lab test results recorded in SGSS (Second Generation Surveillance System). Please note for the dates this is used in the database as the date the specimen was taken, rather than the date of the lab result. There's an important caveat here: where a patient has multiple positive tests, SGSS groups these into \"episodes\" (referred to as \"Organism-Patient-Illness-Episodes\"). Each pathogen has a maximum episode duration (usually 2 weeks) and unless positive tests are separated by longer than this period they are assumed to be the same episode of illness. The specimen date recorded is the earliest positive specimen within the episode. For SARS-CoV-2 the episode length has been set to infinity, meaning that once a patient has tested positive every positive test will be part of the same episode and record the same specimen date. This means that using find_last_match_in_period is pointless when querying for positive results as only one date will ever be recorded and it will be the earliest. Our natural assumption, though it doesn't seem to be explicity stated in the documentation, is that every negative result is treated as unique. For more detail on SGSS in general see: https://assets.publishing.service.gov.uk/government/uploads/system/uploads/attachment_data/file/739854/PHE_Laboratory_Reporting_Guidelines.pdf Information about the SARS-CoV-2 episode length was via email from someone at the National Infection Service: The COVID-19 episode length in SGSS was set to indefinite, so all COVID-19 records from a single patient will be classified as one episode. This may change, but is set as it is due to limited information around re-infection and virus clearance. Parameters: Name Description Default pathogen pathogen we are interested in. Only SARS-CoV-2 results are included in our data extract so this will throw an error if the specified pathogen is anything other than \"SARS-CoV-2\". None test_result must be one of \"positive\", \"negative\" or \"any\" 'any' on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None find_first_match_in_period a boolean that indicates if the data returned is first event if there are multiple matches within the time period None find_last_match_in_period a boolean that indicates if the data returned is last event if there are multiple matches within the time period None returning a string indicating what type of value should be returned. The options are limited to binary_flag (which indicates if they have had the an event or not) and date (which indicate date of event and used with either find_first_match_in_period or find_last_match_in_period) 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date ; Examples: Two variables are created. One called first_tested_for_covid is the first date that a patient has a covid test never mind the result. The second called first_positive_test_date is the first date that a patient has a positive test result. first_tested_for_covid=patients.with_test_result_in_sgss( pathogen=\"SARS-CoV-2\", test_result=\"any\", on_or_after=\"2020-02-01\", find_first_match_in_period=True, returning=\"date\", date_format=\"YYYY-MM-DD\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ), first_positive_test_date=patients.with_test_result_in_sgss( pathogen=\"SARS-CoV-2\", test_result=\"positive\", on_or_after=\"2020-02-01\", find_first_match_in_period=True, returning=\"date\", date_format=\"YYYY-MM-DD\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ), with_these_clinical_events ( codelist , return_expectations = None , on_or_before = None , on_or_after = None , between = None , find_first_match_in_period = None , find_last_match_in_period = None , returning = 'binary_flag' , include_date_of_match = False , date_format = None , ignore_days_where_these_codes_occur = None , episode_defined_as = None , return_binary_flag = None , return_number_of_matches_in_period = False , return_first_date_in_period = False , return_last_date_in_period = False , include_month = False , include_day = False ) \ud83d\udd17 Patients who have had at least one of these clinical events in the defined period Parameters: Name Description Default codelist a codelist for requested event(s) required return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. If returning an integer ( returning=number_of_matches_in_period or returning=number_of_episodes ), this is a 2-item key-value dictionary of int and incidence . int is a dictionary of distribution , mean , and stddev . These values determine the shape of the dummy data returned, and the int means a int will be returned rather than a float. incidence must have a value and this is what percentage of dummy patients have a value. It needs to be a number between 0 and 1. If returning binary_flag this is a 1-item dictionary of incidence as described above. If returning either first_date_in_period or last_date_in_period , this is a 2-item dictionary of date and incidence . date is a dict of earliest and/or latest date possible. None on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a str defining the type of data to be returned. Options include binary_flag , date , number_of_matches_in_period , number_of_episodes , code , category , or numeric_value . The default value is binary_flag . 'binary_flag' find_first_match_in_period a boolean indicating if any returned date, code, category, or numeric value should be based on the first match in the period. None find_last_match_in_period a boolean indicating if any returned date, code, category, or numeric value should be based on the last match in the period. None include_date_of_match a boolean indicating if an extra column should be included in the output. The default value is False . False date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. Only used if include_date_of_match is True None ignore_days_where_these_codes_occur a codelist that contains codes for events to be ignored. if a events is found on this day, the date is not matched even it matches a code in the main codelist None episode_defined_as a string expression indicating how an episode should be defined None return_binary_flag a boolean indicating if the number of matches in a period should be returned (deprecated: use date_format instead), None return_number_of_matches_in_period a boolean indicating if the number of matches in a period should be returned (deprecated: use date_format instead) False return_first_date_in_period a boolean indicating if the first matches in a period should be returned (deprecated: use date_format instead) False return_last_date_in_period a boolean indicating if the last matches in a period should be returned (deprecated: use date_format instead) False include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag , number_of_episodes or number_of_matches_in_period ; list of strings with a date format returned if returning argument is set to first_date_in_period or last_date_in_period . a list of strings with a category represented in an extra column in the codelist object category is returned. Examples: This creates a variable haem_cancer returning the first date of a diagnosis of haematology malignancy within the time period. haem_cancer=patients.with_these_clinical_events( haem_cancer_codes, between=[\"2015-03-01\", \"2020-02-29\"], returning=\"date\", find_first_match_in_period=True, return_expectations={\"date\": {earliest; \"2015-03-01\", \"latest\": \"2020-02-29\"}}, ) with_these_codes_on_death_certificate ( codelist , on_or_before = None , on_or_after = None , between = None , match_only_underlying_cause = False , returning = 'binary_flag' , date_format = None , include_month = False , include_day = False , return_expectations = None ) \ud83d\udd17 Identify patients with ONS-registered death, where cause of death matches the supplied icd10 codelist Parameters: Name Description Default codelist a codelist for requested value required on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results between the two dates provided. The default value is None . None match_only_underlying_cause boolean for indicating if filters results to only specified cause of death. False returning a string indicating what type of value should be returned. The options are: date_of_death: Date of death binary_flag: If they died or not underlying_cause_of_death: The icd10 code corresponding to the underlying cause of death 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag or underlying_cause_of_death ; list of strings with a date format returned if returning argument is set to date_of_death Examples: A variable called died_ons_covid_flag_any is created that returns the date of death for any patients that have covid on their death certificate even if that is the not the underlying cause of death. died_ons_covid_flag_any=patients.with_these_codes_on_death_certificate( covid_codelist, on_or_after=\"2020-02-01\", match_only_underlying_cause=False, return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ) with_these_medications ( codelist , return_expectations = None , on_or_before = None , on_or_after = None , between = None , find_first_match_in_period = None , find_last_match_in_period = None , returning = 'binary_flag' , include_date_of_match = False , date_format = None , ignore_days_where_these_clinical_codes_occur = None , episode_defined_as = None , return_binary_flag = None , return_number_of_matches_in_period = False , return_first_date_in_period = False , return_last_date_in_period = False , include_month = False , include_day = False ) \ud83d\udd17 Patients who have been prescribed at least one of this list of medications in the defined period Parameters: Name Description Default codelist a codelist for requested medication(s) required return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. If returning an integer (returning number_of_matches_in_period, number_of_episodes), this is a 2-item key-value dictionary of int and incidence . int is a dictionary of distribution , mean , and stddev . These values determine the shape of the dummy data returned, and the int means a int will be returned rather than a float. incidence must have a value and this is what percentage of dummy patients have a value. It needs to be a number between 0 and 1. If returning binary_flag this is a 1-item dictionary of incidence as described above. If returning either first_date_in_period or last_date_in_period , this is a 2-item dictionary of date and incidence . date is a dict of earliest and/or latest date possible. None on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a str defining the type of data to be returned. Options include binary_flag , date , number_of_matches_in_period , number_of_episodes , code , category . The default value is binary_flag . 'binary_flag' find_first_match_in_period a boolean indicating if any returned date, code, category, or numeric value should be based on the first match in the period. None find_last_match_in_period a boolean indicating if any returned date, code, category, or numeric value should be based on the last match in the period. None include_date_of_match a boolean indicating if an extra column should be included in the output. The default value is False . False date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. Only used if include_date_of_match is True None ignore_days_where_these_clinical_codes_occur a codelist that contains codes for medications to be ignored. if a medication is found on this day, the date is not matched even it matches a code in the main codelist None episode_defined_as a string expression indicating how an episode should be defined None return_binary_flag a bool indicatin if a binary flag should be returned (deprecated: use date_format instead) None return_number_of_matches_in_period a boolean indicating if the number of matches in a period should be returned (deprecated: use date_format instead) False return_first_date_in_period a boolean indicating if the first matches in a period should be returned (deprecated: use date_format instead) False return_last_date_in_period a boolean indicating if the last matches in a period should be returned (deprecated: use date_format instead) False include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag , number_of_episodes or number_of_matches_in_period ; list of strings with a date format returned if returning argument is set to first_date_in_period or last_date_in_period . Examples: This creates a variable exacerbation_count returning an int of the number of episodes of oral steroids being prescribed within the time period where a prescription is counted as part of the same episode if it falls within 28 days of a previous prescription. Days where oral steroids are prescribed on the same day as a COPD review are also ignored as may not represent true exacerbations. exacerbation_count=patients.with_these_medications( oral_steroid_med_codes, between=[\"2019-03-01\", \"2020-02-29\"], ignore_days_where_these_clinical_codes_occur=copd_reviews, returning=\"number_of_episodes\", episode_defined_as=\"series of events each <= 28 days apart\", return_expectations={ \"int\": {\"distribution\": \"normal\", \"mean\": 2, \"stddev\": 1}, \"incidence\": 0.2, }, ) with_tpp_vaccination_record ( target_disease_matches = None , product_name_matches = None , on_or_before = None , on_or_after = None , between = None , returning = 'binary_flag' , date_format = None , find_first_match_in_period = None , find_last_match_in_period = None , return_expectations = None ) \ud83d\udd17 Identify patients with a vaccination record for a target disease within the tpp vaccination record Vaccinations can be recorded via a Vaccination Record or via prescription of a vaccine i.e a product code. Parameters: Name Description Default target_disease_matches the target disease as a string None product_name_matches the product name as a string None on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a string indicating what type of value should be returned. The options are limited to binary_flag (which indicates if they have had the vaccination or not) or a date of vaccination 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None find_first_match_in_period a boolean that indicates if the data returned is first indication of vaccination if there are multiple matches within the time period None find_last_match_in_period a boolean that indicates if the data returned is last indication of vaccination if there are multiple matches within the time period None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date Examples: A variable called flu_vaccine is created that returns the date of vaccination for any patients in the GP dataset between 2 dates. flu_vaccine=patients.with_tpp_vaccination_record( target_disease_matches=\"influenza\", between=[\"2019-09-01\", \"2020-04-01\"], returning=\"date\", date_format=\"YYYY-MM\", find_first_match_in_period=True, return_expectations={ date\": {\"earliest\": \"2019-09-01\", \"latest\": \"2020-03-29\"} } ),","title":"Full API"},{"location":"study_definition_api/#full-api","text":"","title":"Full API"},{"location":"study_definition_api/#cohortextractor.patients","text":"This module provides the methods for making a study definition These methods don't do anything; they just return their name and arguments. This provides a friendlier API than having to build some big nested data structure by hand and means we can make use of autocomplete, docstrings etc to make it a bit more discoverable.","title":"patients"},{"location":"study_definition_api/#cohortextractor.patients.address_as_of","text":"Return patients' address characteristics such as IMD as of a particular date Parameters: Name Description Default date date of interest as a string with the format YYYY-MM-DD . Filters results to the given date. required returning a str defining the type of data to be returned. options include index_of_multiple_deprivation rural_urban_classification , and msoa . The default value is None . None round_to_nearest an integer that represents how index_of_multiple_deprivation value are rounded. Only use when returning is index_of_multiple_deprivation None return_expectations a dict defining the rate and the categories returned with ratios None Returns: Type Description list of integers for rural_urban_classification and index_of_multiple_deprivation , strings for msoa Exceptions: Type Description ValueError if unsupported returning argument is provided Examples: This creates a variable called imd based on patient address. imd=patients.address_as_of( \"2020-02-29\", returning=\"index_of_multiple_deprivation\", round_to_nearest=100, return_expectations={ \"rate\": \"universal\", \"category\": {\"ratios\": {\"100\": 0.1, \"200\": 0.2, \"300\": 0.7}}, }, )","title":"address_as_of()"},{"location":"study_definition_api/#cohortextractor.patients.admitted_to_hospital","text":"Return information about admission to hospital. See https://github.com/opensafely/cohort-extractor/issues/186 for in-depth discussion and background. Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a string indicating what type of value should be returned. Options for returning are: binary_flag: if they were admitted at all date_admitted: date patient admitted to hospital date_discharged: date patient discharged from hospital number_of_matches_in_period: number of times patient was admitted in time period specified primary_diagnosis: primary diagnosis code for admission 'binary_flag' find_first_match_in_period a boolean that indicates if the data returned is first event if there are multiple matches within the time period None find_last_match_in_period a boolean that indicates if the data returned is last event if there are multiple matches within the time period None date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None with_these_diagnoses icd10 codes to match against any diagnosis None with_these_primary_diagnoses icd10 codes to match against the primary diagnosis None with_these_procedures opcs4 codes to match against the procedure None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date_admitted or date_discharged ; of integers if returning argument is set to number_of_matches_in_period . list of strings with alphanumerical code format for ICD10 code if returning argument is set to primary_diagnosis Examples: The day of each patient's first hospital admission for Covid19: covid_admission_date=patients.admitted_to_hospital( returning= \"date_admitted\", with_these_diagnoses=covid_codelist, on_or_after=\"2020-02-01\", find_first_match_in_period=True, date_format=\"YYYY-MM-DD\", return_expectations={\"date\": {\"earliest\": \"2020-03-01\"}}, )","title":"admitted_to_hospital()"},{"location":"study_definition_api/#cohortextractor.patients.admitted_to_icu","text":"Return information about being admitted to ICU. Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . None find_first_match_in_period a boolean that indicates if the data returned is first admission to icu if there are multiple admissions within the time period None find_last_match_in_period a boolean that indicates if the data returned is last admission to icu if there are multiple admissions within the time period None returning binary_flag: Whether patient attended A&E date_admitted: Date patient arrived in A&E had_respiratory_support: Whether patient received any form of respiratory support had_basic_respiratory_support: Whether patient received \"basic\" respiratory support had_advanced_respiratory_support: Whether patient received \"advanced\" respiratory support (Note that the terms \"basic\" and \"advanced\" are derived from the underlying ICNARC data.) 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. Only used if returning is binary_flag None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. This is a 2-item key-value dictionary of date and rate . None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag , had_respiratory_support , had_basic_respiratory_support or had_advanced_respiratory_support ; list of strings with a date format returned if returning argument is set to date_admitted Examples: This returns two variables \u2014 one called icu_date_admitted and another had_resp_support : has_resp_support=patients.admitted_to_icu( on_or_after=\"2020-02-01\", find_first_match_in_period=True, returning=\"had_respiratory_support\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ), icu_date_admitted=patients.admitted_to_icu( on_or_after=\"2020-02-01\", find_first_match_in_period=True, returning=\"date_admitted\", date_format=\"YYYY-MM-DD\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ),","title":"admitted_to_icu()"},{"location":"study_definition_api/#cohortextractor.patients.age_as_of","text":"Returns age of patient of at a particular date. Note can be negative if born after reference_date . Parameters: Name Description Default reference_date date of interest as a string with the format YYYY-MM-DD required return_expectations a dict defining an expectation definition that includes at least a rate and a distribution. If distribution is defined as \"population_ages\" it returns likely distribution based on known UK age bands in 2018 (see file: \"uk_population_bands_2018.csv\") None Returns: Type Description list ages as integers Examples: This creates a variable \"age\" with all patient returning an age as an integer: age=patients.age_as_of( \"2020-02-01\", return_expectations={ \"rate\" : \"universal\", \"int\" : {\"distribution\" : \"population_ages\"} } )","title":"age_as_of()"},{"location":"study_definition_api/#cohortextractor.patients.all","text":"","title":"all()"},{"location":"study_definition_api/#cohortextractor.patients.attended_emergency_care","text":"Return information about attendance of A&E from the ECDS dataset. Please note that there is a limited number of diagnoses allowed within this dataset, and so will not match with the range of diagnoses allowed in other datasets such as the primary care record. Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a string indicating what type of value should be returned. Options for returning are: binary_flag: Whether patient attended A&E date_arrived: date patient arrived in A&E number_of_matches_in_period: number of times patient attended A&E discharge_destination: SNOMED CT code of discharge destination. This will be a member of refset 999003011000000105. 'binary_flag' find_first_match_in_period a boolean that indicates if the data returned is first event if there are multiple matches within the time period None find_last_match_in_period a boolean that indicates if the data returned is last event if there are multiple matches within the time period None date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None with_these_diagnoses a list of SNOMED CT codes None discharged_to a list of members of refset 999003011000000105. None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date_arrived ; of integers if returning argument is set to number_of_matches_in_period or discharge_destination (with SNOMED CT code as a numerical value) Examples: A variable called emergency_care is created with returns a date of first attendence in A&E if patient had attended emergency room during the time period. emergency_care=patients.attended_emergency_care( on_or_after=\"2020-01-01\", returning=\"date_arrived\", date_format=\"YYYY-MM-DD\", find_first_match_in_period=True, return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, )","title":"attended_emergency_care()"},{"location":"study_definition_api/#cohortextractor.patients.care_home_status_as_of","text":"TPP have attempted to match patient addresses to care homes as stored in the CQC database. At its most simple this query returns a boolean indicating whether the patient's address (as of the supplied time) matched with a care home. It is also possible return a more complex categorisation based on attributes of the care homes in the CQC database, which can be freely downloaded here: https://www.cqc.org.uk/about-us/transparency/using-cqc-data At present the only imported fields are: LocationRequiresNursing LocationDoesNotRequireNursing But we can ask for more fields to be imported if needed. The categorised_as argument acts in effectively the same way as for the categorised_as function except that the only columns that can be referred to are those belonging to the care home table (i.e. the two nursing fields above) and the boolean IsPotentialCareHome Parameters: Name Description Default date date of interest as a string with the format YYYY-MM-DD . Filters results to the given date required categorised_as a logic expression that applies an algorithm to specific variables to create categories None return_expectations a dict defining the rate and the categories returned with ratios None Returns: Type Description list of strings which each letter representing a category as defined by the algorithm Examples: This creates a variable called care_home_type which contains a 2 letter string which represents a type of care home environment. care_home_type=patients.care_home_status_as_of( \"2020-02-01\", categorised_as={ \"PC\": \"\"\" IsPotentialCareHome AND LocationDoesNotRequireNursing='Y' AND LocationRequiresNursing='N' \"\"\", \"PN\": \"\"\" IsPotentialCareHome AND LocationDoesNotRequireNursing='N' AND LocationRequiresNursing='Y' \"\"\", \"PS\": \"IsPotentialCareHome\", \"U\": \"DEFAULT\", }, return_expectations={ \"rate\": \"universal\", \"category\": {\"ratios\": {\"PC\": 0.05, \"PN\": 0.05, \"PS\": 0.05, \"U\": 0.85,},}, }, ),","title":"care_home_status_as_of()"},{"location":"study_definition_api/#cohortextractor.patients.categorised_as","text":"Patients who had had 1 or more code from 1 or more codelists are categorised into groups according to a prescribed algorithm. Parameters: Name Description Default category_definitions a dict that defines the algorithm and the associated category The keys of the dict are strings representing categories from a defined by other arguments such as with_these_clinical_events . The values are expressions of logic using statements and AND/OR statements. A default argument should be provided if a particular patient cannot be categorised to the algorithm. required return_expectations a dict that defined the ratios of each category. The keys are the category values as strings and the values are ratios as floats. The ratios should add up to 1. None Retyrns list: of strings which each letter representing a category as defined by the algorithm Examples: This creates a variable of asthma status based on codes for asthma and categorising for recent steroid use. current_asthma=patients.categorised_as( { \"1\": \"DEFAULT\", \"2\": \"recent_asthma_code AND prednisolone_last_year = 0\" \"3\": \"recent_asthma_code AND prednisolone_last_year > 0\" }, recent_asthma_code=patients.with_these_clinical_events( asthma_codes, between=[\"2017-02-01\", \"2020-01-31\"], ), prednisolone_last_year=patients.with_these_medications( pred_codes, between=[\"2019-02-01\", \"2020-01-31\"], returning=\"number_of_matches_in_period\", ), return_expectations={ \"category\":{\"ratios\": {\"0\": 0.8, \"1\": 0.1, \"2\": 0.1}} }, )","title":"categorised_as()"},{"location":"study_definition_api/#cohortextractor.patients.date_deregistered_from_all_supported_practices","text":"Returns the date (if any) on which the patient de-registered from all practices for which OpenSAFELY has data. Events which occur in primary care after this date will not be recorded in the platform (though there may be data from other sources e.g. SGSS, CPNS). Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of strings with a date format returned if patient had deregistered, otherwise empty Examples: A variable called dereg_date is created with returns a date of de-registration if patient has deregistered from a practice within the dataset within the specified time period. dereg_date=patients.date_deregistered_from_all_supported_practices( on_or_after=\"2020-03-01\", date_format=\"YYYY-MM\", return_expectations={ {\"date\": {\"earliest\": \"2020-03-01\"}, \"incidence\": 0.05 } )","title":"date_deregistered_from_all_supported_practices()"},{"location":"study_definition_api/#cohortextractor.patients.date_of","text":"","title":"date_of()"},{"location":"study_definition_api/#cohortextractor.patients.date_of_birth","text":"Returns date of birth as a string with format \"YYYY-MM\" Parameters: Name Description Default date_format a string detailing the format of the dates for date of birth to be returned. It can be \"YYYY-MM\" or \"YYYY\" and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with month and year. None return_expectations a dictionary containing an expectation definition defining a rate and a distribution None Returns: Type Description list dates as strings with \"YYYY-MM\" format Exceptions: Type Description ValueError if Date of Birth is attempted to be returned with a YYYY-MM-DD format. Examples: This creates a variable dob with all patient returning a year and month as a string: dob=patients.date_of_birth( \"YYYY-MM\", return_expectations={ \"date\": {\"earliest\": \"1950-01-01\", \"latest\": \"today\"}, \"rate\": \"uniform\", } )","title":"date_of_birth()"},{"location":"study_definition_api/#cohortextractor.patients.died_from_any_cause","text":"Identify patients who with ONS-registered deaths Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a string indicating what type of value should be returned. The options are: date_of_death: Date of death binary_flag: If they died or not 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date_of_death Examples: A variable called died_any is created that returns the date of death for any patients that have died in the time period. died_any=patients.died_from_any_cause( on_or_after=\"2020-02-01\", returning=\"date_of_death\", date_format=\"YYYY-MM-DD\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, )","title":"died_from_any_cause()"},{"location":"study_definition_api/#cohortextractor.patients.household_as_of","text":"Return information about the household to which the patient belonged as of the reference date. This is inferred from address data using an algorithm developed by TPP (to be documented soon) so the results are not 100% reliable but are apparently pretty good. !!! args reference_date: date of interest as a string with the format `YYYY-MM-DD`. Filters results to a particular set date !!! returning \"a string indicating what type of value should be returned. The options for `returning` are:\" !!! pseudo_id \"An integer identifier for the household which has no meaning\" other than to identify individual members of the same household (0 if no household information available) !!! household_size \"the number of individuals in the household (0 if no\" household information available) !!! is_prison \"Boolean indicating whether household is a prison. See\" https://github.com/opensafely/cohort-extractor/issues/271#issuecomment-679069981 for details of how this is determined. !!! has_members_in_other_ehr_systems \"Boolean indicating whether some household\" members are registered with GPs using a different EHR system, meaning that our coverage of the household is incomplete. !!! percentage_of_members_with_data_in_this_backend \"Integer giving the (estimated)\" percentage of household members where we have EHR data available in this backend (i.e. not in other systems as above) msoa: Returns the MSOA (Middle Super Output Area) in which the household is situated return_expectations: a dictionary defining the incidence and distribution of expected value within the population in question. Returns: Type Description list of integers if returning argument is set to pseudo_id , household_size or percentage_of_members_with_data_in_this_backend . a list of 1 or 0 is returning is set to is_prison or has_members_in_other_ehr_systems Examples: household_id=patients.household_as_of( \"2020-02-01\", returning=\"pseudo_id\" ) household_size=patients.household_as_of( \"2020-02-01\", returning=\"household_size\" ),","title":"household_as_of()"},{"location":"study_definition_api/#cohortextractor.patients.maximum_of","text":"Return the maximum value over the supplied columns e.g max_value=patients.maximum_of(\"some_column\", \"another_column\") Additional columns can be defined within the function call which will be used in computing the maximum but won't themselves appear in the output: max_value=patients.maximum_of( \"some_column\", another_colum=patients.with_these_medications(...) )","title":"maximum_of()"},{"location":"study_definition_api/#cohortextractor.patients.mean_recorded_value","text":"Return patients' mean recorded value of a numerical value as defined by a codelist on a particular day within the defined period. This is important as allows us to account for multiple measurements taken on one day. The date of the measurement can be included by flagging with date format options. Parameters: Name Description Default codelist a codelist for requested value required on_most_recent_day_of_measurement boolean flag for requesting measurements be on most recent date None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. This is a 3-item key-value dictionary of \"date\" and \"float\". \"date\" is dictionary itself and should contain the earliest and latest dates needed in the dummy data. float is a dictionary of distribution , mean , and stddev . These values determine the shape of the dummy data returned, and the float means a float will be returned rather than an integer. incidence must have a value and this is what percentage of dummy patients have a value. It needs to be a number between 0 and 1. None on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to measurements on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to measurements on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to measurements between the two dates provided. The default value is None . None include_measurement_date a boolean indicating if an extra column, named date_of_bmi , should be included in the output. The default value is False . False date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. Only used if include_measurement_date is True None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False Returns: Type Description float mean of value Examples: This creates a variable bp_sys returning a float of the most recent systolic blood pressure from the record within the time period. In the event of repeated measurements on the same day, these are averaged. Patient who do not have this information available do not return a value: bp_sys=patients.mean_recorded_value( systolic_blood_pressure_codes, on_most_recent_day_of_measurement=True, between=[\"2017-02-01\", \"2020-01-31\"], include_measurement_date=True, date_format=\"YYYY-MM\", return_expectations={ \"float\": {\"distribution\": \"normal\", \"mean\": 80, \"stddev\": 10}, \"date\": {\"earliest\": \"2019-02-01\", \"latest\": \"2020-01-31\"}, \"incidence\": 0.95, }, )","title":"mean_recorded_value()"},{"location":"study_definition_api/#cohortextractor.patients.minimum_of","text":"Return the minimum value over the supplied columns e.g min_value=patients.minimum_of(\"some_column\", \"another_column\") Note: this ignores \"empty values\" (i.e. the values used if there is no data for a particular column, such as 0.0 for numeric values or the empty string for dates). This ensures that the minimum of a column with a defined value and one with a missing value is equal to the defined value. Additional columns can be defined within the function call which will be used in computing the minimum but won't themselves appear in the output: min_value=patients.minimum_of( \"some_column\", another_colum=patients.with_these_medications(...) )","title":"minimum_of()"},{"location":"study_definition_api/#cohortextractor.patients.most_recent_bmi","text":"Return patients' most recent BMI (in the defined period) either computed from weight and height measurements or, where they are not availble, from recorded BMI values. Measurements taken when a patient was below the minimum age are ignored. The height measurement can be taken before (but not after) the defined period as long as the patient was over the minimum age at the time. The date of the measurement can be obtained using date_of(\"<bmi-column-name>\") . If the BMI is computed from weight and height then we use the date of the weight measurement for this. Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to measurements on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to measurements on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to measurements between the two dates provided. The default value is None . None minimum_age_at_measurement Measurements taken before this age will not count towards BMI calculations. It is an integer and the default value is 16. 16 return_expectations a dictionary defining the incidence and distribution of expected BMI within the population in question. This is a 3-item key-value dictionary of \"date\" and \"float\". \"date\" is dictionary itself and should contain the earliest and latest dates needed in the dummy data. float is a dictionary of distribution , mean , and stddev . These values determine the shape of the dummy data returned, and the float means a float will be returned rather than an integer. incidence must have a value and this is what percentage of dummy patients have a BMI. It needs to be a number between 0 and 1. None include_measurement_date a boolean indicating if an extra column, named date_of_bmi , should be included in the output. The default value is False . False date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. Only used if include_measurement_date is True None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False Returns: Type Description float most recent BMI Examples: This creates a variable \"bmi\" returning a float of the most recent bmi calculated from recorded height and weight, or from a recorded bmi record. Patient who do not have this information available do not return a value: bmi=patients.most_recent_bmi( between=[\"2010-02-01\", \"2020-01-31\"], minimum_age_at_measurement=18, include_measurement_date=True, date_format=\"YYYY-MM\", return_expectations={ \"date\": {\"earliest\": \"2010-02-01\", \"latest\": \"2020-01-31\"}, \"float\": {\"distribution\": \"normal\", \"mean\": 28, \"stddev\": 8}, \"incidence\": 0.80, } )","title":"most_recent_bmi()"},{"location":"study_definition_api/#cohortextractor.patients.random_sample","text":"Flags a random sample of approximately percent patients. Parameters: Name Description Default percent an integer between 1 and 100 for the percent of patients to include within the random sample None return_expectations a dict containing an expectations definition defining at least an incidence None Returns: Type Description list of integers of 1 or 0 Examples: This creates a variable example , flagging approximately 10% of the population with the value 1 : example=patients.random_sample(percent=10, expectations={'incidence': 0.1})","title":"random_sample()"},{"location":"study_definition_api/#cohortextractor.patients.registered_as_of","text":"All patients registered on the given date. Note this function passes arguments to registered_with_one_practice_between() Parameters: Name Description Default reference_date date of interest as a string with the format YYYY-MM-DD . Filters results to patients registered at a practice on the given date. required return_expectations a dictionary containing an expectation definition defining an incidence between 0 and 1 . None Returns: Type Description list of integers of 1 or 0 . Examples: This creates a variable \"registered\" with patient returning an integer of 1 if patient registered at date. Patients who are not registered return an integer of 0 : registered=patients.registered_as_of( \"2020-03-01\", return_expectations={\"incidence\": 0.98} )","title":"registered_as_of()"},{"location":"study_definition_api/#cohortextractor.patients.registered_practice_as_of","text":"Return patients' practice address characteristics such as STP or MSOA Parameters: Name Description Default date date of interest as a string with the format YYYY-MM-DD . Filters results to the given date. required returning a str defining the type of data to be returned. options include msoa , nuts1_region_name, and stp_code . The default value is None . None return_expectations a dict defining the rate and the categories returned with ratios None Returns: Type Description list of strings Exceptions: Type Description ValueError if unsupported returning argument is provided Examples: This creates a variable called region based on practice address of the patient: region=patients.registered_practice_as_of( \"2020-02-01\", returning=\"nuts1_region_name\", return_expectations={ \"rate\": \"universal\", \"category\": { \"ratios\": { \"North East\": 0.1, \"North West\": 0.1, \"Yorkshire and the Humber\": 0.1, \"East Midlands\": 0.1, \"West Midlands\": 0.1, \"East of England\": 0.1, \"London\": 0.2, \"South East\": 0.2, }, }, }, )","title":"registered_practice_as_of()"},{"location":"study_definition_api/#cohortextractor.patients.registered_with_one_practice_between","text":"All patients registered with the same practice through the given period Parameters: Name Description Default start_date start date of interest of period as a string with the format YYYY-MM-DD . Together with end date, this filters results to patients registered at a practice between two dates required end_date end date of interest of period as a string with the format YYYY-MM-DD . Together with start date, this filters results to patients registered at a practice between two dates required return_expectations a dictionary containing an expectation definition defining an incidence between 0 and 1 . None Returns: Type Description list of integers of 1 or 0 . Examples: This creates a variable registered_one with patient returning an integer of 1 if patient registered at one practice between two dates. Patients who are not registered return an integer of 0 . registered_one=patients.registered_with_one_practice_between( start_date=\"2020-03-01\", end_date=\"2020-06-01\", return_expectations={\"incidence\": 0.90} )","title":"registered_with_one_practice_between()"},{"location":"study_definition_api/#cohortextractor.patients.satisfying","text":"Patients who meet the criteria for one or more expressions. Used as a way of combining groups or making subgroups based on certain characteristics. Parameters: Name Description Default expression a string in that links together 2 or more expressions into one statement. key variables for this expression can be defined under this statement or anywhere in study definition. required return_expectations a dictionary defining the rate of expected value within the population in question None Returns: Type Description list of integers, either 1 or 0 Examples: This creates a study population where patients included have asthma and not copd: population=patients.satisfying( \"\"\" has_asthma AND NOT has_copd \"\"\", has_asthma=patients.with_these_clinical_events( asthma_codes, between=[\"2017-02-28\", \"2020-02-29\"], has_copd=patients.with_these_clinical_events( copd_codes, between=[\"2017-02-28\", \"2020-02-29\"], ), )","title":"satisfying()"},{"location":"study_definition_api/#cohortextractor.patients.sex","text":"Returns the sex of the patient. Parameters: Name Description Default return_expectations a dict containing an expectation definition defining a rate and a ratio for sexes None Returns: Type Description list \"M\" male, \"F\" female, \"I\" intersex, or \"U\" unknown. Examples: This creates a variable 'sex' with all patients returning a sex of either \"M\", \"F\" or \"\" sex=patients.sex( return_expectations={ \"rate\": \"universal\", \"category\": {\"ratios\": {\"M\": 0.49, \"F\": 0.51}}, } )","title":"sex()"},{"location":"study_definition_api/#cohortextractor.patients.with_complete_gp_consultation_history_between","text":"The concept of a \"consultation\" in EHR systems does not map exactly to the GP-patient interaction we're interested in (see above) so there is some processing required on the part of the EHR vendor to produce the consultation record we need. This does not happen automatically as part of the GP2GP transfer, and therefore this query can be used to find just those patients for which the full history is available. This means finding patients who have been continuously registered with a single TPP-using practice throughout a time period. Parameters: Name Description Default start_date start date of interest as a string with the format YYYY-MM-DD required end_date end date of interest as a string with the format YYYY-MM-DD required return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None","title":"with_complete_gp_consultation_history_between()"},{"location":"study_definition_api/#cohortextractor.patients.with_complete_history_between","text":"All patients for which we have a full set of records between the given dates Parameters: Name Description Default start_date start date of interest of period as a string with the format YYYY-MM-DD . Together with end date, this filters results to patients registered at a practice between two dates who have a complete history. required end_date end date of interest of period as a string with the format YYYY-MM-DD . Together with start date, this filters results to patients registered at a practice between two dates who have a complete history. required return_expectations a dictionary containing an expectation definition defining an incidence between 0 and 1 . None Returns: Type Description list of integers of 1 or 0 Examples: This creates a variable has_consultation_history with patient returning an integer of 1 if patient registered at one practice between two dates and has a completed record. Patients who are not registered with a complete record return an integer of 0 . has_consultation_history=patients.with_complete_gp_consultation_history_between( start_date=\"2019-02-01\", end_date=\"2020-01-31\", return_expectations={\"incidence\": 0.9}, )","title":"with_complete_history_between()"},{"location":"study_definition_api/#cohortextractor.patients.with_death_recorded_in_cpns","text":"Identify patients who with death registered in CPNS dataset Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a string indicating what type of value should be returned. The options are: date_of_death: Date of death binary_flag: If they died or not 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date_of_death Examples: A variable called died_date_cpns is created that returns the date of death for any patients have died in the CPNS dataset. died_date_cpns=patients.with_death_recorded_in_cpns( on_or_after=\"2020-02-01\", returning=\"date_of_death\", include_month=True, include_day=True, return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ),","title":"with_death_recorded_in_cpns()"},{"location":"study_definition_api/#cohortextractor.patients.with_death_recorded_in_primary_care","text":"Identify patients with a date-of-death in their primary care record. There is generally a lag between the death being recorded in ONS data and appearing in the primary care record, but the date itself is usually reliable when it appears. By contrast, cause of death is often not accurate in the primary care record so we don't make it available to query here. Args: !!! on_or_before \"date of interest as a string with the format `YYYY-MM-DD`. Filters results\" on or before the given date. The default value is `None`. !!! on_or_after \"date of interest as a string with the format `YYYY-MM-DD`. Filters results\" on or after the given date. The default value is `None`. !!! between \"two dates of interest as a list with each date as a string with the format `YYYY-MM-DD`.\" Filters results to between the two dates provided. The default value is `None`. !!! returning \"a string indicating what type of value should be returned. The options are:\" date_of_death: Date of death binary_flag: If they died or not !!! date_format \"a string detailing the format of the dates to be returned. It can be `YYYY-MM-DD`,\" `YYYY-MM` or `YYYY` and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. !!! return_expectations \"a dictionary defining the incidence and distribution of expected value\" within the population in question. Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date_of_death Examples: A variable called died_date_gp is created that returns the date of death for any patients have died in the GP dataset. died_date_gp=patients.with_death_recorded_in_primary_care( on_or_after=\"2020-02-01\", returning=\"date_of_death\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ),","title":"with_death_recorded_in_primary_care()"},{"location":"study_definition_api/#cohortextractor.patients.with_gp_consultations","text":"These are GP-patient interactions, either in person or via phone/video call. The concept of a \"consultation\" in EHR systems is generally broader and might include things like updating a phone number with the receptionist. Parameters: Name Description Default on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None find_first_match_in_period a boolean that indicates if the data returned is first event if there are multiple matches within the time period None find_last_match_in_period a boolean that indicates if the data returned is last event if there are multiple matches within the time period None returning a string indicating what type of value should be returned. The options are limited to binary_flag (which indicates if they have had the an event or not), date (which indicate date of event and used with either find_first_match_in_period or find_last_match_in_period), or number_of_matches_in_period (which counts the events in the period) 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date ; a list of integers if returning argument is set to number_of_matches_in_period Examples: A variable called gp_count is created that counts number of GP consultation between two dates in 2019. gp_count=patients.with_gp_consultations( between=[\"2019-01-01\", \"2020-12-31\"], returning=\"number_of_matches_in_period\", return_expectations={ \"int\": {\"distribution\": \"normal\", \"mean\": 6, \"stddev\": 3}, \"incidence\": 0.6, }, )","title":"with_gp_consultations()"},{"location":"study_definition_api/#cohortextractor.patients.with_high_cost_drugs","text":"Returns data from the High Cost Drugs Dataset More details available in this notebook: https://github.com/opensafely/highcostdrugs-research/blob/master/analysis/High%20Cost%20Drugs%20Dataset.ipynb Parameters: Name Description Default drug_name_matches a drug name as a string, or a list of such names, or a codelist containing such names. Results will be filtered to just rows matching any of the supplied names exactly. Note these are not standardised names, they are just the names however they come to us in the original data. None returning a string indicating what type of value should be returned. Options are: binary_flag: if the patient received any matching drugs date: date drug received 'binary_flag' on_or_before as described elsewhere None on_or_after as described elsewhere None between as described elsewhere None find_first_match_in_period as described elsewhere None find_last_match_in_period as described elsewhere None date_format only \"YYYY\" and \"YYYY-MM\" supported here as day level data not available None return_expectations as described elsewhere None Examples: The first month in which each patient received \"ACME Drug\" after March 2019: covid_admission_date=patients.with_high_cost_drugs( drug_name_matches=\"ACME Drug\", on_or_after=\"2019-03-01\", find_first_match_in_period=True, returning=\"date\", date_format=\"YYYY-MM\", return_expectations={\"date\": {\"earliest\": \"2019-03-01\"}}, )","title":"with_high_cost_drugs()"},{"location":"study_definition_api/#cohortextractor.patients.with_test_result_in_sgss","text":"Finds lab test results recorded in SGSS (Second Generation Surveillance System). Please note for the dates this is used in the database as the date the specimen was taken, rather than the date of the lab result. There's an important caveat here: where a patient has multiple positive tests, SGSS groups these into \"episodes\" (referred to as \"Organism-Patient-Illness-Episodes\"). Each pathogen has a maximum episode duration (usually 2 weeks) and unless positive tests are separated by longer than this period they are assumed to be the same episode of illness. The specimen date recorded is the earliest positive specimen within the episode. For SARS-CoV-2 the episode length has been set to infinity, meaning that once a patient has tested positive every positive test will be part of the same episode and record the same specimen date. This means that using find_last_match_in_period is pointless when querying for positive results as only one date will ever be recorded and it will be the earliest. Our natural assumption, though it doesn't seem to be explicity stated in the documentation, is that every negative result is treated as unique. For more detail on SGSS in general see: https://assets.publishing.service.gov.uk/government/uploads/system/uploads/attachment_data/file/739854/PHE_Laboratory_Reporting_Guidelines.pdf Information about the SARS-CoV-2 episode length was via email from someone at the National Infection Service: The COVID-19 episode length in SGSS was set to indefinite, so all COVID-19 records from a single patient will be classified as one episode. This may change, but is set as it is due to limited information around re-infection and virus clearance. Parameters: Name Description Default pathogen pathogen we are interested in. Only SARS-CoV-2 results are included in our data extract so this will throw an error if the specified pathogen is anything other than \"SARS-CoV-2\". None test_result must be one of \"positive\", \"negative\" or \"any\" 'any' on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None find_first_match_in_period a boolean that indicates if the data returned is first event if there are multiple matches within the time period None find_last_match_in_period a boolean that indicates if the data returned is last event if there are multiple matches within the time period None returning a string indicating what type of value should be returned. The options are limited to binary_flag (which indicates if they have had the an event or not) and date (which indicate date of event and used with either find_first_match_in_period or find_last_match_in_period) 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date ; Examples: Two variables are created. One called first_tested_for_covid is the first date that a patient has a covid test never mind the result. The second called first_positive_test_date is the first date that a patient has a positive test result. first_tested_for_covid=patients.with_test_result_in_sgss( pathogen=\"SARS-CoV-2\", test_result=\"any\", on_or_after=\"2020-02-01\", find_first_match_in_period=True, returning=\"date\", date_format=\"YYYY-MM-DD\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ), first_positive_test_date=patients.with_test_result_in_sgss( pathogen=\"SARS-CoV-2\", test_result=\"positive\", on_or_after=\"2020-02-01\", find_first_match_in_period=True, returning=\"date\", date_format=\"YYYY-MM-DD\", return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, ),","title":"with_test_result_in_sgss()"},{"location":"study_definition_api/#cohortextractor.patients.with_these_clinical_events","text":"Patients who have had at least one of these clinical events in the defined period Parameters: Name Description Default codelist a codelist for requested event(s) required return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. If returning an integer ( returning=number_of_matches_in_period or returning=number_of_episodes ), this is a 2-item key-value dictionary of int and incidence . int is a dictionary of distribution , mean , and stddev . These values determine the shape of the dummy data returned, and the int means a int will be returned rather than a float. incidence must have a value and this is what percentage of dummy patients have a value. It needs to be a number between 0 and 1. If returning binary_flag this is a 1-item dictionary of incidence as described above. If returning either first_date_in_period or last_date_in_period , this is a 2-item dictionary of date and incidence . date is a dict of earliest and/or latest date possible. None on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a str defining the type of data to be returned. Options include binary_flag , date , number_of_matches_in_period , number_of_episodes , code , category , or numeric_value . The default value is binary_flag . 'binary_flag' find_first_match_in_period a boolean indicating if any returned date, code, category, or numeric value should be based on the first match in the period. None find_last_match_in_period a boolean indicating if any returned date, code, category, or numeric value should be based on the last match in the period. None include_date_of_match a boolean indicating if an extra column should be included in the output. The default value is False . False date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. Only used if include_date_of_match is True None ignore_days_where_these_codes_occur a codelist that contains codes for events to be ignored. if a events is found on this day, the date is not matched even it matches a code in the main codelist None episode_defined_as a string expression indicating how an episode should be defined None return_binary_flag a boolean indicating if the number of matches in a period should be returned (deprecated: use date_format instead), None return_number_of_matches_in_period a boolean indicating if the number of matches in a period should be returned (deprecated: use date_format instead) False return_first_date_in_period a boolean indicating if the first matches in a period should be returned (deprecated: use date_format instead) False return_last_date_in_period a boolean indicating if the last matches in a period should be returned (deprecated: use date_format instead) False include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag , number_of_episodes or number_of_matches_in_period ; list of strings with a date format returned if returning argument is set to first_date_in_period or last_date_in_period . a list of strings with a category represented in an extra column in the codelist object category is returned. Examples: This creates a variable haem_cancer returning the first date of a diagnosis of haematology malignancy within the time period. haem_cancer=patients.with_these_clinical_events( haem_cancer_codes, between=[\"2015-03-01\", \"2020-02-29\"], returning=\"date\", find_first_match_in_period=True, return_expectations={\"date\": {earliest; \"2015-03-01\", \"latest\": \"2020-02-29\"}}, )","title":"with_these_clinical_events()"},{"location":"study_definition_api/#cohortextractor.patients.with_these_codes_on_death_certificate","text":"Identify patients with ONS-registered death, where cause of death matches the supplied icd10 codelist Parameters: Name Description Default codelist a codelist for requested value required on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results between the two dates provided. The default value is None . None match_only_underlying_cause boolean for indicating if filters results to only specified cause of death. False returning a string indicating what type of value should be returned. The options are: date_of_death: Date of death binary_flag: If they died or not underlying_cause_of_death: The icd10 code corresponding to the underlying cause of death 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag or underlying_cause_of_death ; list of strings with a date format returned if returning argument is set to date_of_death Examples: A variable called died_ons_covid_flag_any is created that returns the date of death for any patients that have covid on their death certificate even if that is the not the underlying cause of death. died_ons_covid_flag_any=patients.with_these_codes_on_death_certificate( covid_codelist, on_or_after=\"2020-02-01\", match_only_underlying_cause=False, return_expectations={ \"date\": {\"earliest\" : \"2020-02-01\"}, \"rate\" : \"exponential_increase\" }, )","title":"with_these_codes_on_death_certificate()"},{"location":"study_definition_api/#cohortextractor.patients.with_these_medications","text":"Patients who have been prescribed at least one of this list of medications in the defined period Parameters: Name Description Default codelist a codelist for requested medication(s) required return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. If returning an integer (returning number_of_matches_in_period, number_of_episodes), this is a 2-item key-value dictionary of int and incidence . int is a dictionary of distribution , mean , and stddev . These values determine the shape of the dummy data returned, and the int means a int will be returned rather than a float. incidence must have a value and this is what percentage of dummy patients have a value. It needs to be a number between 0 and 1. If returning binary_flag this is a 1-item dictionary of incidence as described above. If returning either first_date_in_period or last_date_in_period , this is a 2-item dictionary of date and incidence . date is a dict of earliest and/or latest date possible. None on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a str defining the type of data to be returned. Options include binary_flag , date , number_of_matches_in_period , number_of_episodes , code , category . The default value is binary_flag . 'binary_flag' find_first_match_in_period a boolean indicating if any returned date, code, category, or numeric value should be based on the first match in the period. None find_last_match_in_period a boolean indicating if any returned date, code, category, or numeric value should be based on the last match in the period. None include_date_of_match a boolean indicating if an extra column should be included in the output. The default value is False . False date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. Only used if include_date_of_match is True None ignore_days_where_these_clinical_codes_occur a codelist that contains codes for medications to be ignored. if a medication is found on this day, the date is not matched even it matches a code in the main codelist None episode_defined_as a string expression indicating how an episode should be defined None return_binary_flag a bool indicatin if a binary flag should be returned (deprecated: use date_format instead) None return_number_of_matches_in_period a boolean indicating if the number of matches in a period should be returned (deprecated: use date_format instead) False return_first_date_in_period a boolean indicating if the first matches in a period should be returned (deprecated: use date_format instead) False return_last_date_in_period a boolean indicating if the last matches in a period should be returned (deprecated: use date_format instead) False include_month a boolean indicating if day should be included in addition to year (deprecated: use date_format instead). False include_day a boolean indicating if day should be included in addition to year and month (deprecated: use date_format instead). False Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag , number_of_episodes or number_of_matches_in_period ; list of strings with a date format returned if returning argument is set to first_date_in_period or last_date_in_period . Examples: This creates a variable exacerbation_count returning an int of the number of episodes of oral steroids being prescribed within the time period where a prescription is counted as part of the same episode if it falls within 28 days of a previous prescription. Days where oral steroids are prescribed on the same day as a COPD review are also ignored as may not represent true exacerbations. exacerbation_count=patients.with_these_medications( oral_steroid_med_codes, between=[\"2019-03-01\", \"2020-02-29\"], ignore_days_where_these_clinical_codes_occur=copd_reviews, returning=\"number_of_episodes\", episode_defined_as=\"series of events each <= 28 days apart\", return_expectations={ \"int\": {\"distribution\": \"normal\", \"mean\": 2, \"stddev\": 1}, \"incidence\": 0.2, }, )","title":"with_these_medications()"},{"location":"study_definition_api/#cohortextractor.patients.with_tpp_vaccination_record","text":"Identify patients with a vaccination record for a target disease within the tpp vaccination record Vaccinations can be recorded via a Vaccination Record or via prescription of a vaccine i.e a product code. Parameters: Name Description Default target_disease_matches the target disease as a string None product_name_matches the product name as a string None on_or_before date of interest as a string with the format YYYY-MM-DD . Filters results to on or before the given date. The default value is None . None on_or_after date of interest as a string with the format YYYY-MM-DD . Filters results to on or after the given date. The default value is None . None between two dates of interest as a list with each date as a string with the format YYYY-MM-DD . Filters results to between the two dates provided. The default value is None . None returning a string indicating what type of value should be returned. The options are limited to binary_flag (which indicates if they have had the vaccination or not) or a date of vaccination 'binary_flag' date_format a string detailing the format of the dates to be returned. It can be YYYY-MM-DD , YYYY-MM or YYYY and wherever possible the least disclosive data should be returned. i.e returning only year is less disclosive than a date with day, month and year. None find_first_match_in_period a boolean that indicates if the data returned is first indication of vaccination if there are multiple matches within the time period None find_last_match_in_period a boolean that indicates if the data returned is last indication of vaccination if there are multiple matches within the time period None return_expectations a dictionary defining the incidence and distribution of expected value within the population in question. None Returns: Type Description list of integers of 1 or 0 if returning argument is set to binary_flag ; list of strings with a date format returned if returning argument is set to date Examples: A variable called flu_vaccine is created that returns the date of vaccination for any patients in the GP dataset between 2 dates. flu_vaccine=patients.with_tpp_vaccination_record( target_disease_matches=\"influenza\", between=[\"2019-09-01\", \"2020-04-01\"], returning=\"date\", date_format=\"YYYY-MM\", find_first_match_in_period=True, return_expectations={ date\": {\"earliest\": \"2019-09-01\", \"latest\": \"2020-03-29\"} } ),","title":"with_tpp_vaccination_record()"},{"location":"workflow/","text":"This section introduces the typical OpenSAFELY workflow for a single research project. The workflow consists of a number of key steps which may be iterated over as the code is developed and the study evolves. The following assumes that a well-defined and ethically-approved research agenda has been specified, with an accompanying study protocol, and all necessary permissions for accessing the OpenSAFELY platform are in place. The workflow for a single study can typically be broken down into the following steps: Create a git repository from the template repository provided and clone it on your local machine. This repo will contain all the code relating to your project, and a history it's development over time. Write a Study Definition that specifies what data you want to extract from the database: specify the patient population (dataset rows) and variables (dataset columns) specify the expected distributions of these variables for use in dummy data specify (or create) the codelists required by the study definition , hosted by codelists.opensafely.org, and import them to the repo. Generate dummy data based on the Study Definition, for writing and testing code. Develop analysis scripts using the dummy data in R, Stata, or Python. This will include: importing and processing the dataset(s) created by the cohort extractor importing any other external files needed for analysis generating analysis outputs like tables and figures generating log files to debug the scripts when they run on the real data. Test the code by running the analysis steps specified in the project pipeline , which specifies the execution order for data extracts and analyses and the outputs to be released. Execute the analysis on the real data via the job server . This will generate outputs on the secure server. Check the output for disclosivity within the server, and redact if necessary. Release the outputs via GitHub. Repeat and iterate as necessary . These steps should always proceed with frequent git commits and code reviews where appropriate. Steps 2-5 can all be progressed on your local machine without accessing the real data. It is possible to automatically test that the analytical pipeline defined in step 5 can be successfully executed on dummy data, using the opensafely run command. This pipeline is also automatically tested against dummy data every time a new version of the repository is saved (\"pushed\") to GitHub. As well as your own Python, R or Stata scripts, other non-standard actions are available. For example, it's possible to run a matching routine that extracts a matched control population to the population defined in the study definition , without having to extract all candidate matches into a dataset first.","title":"Analysis workflow"}]}